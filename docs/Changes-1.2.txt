Incompatible Changes from GTK+-1.0 to GTK+-1.2:

* GtkAcceleratorTable has been replaced with GtkAccelGroup

* GtkMenuFactory has been replaced with GtkItemFactory, although
  a version of GtkMenuFactory is provided to ease compatibility.

* GtkButton has been changed to derive from GtkBin. 
 
 To access a button's child, use GTK_BIN (button)->child, instead
 of the old GTK_BUTTON (button)->child.

* The selection API has been slightly modified:

 gtk_selection_add_handler() and gtk_selection_add_handler_full() 
 have been removed. To supply the selection, one now register
 the targets one is interested in with:

  void gtk_selection_add_target (GtkWidget           *widget, 
	  	                 GdkAtom              selection,
			         GdkAtom              target,
			         guint                info);

 or:
  
  void gtk_selection_add_targets (GtkWidget           *widget, 
	  			  GdkAtom              selection,
				  GtkTargetEntry      *targets,
				  guint                ntargets);

 When a request for a selection is received, the new "selection_get"
 signal will be called:

   void  "selection_get"           (GtkWidget          *widget,
				    GtkSelectionData   *selection_data,
				    guint               info,
				    guint               time);

 A "time" parameter has also been added to the "selection_received"
 signal.

  void  "selection_received"       (GtkWidget          *widget,
				    GtkSelectionData   *selection_data,
				    guint               time);

* The old drag and drop API has been completely removed and replaced.
  See the reference documentation for details on the new API.

* Support for Themes has been added. In general, this does
  not affect application code, however, a few new rules should
  be observed:

   - To set a shape for a window, you must use 
     gtk_widget_shape_combine_mask() instead of 
     gdk_window_shape_combine_mask(), or the shape will be
     reset when switching themes.

   - It is no longer permissable to draw directly on an arbitrary
     widget, or to set an arbitrary widget's background pixmap.
     If you need to do that, use a GtkDrawingArea or (for a 
     toplevel) the new GtkDrawWindow widget.

* The ScrolledWindow widget no longer creates a Viewport
  automatically. Instead, it has been generalized to accept
  any "self-scrolling" widget.

  The self-scrolling widgets in the Gtk+ core are GtkViewport,
  GtkCList, GtkCTree, GtkText, and GtkLayout. All of these widgets can
  be added to a scrolled window as normal children with
  gtk_container_add() and scrollbars will be set up automatically.

  To add scrollbars to a non self-scrolling widget, (such as a GtkList),
  first add it to a viewport, then add the viewport to a scrolled window.
  The scrolled window code provides a convenience function to do this:

  void gtk_scrolled_window_add_with_viewport (GtkScrolledWindow *scrollwin,
					      GtkWidget         *child);

  This does exactly what it says - it creates a Viewport, adds the child
  widget to it, then adds the Viewport to the scrolled window.

  The scrollbars have been removed from the GtkCList and GtkCTree,
  because they are now scrolled by simply adding them to a Scrolled
  Window. The scrollbar policy is set on the scrolled window with
  gtk_scrolled_window_set_policy() and not on the child widgets
  (e.g. GtkCList's gtk_clist_set_policy() was removed).
  
* The "main loop" of GTK+ has been moved to GLib. This should not
  affect existing programs, since compatibility functions have
  been provided. However, you may want to consider migrating
  your code to use the GLib main loop directly.

  Minor known incompatibilities:

  - gtk_idle_remove_by_data() and gtk_timeout_remove_by_data() now
    work from a common pool of "input sources", so 
    gtk_idle_remove_by_data() will remove timeouts and 
    vice-versa.

* the GTK_BASIC flag was removed, and with it the corresponding
  macro and function GTK_WIDGET_BASIC() and gtk_widget_basic().
  
* All freeze/thaw methods are now recursive - that is, if you
  freeze a widget n times, you must also thaw it n times.

  Therefore, if you have code like:

  gboolean frozen;
  frozen = GTK_CLIST_FROZEN (clist);
  gtk_clist_freeze (clist);
  [...]
  if (!frozen)
    gtk_clist_thaw (clist);

  it will not work anymore. It must be, simply:

  gtk_clist_freeze (clist);
  [...]
  gtk_clist_thaw (clist);

* The thread safety in GTK+ 1.2 is slightly different than
  that which appeared in early versions in the 1.1
  development track. The main difference is that it relies on 
  the thread primitives in GLib, and on the thread-safe 
  GLib main loop.

  This means:

   - You must call g_thread_init(), then gtk_thread_init()
     in a threaded GTK+ program.

   - Idles, timeouts, and input functions are executed outside 
     of the main GTK+ lock. So, if you need to call GTK+ 
     inside of such a callback, you must surround the callback
     with a gtk_thread_enter()/gtk_thread_leave() pair.

     [ However, signals are still executed within the main
       GTK+ lock ]

     In particular, this means, if you are writing widgets
     that might be used in threaded programs, you _must_
     surround timeouts and idle functions in this matter.

   - There is no longer a special --with-threads configure
     option for GTK+. To use threads in a GTK+ program, you
     must:

      a) If you want to use the native thread implementation,
         make sure GLib found this in configuration, otherwise,
         call you must provide a thread implementation to
	 g_thread_init().
   
      b) Link with the libraries returned by:
 
           gtk-config --libs gthread

* All functions matching g_message* are deprecated

* Functions *_interp are deprecated, *_full variants are available
  instead

