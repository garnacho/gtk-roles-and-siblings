<STRUCT>
<NAME>GtkAccelGroup</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkAccelEntry</NAME>
</STRUCT>
<ENUM>
<NAME>GtkAccelFlags</NAME>
typedef enum
{
  /* should the accelerator appear in
   * the widget's display?
   */
  GTK_ACCEL_VISIBLE        = 1 << 0,
  /* should the signal associated with
   * this accelerator be also visible?
   */
  GTK_ACCEL_SIGNAL_VISIBLE = 1 << 1,
  /* may the accelerator be removed
   * again?
   */
  GTK_ACCEL_LOCKED         = 1 << 2,
  GTK_ACCEL_MASK           = 0x07
} GtkAccelFlags;
</ENUM>
<STRUCT>
<NAME>GtkAccelGroup</NAME>
struct GtkAccelGroup
{
  guint	          ref_count;
  guint	          lock_count;
  GdkModifierType modifier_mask;
  GSList         *attach_objects;
};
</STRUCT>
<STRUCT>
<NAME>GtkAccelEntry</NAME>
struct GtkAccelEntry
{
  /* key portion
   */
  GtkAccelGroup		*accel_group;
  guint			 accelerator_key;
  GdkModifierType	 accelerator_mods;
  
  GtkAccelFlags		 accel_flags;
  GtkObject		*object;
  guint			 signal_id;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_accel_group_new</NAME>
<RETURNS>GtkAccelGroup *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_accel_group_get_default</NAME>
<RETURNS>GtkAccelGroup *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_accel_group_ref</NAME>
<RETURNS>GtkAccelGroup *</RETURNS>
GtkAccelGroup	*accel_group
</FUNCTION>
<FUNCTION>
<NAME>gtk_accel_group_unref</NAME>
<RETURNS>void 	</RETURNS>
GtkAccelGroup	*accel_group
</FUNCTION>
<FUNCTION>
<NAME>gtk_accel_group_activate</NAME>
<RETURNS>gboolean  </RETURNS>
GtkAccelGroup	*accel_group,guint		 accel_key,GdkModifierType accel_mods
</FUNCTION>
<FUNCTION>
<NAME>gtk_accel_groups_activate</NAME>
<RETURNS>gboolean  </RETURNS>
GtkObject	*object,guint		 accel_key,GdkModifierType accel_mods
</FUNCTION>
<FUNCTION>
<NAME>gtk_accel_group_attach</NAME>
<RETURNS>void 	</RETURNS>
GtkAccelGroup	*accel_group,GtkObject	*object
</FUNCTION>
<FUNCTION>
<NAME>gtk_accel_group_detach</NAME>
<RETURNS>void 	</RETURNS>
GtkAccelGroup	*accel_group,GtkObject	*object
</FUNCTION>
<FUNCTION>
<NAME>gtk_accel_group_lock</NAME>
<RETURNS>void 	</RETURNS>
GtkAccelGroup	*accel_group
</FUNCTION>
<FUNCTION>
<NAME>gtk_accel_group_unlock</NAME>
<RETURNS>void 	</RETURNS>
GtkAccelGroup	*accel_group
</FUNCTION>
<FUNCTION>
<NAME>gtk_accel_group_get_entry</NAME>
<RETURNS>GtkAccelEntry *</RETURNS>
GtkAccelGroup  *accel_group,guint           accel_key,GdkModifierType accel_mods
</FUNCTION>
<FUNCTION>
<NAME>gtk_accel_group_lock_entry</NAME>
<RETURNS>void 	</RETURNS>
GtkAccelGroup	*accel_group,guint		 accel_key,GdkModifierType accel_mods
</FUNCTION>
<FUNCTION>
<NAME>gtk_accel_group_unlock_entry</NAME>
<RETURNS>void 	</RETURNS>
GtkAccelGroup	*accel_group,guint		 accel_key,GdkModifierType accel_mods
</FUNCTION>
<FUNCTION>
<NAME>gtk_accel_group_add</NAME>
<RETURNS>void 	</RETURNS>
GtkAccelGroup	*accel_group,guint		 accel_key,GdkModifierType accel_mods,GtkAccelFlags	 accel_flags,GtkObject	*object,const gchar	*accel_signal
</FUNCTION>
<FUNCTION>
<NAME>gtk_accel_group_remove</NAME>
<RETURNS>void 	</RETURNS>
GtkAccelGroup	*accel_group,guint		 accel_key,GdkModifierType accel_mods,GtkObject	*object
</FUNCTION>
<FUNCTION>
<NAME>gtk_accel_group_handle_add</NAME>
<RETURNS>void 	</RETURNS>
GtkObject	*object,guint		 accel_signal_id,GtkAccelGroup	*accel_group,guint		 accel_key,GdkModifierType accel_mods,GtkAccelFlags   accel_flags
</FUNCTION>
<FUNCTION>
<NAME>gtk_accel_group_handle_remove</NAME>
<RETURNS>void 	</RETURNS>
GtkObject	*object,GtkAccelGroup	*accel_group,guint		 accel_key,GdkModifierType accel_mods
</FUNCTION>
<FUNCTION>
<NAME>gtk_accel_group_create_add</NAME>
<RETURNS>guint 	</RETURNS>
GtkType	 class_type,GtkSignalRunType signal_flags,guint		 handler_offset
</FUNCTION>
<FUNCTION>
<NAME>gtk_accel_group_create_remove</NAME>
<RETURNS>guint 	</RETURNS>
GtkType	 class_type,GtkSignalRunType signal_flags,guint		 handler_offset
</FUNCTION>
<FUNCTION>
<NAME>gtk_accel_group_marshal_add</NAME>
<RETURNS>void 	</RETURNS>
GtkObject	*object,GtkSignalFunc	 func,gpointer	 func_data,GtkArg		*args
</FUNCTION>
<FUNCTION>
<NAME>gtk_accel_group_marshal_remove</NAME>
<RETURNS>void 	</RETURNS>
GtkObject	*object,GtkSignalFunc	 func,gpointer	 func_data,GtkArg		*args
</FUNCTION>
<FUNCTION>
<NAME>gtk_accel_groups_from_object</NAME>
<RETURNS>GSList *</RETURNS>
GtkObject	*object
</FUNCTION>
<FUNCTION>
<NAME>gtk_accel_group_entries_from_object</NAME>
<RETURNS>GSList *</RETURNS>
GtkObject	*object
</FUNCTION>
<FUNCTION>
<NAME>gtk_accelerator_valid</NAME>
<RETURNS>gboolean  </RETURNS>
guint	        keyval,GdkModifierType  modifiers
</FUNCTION>
<FUNCTION>
<NAME>gtk_accelerator_parse</NAME>
<RETURNS>void 	</RETURNS>
const gchar     *accelerator,guint	       *accelerator_key,GdkModifierType *accelerator_mods
</FUNCTION>
<FUNCTION>
<NAME>gtk_accelerator_name</NAME>
<RETURNS>gchar *</RETURNS>
guint	        accelerator_key,GdkModifierType  accelerator_mods
</FUNCTION>
<FUNCTION>
<NAME>gtk_accelerator_set_default_mod_mask</NAME>
<RETURNS>void 	</RETURNS>
GdkModifierType  default_mod_mask
</FUNCTION>
<FUNCTION>
<NAME>gtk_accelerator_get_default_mod_mask</NAME>
<RETURNS>guint 	</RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_ACCEL_LABEL</NAME>
#define GTK_TYPE_ACCEL_LABEL		(gtk_accel_label_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_ACCEL_LABEL</NAME>
#define GTK_ACCEL_LABEL(obj)		(GTK_CHECK_CAST ((obj), GTK_TYPE_ACCEL_LABEL, GtkAccelLabel))
</MACRO>
<MACRO>
<NAME>GTK_ACCEL_LABEL_CLASS</NAME>
#define GTK_ACCEL_LABEL_CLASS(klass)	(GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_ACCEL_LABEL, GtkAccelLabelClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_ACCEL_LABEL</NAME>
#define GTK_IS_ACCEL_LABEL(obj)		(GTK_CHECK_TYPE ((obj), GTK_TYPE_ACCEL_LABEL))
</MACRO>
<MACRO>
<NAME>GTK_IS_ACCEL_LABEL_CLASS</NAME>
#define GTK_IS_ACCEL_LABEL_CLASS(klass) (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_ACCEL_LABEL))
</MACRO>
<STRUCT>
<NAME>GtkAccelLabel</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkAccelLabelClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkAccelLabel</NAME>
struct GtkAccelLabel
{
  GtkLabel label;

  guint	     queue_id;
  guint	     accel_padding;
  GtkWidget *accel_widget;
  gchar     *accel_string;
  guint16     accel_string_width;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_accel_label_get_type</NAME>
<RETURNS>GtkType 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_accel_label_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
const gchar   *string
</FUNCTION>
<FUNCTION>
<NAME>gtk_accel_label_get_accel_width</NAME>
<RETURNS>guint 	</RETURNS>
GtkAccelLabel *accel_label
</FUNCTION>
<FUNCTION>
<NAME>gtk_accel_label_set_accel_widget</NAME>
<RETURNS>void 	</RETURNS>
GtkAccelLabel *accel_label,GtkWidget	    *accel_widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_accel_label_refetch</NAME>
<RETURNS>gboolean  </RETURNS>
GtkAccelLabel *accel_label
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_ADJUSTMENT</NAME>
#define GTK_TYPE_ADJUSTMENT                  (gtk_adjustment_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_ADJUSTMENT</NAME>
#define GTK_ADJUSTMENT(obj)                  (GTK_CHECK_CAST ((obj), GTK_TYPE_ADJUSTMENT, GtkAdjustment))
</MACRO>
<MACRO>
<NAME>GTK_ADJUSTMENT_CLASS</NAME>
#define GTK_ADJUSTMENT_CLASS(klass)          (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_ADJUSTMENT, GtkAdjustmentClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_ADJUSTMENT</NAME>
#define GTK_IS_ADJUSTMENT(obj)               (GTK_CHECK_TYPE ((obj), GTK_TYPE_ADJUSTMENT))
</MACRO>
<MACRO>
<NAME>GTK_IS_ADJUSTMENT_CLASS</NAME>
#define GTK_IS_ADJUSTMENT_CLASS(klass)       (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_ADJUSTMENT))
</MACRO>
<STRUCT>
<NAME>GtkAdjustment</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkAdjustmentClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkAdjustment</NAME>
struct GtkAdjustment
{
  GtkData data;
  
  gfloat lower;
  gfloat upper;
  gfloat value;
  gfloat step_increment;
  gfloat page_increment;
  gfloat page_size;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_adjustment_get_type</NAME>
<RETURNS>GtkType 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_adjustment_new</NAME>
<RETURNS>GtkObject *</RETURNS>
gfloat		  value,gfloat		  lower,gfloat		  upper,gfloat		  step_increment,gfloat		  page_increment,gfloat		  page_size
</FUNCTION>
<FUNCTION>
<NAME>gtk_adjustment_changed</NAME>
<RETURNS>void 	</RETURNS>
GtkAdjustment	 *adjustment
</FUNCTION>
<FUNCTION>
<NAME>gtk_adjustment_value_changed</NAME>
<RETURNS>void 	</RETURNS>
GtkAdjustment	 *adjustment
</FUNCTION>
<FUNCTION>
<NAME>gtk_adjustment_clamp_page</NAME>
<RETURNS>void 	</RETURNS>
GtkAdjustment	 *adjustment,gfloat		  lower,gfloat		  upper
</FUNCTION>
<FUNCTION>
<NAME>gtk_adjustment_set_value</NAME>
<RETURNS>void 	</RETURNS>
GtkAdjustment	 *adjustment,gfloat		  value
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_ALIGNMENT</NAME>
#define GTK_TYPE_ALIGNMENT                  (gtk_alignment_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_ALIGNMENT</NAME>
#define GTK_ALIGNMENT(obj)                  (GTK_CHECK_CAST ((obj), GTK_TYPE_ALIGNMENT, GtkAlignment))
</MACRO>
<MACRO>
<NAME>GTK_ALIGNMENT_CLASS</NAME>
#define GTK_ALIGNMENT_CLASS(klass)          (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_ALIGNMENT, GtkAlignmentClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_ALIGNMENT</NAME>
#define GTK_IS_ALIGNMENT(obj)               (GTK_CHECK_TYPE ((obj), GTK_TYPE_ALIGNMENT))
</MACRO>
<MACRO>
<NAME>GTK_IS_ALIGNMENT_CLASS</NAME>
#define GTK_IS_ALIGNMENT_CLASS(klass)       (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_ALIGNMENT))
</MACRO>
<STRUCT>
<NAME>GtkAlignment</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkAlignmentClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkAlignment</NAME>
struct GtkAlignment
{
  GtkBin bin;

  gfloat xalign;
  gfloat yalign;
  gfloat xscale;
  gfloat yscale;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_alignment_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_alignment_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
gfloat             xalign,gfloat             yalign,gfloat             xscale,gfloat             yscale
</FUNCTION>
<FUNCTION>
<NAME>gtk_alignment_set</NAME>
<RETURNS>void  </RETURNS>
GtkAlignment      *alignment,gfloat             xalign,gfloat             yalign,gfloat             xscale,gfloat             yscale
</FUNCTION>
<STRUCT>
<NAME>GtkArgInfo</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkArgInfo</NAME>
struct GtkArgInfo
{
  /* hash key portion */
  GtkType class_type;
  gchar *name;
  
  GtkType type;
  guint arg_flags;
  gchar *full_name;
  
  /* private fields */
  guint arg_id;
  guint seq_id;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_arg_new</NAME>
<RETURNS>GtkArg *</RETURNS>
GtkType	arg_type
</FUNCTION>
<FUNCTION>
<NAME>gtk_arg_copy</NAME>
<RETURNS>GtkArg *</RETURNS>
GtkArg       *src_arg,GtkArg       *dest_arg
</FUNCTION>
<FUNCTION>
<NAME>gtk_arg_free</NAME>
<RETURNS>void 	</RETURNS>
GtkArg       *arg,gboolean	free_contents
</FUNCTION>
<FUNCTION>
<NAME>gtk_arg_reset</NAME>
<RETURNS>void 	</RETURNS>
GtkArg       *arg
</FUNCTION>
<FUNCTION>
<NAME>gtk_arg_values_equal</NAME>
<RETURNS>gboolean 	</RETURNS>
const GtkArg *arg1,const GtkArg *arg2
</FUNCTION>
<FUNCTION>
<NAME>gtk_args_collect</NAME>
<RETURNS>gchar *</RETURNS>
GtkType	object_type,GHashTable    *arg_info_hash_table,GSList      **arg_list_p,GSList      **info_list_p,const gchar   *first_arg_name,va_list	var_args
</FUNCTION>
<FUNCTION>
<NAME>gtk_args_collect_cleanup</NAME>
<RETURNS>void 	</RETURNS>
GSList       *arg_list,GSList       *info_list
</FUNCTION>
<FUNCTION>
<NAME>gtk_arg_get_info</NAME>
<RETURNS>gchar *</RETURNS>
GtkType	object_type,GHashTable    *arg_info_hash_table,const gchar   *arg_name,GtkArgInfo   **info_p
</FUNCTION>
<FUNCTION>
<NAME>gtk_arg_type_new_static</NAME>
<RETURNS>GtkArgInfo *</RETURNS>
GtkType	base_class_type,const gchar   *arg_name,guint		class_n_args_offset,GHashTable    *arg_info_hash_table,GtkType	arg_type,guint		arg_flags,guint		arg_id
</FUNCTION>
<FUNCTION>
<NAME>gtk_args_query</NAME>
<RETURNS>GtkArg *</RETURNS>
GtkType	class_type,GHashTable    *arg_info_hash_table,guint32      **arg_flags,guint	       *n_args_p
</FUNCTION>
<FUNCTION>
<NAME>gtk_arg_name_strip_type</NAME>
<RETURNS>gchar *</RETURNS>
const gchar   *arg_name
</FUNCTION>
<FUNCTION>
<NAME>gtk_arg_info_equal</NAME>
<RETURNS>gint 	</RETURNS>
gconstpointer	 arg_info_1,gconstpointer	 arg_info_2
</FUNCTION>
<FUNCTION>
<NAME>gtk_arg_info_hash</NAME>
<RETURNS>guint 	</RETURNS>
gconstpointer	 arg_info
</FUNCTION>
<FUNCTION>
<NAME>gtk_arg_to_valueloc</NAME>
<RETURNS>void 	</RETURNS>
GtkArg	*arg,gpointer	 value_pointer
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_ARROW</NAME>
#define GTK_TYPE_ARROW                  (gtk_arrow_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_ARROW</NAME>
#define GTK_ARROW(obj)                  (GTK_CHECK_CAST ((obj), GTK_TYPE_ARROW, GtkArrow))
</MACRO>
<MACRO>
<NAME>GTK_ARROW_CLASS</NAME>
#define GTK_ARROW_CLASS(klass)          (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_ARROW, GtkArrowClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_ARROW</NAME>
#define GTK_IS_ARROW(obj)               (GTK_CHECK_TYPE ((obj), GTK_TYPE_ARROW))
</MACRO>
<MACRO>
<NAME>GTK_IS_ARROW_CLASS</NAME>
#define GTK_IS_ARROW_CLASS(klass)       (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_ARROW))
</MACRO>
<STRUCT>
<NAME>GtkArrow</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkArrowClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkArrow</NAME>
struct GtkArrow
{
  GtkMisc misc;

  gint16 arrow_type;
  gint16 shadow_type;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_arrow_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_arrow_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GtkArrowType   arrow_type,GtkShadowType  shadow_type
</FUNCTION>
<FUNCTION>
<NAME>gtk_arrow_set</NAME>
<RETURNS>void  </RETURNS>
GtkArrow      *arrow,GtkArrowType   arrow_type,GtkShadowType  shadow_type
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_ASPECT_FRAME</NAME>
#define GTK_TYPE_ASPECT_FRAME            (gtk_aspect_frame_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_ASPECT_FRAME</NAME>
#define GTK_ASPECT_FRAME(obj)            (GTK_CHECK_CAST ((obj), GTK_TYPE_ASPECT_FRAME, GtkAspectFrame))
</MACRO>
<MACRO>
<NAME>GTK_ASPECT_FRAME_CLASS</NAME>
#define GTK_ASPECT_FRAME_CLASS(klass)    (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_ASPECT_FRAME, GtkAspectFrameClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_ASPECT_FRAME</NAME>
#define GTK_IS_ASPECT_FRAME(obj)         (GTK_CHECK_TYPE ((obj), GTK_TYPE_ASPECT_FRAME))
</MACRO>
<MACRO>
<NAME>GTK_IS_ASPECT_FRAME_CLASS</NAME>
#define GTK_IS_ASPECT_FRAME_CLASS(klass) (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_ASPECT_FRAME))
</MACRO>
<STRUCT>
<NAME>GtkAspectFrame</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkAspectFrameClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkAspectFrame</NAME>
struct GtkAspectFrame
{
  GtkFrame frame;

  gfloat xalign;
  gfloat yalign;
  gfloat ratio;
  gint obey_child;

  GtkAllocation center_allocation;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_aspect_frame_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_aspect_frame_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
const gchar       *label,gfloat             xalign,gfloat             yalign,gfloat             ratio,gint               obey_child
</FUNCTION>
<FUNCTION>
<NAME>gtk_aspect_frame_set</NAME>
<RETURNS>void  </RETURNS>
GtkAspectFrame      *aspect_frame,gfloat             xalign,gfloat             yalign,gfloat             ratio,gint               obey_child
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_BUTTON_BOX</NAME>
#define	GTK_TYPE_BUTTON_BOX		(gtk_button_box_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_BUTTON_BOX</NAME>
#define GTK_BUTTON_BOX(obj)		(GTK_CHECK_CAST ((obj), GTK_TYPE_BUTTON_BOX, GtkButtonBox))
</MACRO>
<MACRO>
<NAME>GTK_BUTTON_BOX_CLASS</NAME>
#define GTK_BUTTON_BOX_CLASS(klass)	(GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_BUTTON_BOX, GtkButtonBoxClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_BUTTON_BOX</NAME>
#define GTK_IS_BUTTON_BOX(obj)		(GTK_CHECK_TYPE ((obj), GTK_TYPE_BUTTON_BOX))
</MACRO>
<MACRO>
<NAME>GTK_IS_BUTTON_BOX_CLASS</NAME>
#define GTK_IS_BUTTON_BOX_CLASS(klass)	(GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_BUTTON_BOX))
</MACRO>
<MACRO>
<NAME>GTK_BUTTONBOX_DEFAULT</NAME>
#define GTK_BUTTONBOX_DEFAULT -1
</MACRO>
<STRUCT>
<NAME>GtkButtonBox</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkButtonBoxClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkButtonBox</NAME>
struct GtkButtonBox
{
  GtkBox box;
  gint spacing;
  gint child_min_width;
  gint child_min_height;
  gint child_ipad_x;
  gint child_ipad_y;
  GtkButtonBoxStyle layout_style;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_button_box_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_button_box_get_child_size_default</NAME>
<RETURNS>void  </RETURNS>
gint *min_width, gint *min_height
</FUNCTION>
<FUNCTION>
<NAME>gtk_button_box_get_child_ipadding_default</NAME>
<RETURNS>void  </RETURNS>
gint *ipad_x, gint *ipad_y
</FUNCTION>
<FUNCTION>
<NAME>gtk_button_box_set_child_size_default</NAME>
<RETURNS>void  </RETURNS>
gint min_width, gint min_height
</FUNCTION>
<FUNCTION>
<NAME>gtk_button_box_set_child_ipadding_default</NAME>
<RETURNS>void  </RETURNS>
gint ipad_x, gint ipad_y
</FUNCTION>
<FUNCTION>
<NAME>gtk_button_box_get_spacing</NAME>
<RETURNS>gint  </RETURNS>
GtkButtonBox *widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_button_box_get_layout</NAME>
<RETURNS>GtkButtonBoxStyle  </RETURNS>
GtkButtonBox *widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_button_box_get_child_size</NAME>
<RETURNS>void  </RETURNS>
GtkButtonBox *widget,gint *min_width, gint *min_height
</FUNCTION>
<FUNCTION>
<NAME>gtk_button_box_get_child_ipadding</NAME>
<RETURNS>void  </RETURNS>
GtkButtonBox *widget, gint *ipad_x, gint *ipad_y
</FUNCTION>
<FUNCTION>
<NAME>gtk_button_box_set_spacing</NAME>
<RETURNS>void  </RETURNS>
GtkButtonBox *widget, gint spacing
</FUNCTION>
<FUNCTION>
<NAME>gtk_button_box_set_layout</NAME>
<RETURNS>void  </RETURNS>
GtkButtonBox *widget,GtkButtonBoxStyle layout_style
</FUNCTION>
<FUNCTION>
<NAME>gtk_button_box_set_child_size</NAME>
<RETURNS>void  </RETURNS>
GtkButtonBox *widget,gint min_width, gint min_height
</FUNCTION>
<FUNCTION>
<NAME>gtk_button_box_set_child_ipadding</NAME>
<RETURNS>void  </RETURNS>
GtkButtonBox *widget, gint ipad_x, gint ipad_y
</FUNCTION>
<FUNCTION>
<NAME>gtk_button_box_child_requisition</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *widget,int *nvis_children,int *width,int *height
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_BIN</NAME>
#define GTK_TYPE_BIN                  (gtk_bin_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_BIN</NAME>
#define GTK_BIN(obj)                  (GTK_CHECK_CAST ((obj), GTK_TYPE_BIN, GtkBin))
</MACRO>
<MACRO>
<NAME>GTK_BIN_CLASS</NAME>
#define GTK_BIN_CLASS(klass)          (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_BIN, GtkBinClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_BIN</NAME>
#define GTK_IS_BIN(obj)               (GTK_CHECK_TYPE ((obj), GTK_TYPE_BIN))
</MACRO>
<MACRO>
<NAME>GTK_IS_BIN_CLASS</NAME>
#define GTK_IS_BIN_CLASS(klass)       (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_BIN))
</MACRO>
<STRUCT>
<NAME>GtkBin</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkBinClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkBin</NAME>
struct GtkBin
{
  GtkContainer container;

  GtkWidget *child;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_bin_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GtkPatternSpec</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkPatternSpec</NAME>
struct GtkPatternSpec
{
  GtkMatchType	 match_type;
  guint		 pattern_length;
  gchar		*pattern;
  gchar		*pattern_reversed;
  gpointer	 user_data;
  guint		 seq_id;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_pattern_spec_init</NAME>
<RETURNS>void 	</RETURNS>
GtkPatternSpec	 *pspec,const gchar	 *pattern
</FUNCTION>
<FUNCTION>
<NAME>gtk_pattern_spec_free_segs</NAME>
<RETURNS>void 	</RETURNS>
GtkPatternSpec	 *pspec
</FUNCTION>
<FUNCTION>
<NAME>gtk_pattern_match</NAME>
<RETURNS>gboolean  </RETURNS>
GtkPatternSpec	 *pspec,guint		  string_length,const gchar	 *string,const gchar	 *string_reversed
</FUNCTION>
<FUNCTION>
<NAME>gtk_pattern_match_string</NAME>
<RETURNS>gboolean  </RETURNS>
GtkPatternSpec	 *pspec,const gchar	 *string
</FUNCTION>
<FUNCTION>
<NAME>gtk_pattern_match_simple</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar	 *pattern,const gchar	 *string
</FUNCTION>
<STRUCT>
<NAME>GtkBindingSet</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkBindingEntry</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkBindingSignal</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkBindingArg</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkBindingSet</NAME>
struct GtkBindingSet
{
  gchar			*set_name;
  gint			 priority;
  GSList		*widget_path_pspecs;
  GSList		*widget_class_pspecs;
  GSList		*class_branch_pspecs;
  GtkBindingEntry	*entries;
  GtkBindingEntry	*current;
};
</STRUCT>
<STRUCT>
<NAME>GtkBindingEntry</NAME>
struct GtkBindingEntry
{
  /* key portion
   */
  guint			 keyval;
  guint			 modifiers;
  
  GtkBindingSet		*binding_set;
  guint			destroyed : 1;
  guint			in_emission : 1;
  GtkBindingEntry	*set_next;
  GtkBindingEntry	*hash_next;
  GtkBindingSignal	*signals;
};
</STRUCT>
<STRUCT>
<NAME>GtkBindingSignal</NAME>
struct GtkBindingSignal
{
  GtkBindingSignal	*next;
  gchar			*signal_name;
  guint			 n_args;
  GtkBindingArg		*args;
};
</STRUCT>
<STRUCT>
<NAME>GtkBindingArg</NAME>
struct GtkBindingArg
{
  GtkType	arg_type;
  union {
    glong	 long_data;
    gdouble	 double_data;
    gchar	*string_data;
  } d;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_binding_set_new</NAME>
<RETURNS>GtkBindingSet *</RETURNS>
const gchar	*set_name
</FUNCTION>
<FUNCTION>
<NAME>gtk_binding_set_by_class</NAME>
<RETURNS>GtkBindingSet *</RETURNS>
gpointer	 object_class
</FUNCTION>
<FUNCTION>
<NAME>gtk_binding_set_find</NAME>
<RETURNS>GtkBindingSet *</RETURNS>
const gchar	*set_name
</FUNCTION>
<FUNCTION>
<NAME>gtk_bindings_activate</NAME>
<RETURNS>gboolean  </RETURNS>
GtkObject	*object,guint		 keyval,guint		 modifiers
</FUNCTION>
<FUNCTION>
<NAME>gtk_binding_set_activate</NAME>
<RETURNS>gboolean  </RETURNS>
GtkBindingSet	*binding_set,guint		 keyval,guint		 modifiers,GtkObject	*object
</FUNCTION>
<MACRO>
<NAME>gtk_binding_entry_add</NAME>
#define	 gtk_binding_entry_add		gtk_binding_entry_clear
</MACRO>
<FUNCTION>
<NAME>gtk_binding_entry_clear</NAME>
<RETURNS>void 	</RETURNS>
GtkBindingSet	*binding_set,guint		 keyval,guint		 modifiers
</FUNCTION>
<FUNCTION>
<NAME>gtk_binding_entry_add_signal</NAME>
<RETURNS>void 	</RETURNS>
GtkBindingSet	*binding_set,guint		 keyval,guint		 modifiers,const gchar	*signal_name,guint		 n_args,...
</FUNCTION>
<FUNCTION>
<NAME>gtk_binding_set_add_path</NAME>
<RETURNS>void 	</RETURNS>
GtkBindingSet	*binding_set,GtkPathType	 path_type,const gchar	*path_pattern,GtkPathPriorityType priority
</FUNCTION>
<FUNCTION>
<NAME>gtk_binding_entry_remove</NAME>
<RETURNS>void 	</RETURNS>
GtkBindingSet	*binding_set,guint		 keyval,guint		 modifiers
</FUNCTION>
<FUNCTION>
<NAME>gtk_binding_entry_add_signall</NAME>
<RETURNS>void 	</RETURNS>
GtkBindingSet	*binding_set,guint		 keyval,guint		 modifiers,const gchar	*signal_name,GSList		*binding_args
</FUNCTION>
<FUNCTION>
<NAME>gtk_binding_parse_binding</NAME>
<RETURNS>guint 	</RETURNS>
GScanner	*scanner
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_BOX</NAME>
#define GTK_TYPE_BOX		(gtk_box_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_BOX</NAME>
#define GTK_BOX(obj)		(GTK_CHECK_CAST ((obj), GTK_TYPE_BOX, GtkBox))
</MACRO>
<MACRO>
<NAME>GTK_BOX_CLASS</NAME>
#define GTK_BOX_CLASS(klass)	(GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_BOX, GtkBoxClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_BOX</NAME>
#define GTK_IS_BOX(obj)		(GTK_CHECK_TYPE ((obj), GTK_TYPE_BOX))
</MACRO>
<MACRO>
<NAME>GTK_IS_BOX_CLASS</NAME>
#define GTK_IS_BOX_CLASS(klass)	(GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_BOX))
</MACRO>
<STRUCT>
<NAME>GtkBox</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkBoxClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkBoxChild</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkBox</NAME>
struct GtkBox
{
  GtkContainer container;
  
  GList *children;
  gint16 spacing;
  guint homogeneous : 1;
};
</STRUCT>
<STRUCT>
<NAME>GtkBoxChild</NAME>
struct GtkBoxChild
{
  GtkWidget *widget;
  guint16 padding;
  guint expand : 1;
  guint fill : 1;
  guint pack : 1;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_box_get_type</NAME>
<RETURNS>GtkType 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_box_pack_start</NAME>
<RETURNS>void 	</RETURNS>
GtkBox	     *box,GtkWidget    *child,gboolean      expand,gboolean      fill,guint	      padding
</FUNCTION>
<FUNCTION>
<NAME>gtk_box_pack_end</NAME>
<RETURNS>void 	</RETURNS>
GtkBox	     *box,GtkWidget    *child,gboolean      expand,gboolean      fill,guint	      padding
</FUNCTION>
<FUNCTION>
<NAME>gtk_box_pack_start_defaults</NAME>
<RETURNS>void 	</RETURNS>
GtkBox	     *box,GtkWidget    *widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_box_pack_end_defaults</NAME>
<RETURNS>void 	</RETURNS>
GtkBox	     *box,GtkWidget    *widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_box_set_homogeneous</NAME>
<RETURNS>void 	</RETURNS>
GtkBox	     *box,gboolean      homogeneous
</FUNCTION>
<FUNCTION>
<NAME>gtk_box_set_spacing</NAME>
<RETURNS>void 	</RETURNS>
GtkBox	     *box,gint	      spacing
</FUNCTION>
<FUNCTION>
<NAME>gtk_box_reorder_child</NAME>
<RETURNS>void 	</RETURNS>
GtkBox	     *box,GtkWidget    *child,gint	      position
</FUNCTION>
<FUNCTION>
<NAME>gtk_box_query_child_packing</NAME>
<RETURNS>void 	</RETURNS>
GtkBox	     *box,GtkWidget    *child,gboolean     *expand,gboolean     *fill,guint	     *padding,GtkPackType  *pack_type
</FUNCTION>
<FUNCTION>
<NAME>gtk_box_set_child_packing</NAME>
<RETURNS>void 	</RETURNS>
GtkBox	     *box,GtkWidget    *child,gboolean      expand,gboolean      fill,guint	      padding,GtkPackType   pack_type
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_BUTTON</NAME>
#define GTK_TYPE_BUTTON			(gtk_button_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_BUTTON</NAME>
#define GTK_BUTTON(obj)			(GTK_CHECK_CAST ((obj), GTK_TYPE_BUTTON, GtkButton))
</MACRO>
<MACRO>
<NAME>GTK_BUTTON_CLASS</NAME>
#define GTK_BUTTON_CLASS(klass)		(GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_BUTTON, GtkButtonClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_BUTTON</NAME>
#define GTK_IS_BUTTON(obj)		(GTK_CHECK_TYPE ((obj), GTK_TYPE_BUTTON))
</MACRO>
<MACRO>
<NAME>GTK_IS_BUTTON_CLASS</NAME>
#define GTK_IS_BUTTON_CLASS(klass)	(GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_BUTTON))
</MACRO>
<STRUCT>
<NAME>GtkButton</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkButtonClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkButton</NAME>
struct GtkButton
{
  GtkBin bin;

  GtkWidget *child /* deprecapted field,
		    * use GTK_BIN (button)->child instead
		    */;

  guint in_button : 1;
  guint button_down : 1;
  guint relief : 2;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_button_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_button_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_button_new_with_label</NAME>
<RETURNS>GtkWidget *</RETURNS>
const gchar *label
</FUNCTION>
<FUNCTION>
<NAME>gtk_button_pressed</NAME>
<RETURNS>void  </RETURNS>
GtkButton *button
</FUNCTION>
<FUNCTION>
<NAME>gtk_button_released</NAME>
<RETURNS>void  </RETURNS>
GtkButton *button
</FUNCTION>
<FUNCTION>
<NAME>gtk_button_clicked</NAME>
<RETURNS>void  </RETURNS>
GtkButton *button
</FUNCTION>
<FUNCTION>
<NAME>gtk_button_enter</NAME>
<RETURNS>void  </RETURNS>
GtkButton *button
</FUNCTION>
<FUNCTION>
<NAME>gtk_button_leave</NAME>
<RETURNS>void  </RETURNS>
GtkButton *button
</FUNCTION>
<FUNCTION>
<NAME>gtk_button_set_relief</NAME>
<RETURNS>void  </RETURNS>
GtkButton *button,GtkReliefStyle newstyle
</FUNCTION>
<FUNCTION>
<NAME>gtk_button_get_relief</NAME>
<RETURNS>GtkReliefStyle  </RETURNS>
GtkButton *button
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_CALENDAR</NAME>
#define GTK_TYPE_CALENDAR		   (gtk_calendar_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_CALENDAR</NAME>
#define GTK_CALENDAR(obj)		   (GTK_CHECK_CAST ((obj), GTK_TYPE_CALENDAR, GtkCalendar))
</MACRO>
<MACRO>
<NAME>GTK_CALENDAR_CLASS</NAME>
#define GTK_CALENDAR_CLASS(klass)	   (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_CALENDAR, GtkCalendarClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_CALENDAR</NAME>
#define GTK_IS_CALENDAR(obj)		   (GTK_CHECK_TYPE ((obj), GTK_TYPE_CALENDAR))
</MACRO>
<MACRO>
<NAME>GTK_IS_CALENDAR_CLASS</NAME>
#define GTK_IS_CALENDAR_CLASS(klass)	   (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_CALENDAR))
</MACRO>
<STRUCT>
<NAME>GtkCalendar</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkCalendarClass</NAME>
</STRUCT>
<ENUM>
<NAME>GtkCalendarDisplayOptions</NAME>
typedef enum
{
  GTK_CALENDAR_SHOW_HEADING		= 1 << 0,
  GTK_CALENDAR_SHOW_DAY_NAMES		= 1 << 1,
  GTK_CALENDAR_NO_MONTH_CHANGE		= 1 << 2,
  GTK_CALENDAR_SHOW_WEEK_NUMBERS	= 1 << 3,
  GTK_CALENDAR_WEEK_START_MONDAY	= 1 << 4
} GtkCalendarDisplayOptions;
</ENUM>
<STRUCT>
<NAME>GtkCalendar</NAME>
struct GtkCalendar
{
  GtkWidget widget;
  
  GtkStyle  *header_style;
  GtkStyle  *label_style;
  
  gint month;
  gint year;
  gint selected_day;
  
  gint day_month[6][7];
  gint day[6][7];
  
  gint num_marked_dates;
  gint marked_date[31];
  GtkCalendarDisplayOptions  display_flags;
  GdkColor marked_date_color[31];
  
  GdkGC *gc;
  GdkGC *xor_gc;

  gint focus_row;
  gint focus_col;

  gint highlight_row;
  gint highlight_col;
  
  gpointer private_data;
  gchar grow_space [32];
};
</STRUCT>
<FUNCTION>
<NAME>gtk_calendar_get_type</NAME>
<RETURNS>GtkType 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_calendar_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_calendar_select_month</NAME>
<RETURNS>gint 	</RETURNS>
GtkCalendar *calendar,guint	      month,guint	      year
</FUNCTION>
<FUNCTION>
<NAME>gtk_calendar_select_day</NAME>
<RETURNS>void 	</RETURNS>
GtkCalendar *calendar,guint	      day
</FUNCTION>
<FUNCTION>
<NAME>gtk_calendar_mark_day</NAME>
<RETURNS>gint 	</RETURNS>
GtkCalendar *calendar,guint	      day
</FUNCTION>
<FUNCTION>
<NAME>gtk_calendar_unmark_day</NAME>
<RETURNS>gint 	</RETURNS>
GtkCalendar *calendar,guint	      day
</FUNCTION>
<FUNCTION>
<NAME>gtk_calendar_clear_marks</NAME>
<RETURNS>void 	</RETURNS>
GtkCalendar *calendar
</FUNCTION>
<FUNCTION>
<NAME>gtk_calendar_display_options</NAME>
<RETURNS>void 	</RETURNS>
GtkCalendar		  *calendar,GtkCalendarDisplayOptions flags
</FUNCTION>
<FUNCTION>
<NAME>gtk_calendar_get_date</NAME>
<RETURNS>void 	</RETURNS>
GtkCalendar *calendar,guint	     *year,guint	     *month,guint	     *day
</FUNCTION>
<FUNCTION>
<NAME>gtk_calendar_freeze</NAME>
<RETURNS>void 	</RETURNS>
GtkCalendar *calendar
</FUNCTION>
<FUNCTION>
<NAME>gtk_calendar_thaw</NAME>
<RETURNS>void 	</RETURNS>
GtkCalendar *calendar
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_CHECK_BUTTON</NAME>
#define GTK_TYPE_CHECK_BUTTON                  (gtk_check_button_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_CHECK_BUTTON</NAME>
#define GTK_CHECK_BUTTON(obj)                  (GTK_CHECK_CAST ((obj), GTK_TYPE_CHECK_BUTTON, GtkCheckButton))
</MACRO>
<MACRO>
<NAME>GTK_CHECK_BUTTON_CLASS</NAME>
#define GTK_CHECK_BUTTON_CLASS(klass)          (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_CHECK_BUTTON, GtkCheckButtonClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_CHECK_BUTTON</NAME>
#define GTK_IS_CHECK_BUTTON(obj)               (GTK_CHECK_TYPE ((obj), GTK_TYPE_CHECK_BUTTON))
</MACRO>
<MACRO>
<NAME>GTK_IS_CHECK_BUTTON_CLASS</NAME>
#define GTK_IS_CHECK_BUTTON_CLASS(klass)       (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_CHECK_BUTTON))
</MACRO>
<STRUCT>
<NAME>GtkCheckButton</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkCheckButtonClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkCheckButton</NAME>
struct GtkCheckButton
{
  GtkToggleButton toggle_button;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_check_button_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_check_button_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_check_button_new_with_label</NAME>
<RETURNS>GtkWidget *</RETURNS>
const gchar *label
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_CHECK_MENU_ITEM</NAME>
#define GTK_TYPE_CHECK_MENU_ITEM	    (gtk_check_menu_item_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_CHECK_MENU_ITEM</NAME>
#define GTK_CHECK_MENU_ITEM(obj)	    (GTK_CHECK_CAST ((obj), GTK_TYPE_CHECK_MENU_ITEM, GtkCheckMenuItem))
</MACRO>
<MACRO>
<NAME>GTK_CHECK_MENU_ITEM_CLASS</NAME>
#define GTK_CHECK_MENU_ITEM_CLASS(klass)    (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_CHECK_MENU_ITEM, GtkCheckMenuItemClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_CHECK_MENU_ITEM</NAME>
#define GTK_IS_CHECK_MENU_ITEM(obj)	    (GTK_CHECK_TYPE ((obj), GTK_TYPE_CHECK_MENU_ITEM))
</MACRO>
<MACRO>
<NAME>GTK_IS_CHECK_MENU_ITEM_CLASS</NAME>
#define GTK_IS_CHECK_MENU_ITEM_CLASS(klass) (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_CHECK_MENU_ITEM))
</MACRO>
<STRUCT>
<NAME>GtkCheckMenuItem</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkCheckMenuItemClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkCheckMenuItem</NAME>
struct GtkCheckMenuItem
{
  GtkMenuItem menu_item;
  
  guint active : 1;
  guint always_show_toggle : 1;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_check_menu_item_get_type</NAME>
<RETURNS>GtkType 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_check_menu_item_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_check_menu_item_new_with_label</NAME>
<RETURNS>GtkWidget *</RETURNS>
const gchar	 *label
</FUNCTION>
<FUNCTION>
<NAME>gtk_check_menu_item_set_active</NAME>
<RETURNS>void 	</RETURNS>
GtkCheckMenuItem *check_menu_item,gboolean	  is_active
</FUNCTION>
<FUNCTION>
<NAME>gtk_check_menu_item_set_show_toggle</NAME>
<RETURNS>void 	</RETURNS>
GtkCheckMenuItem *menu_item,gboolean	  always
</FUNCTION>
<FUNCTION>
<NAME>gtk_check_menu_item_toggled</NAME>
<RETURNS>void 	</RETURNS>
GtkCheckMenuItem *check_menu_item
</FUNCTION>
<ENUM>
<NAME>GtkCellType</NAME>
typedef enum
{
  GTK_CELL_EMPTY,
  GTK_CELL_TEXT,
  GTK_CELL_PIXMAP,
  GTK_CELL_PIXTEXT,
  GTK_CELL_WIDGET
} GtkCellType;
</ENUM>
<ENUM>
<NAME>GtkCListDragPos</NAME>
typedef enum
{
  GTK_CLIST_DRAG_NONE,
  GTK_CLIST_DRAG_BEFORE,
  GTK_CLIST_DRAG_INTO,
  GTK_CLIST_DRAG_AFTER
} GtkCListDragPos;
</ENUM>
<ENUM>
<NAME>GtkButtonAction</NAME>
typedef enum
{
  GTK_BUTTON_IGNORED = 0,
  GTK_BUTTON_SELECTS = 1 << 0,
  GTK_BUTTON_DRAGS   = 1 << 1,
  GTK_BUTTON_EXPANDS = 1 << 2
} GtkButtonAction;
</ENUM>
<MACRO>
<NAME>GTK_TYPE_CLIST</NAME>
#define GTK_TYPE_CLIST            (gtk_clist_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_CLIST</NAME>
#define GTK_CLIST(obj)            (GTK_CHECK_CAST ((obj), GTK_TYPE_CLIST, GtkCList))
</MACRO>
<MACRO>
<NAME>GTK_CLIST_CLASS</NAME>
#define GTK_CLIST_CLASS(klass)    (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_CLIST, GtkCListClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_CLIST</NAME>
#define GTK_IS_CLIST(obj)         (GTK_CHECK_TYPE ((obj), GTK_TYPE_CLIST))
</MACRO>
<MACRO>
<NAME>GTK_IS_CLIST_CLASS</NAME>
#define GTK_IS_CLIST_CLASS(klass) (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_CLIST))
</MACRO>
<MACRO>
<NAME>GTK_CLIST_FLAGS</NAME>
#define GTK_CLIST_FLAGS(clist)             (GTK_CLIST (clist)->flags)
</MACRO>
<MACRO>
<NAME>GTK_CLIST_SET_FLAG</NAME>
#define GTK_CLIST_SET_FLAG(clist,flag)     (GTK_CLIST_FLAGS (clist) |= (GTK_ ## flag))
</MACRO>
<MACRO>
<NAME>GTK_CLIST_UNSET_FLAG</NAME>
#define GTK_CLIST_UNSET_FLAG(clist,flag)   (GTK_CLIST_FLAGS (clist) &= ~(GTK_ ## flag))
</MACRO>
<MACRO>
<NAME>GTK_CLIST_IN_DRAG</NAME>
#define GTK_CLIST_IN_DRAG(clist)           (GTK_CLIST_FLAGS (clist) & GTK_CLIST_IN_DRAG)
</MACRO>
<MACRO>
<NAME>GTK_CLIST_ROW_HEIGHT_SET</NAME>
#define GTK_CLIST_ROW_HEIGHT_SET(clist)    (GTK_CLIST_FLAGS (clist) & GTK_CLIST_ROW_HEIGHT_SET)
</MACRO>
<MACRO>
<NAME>GTK_CLIST_SHOW_TITLES</NAME>
#define GTK_CLIST_SHOW_TITLES(clist)       (GTK_CLIST_FLAGS (clist) & GTK_CLIST_SHOW_TITLES)
</MACRO>
<MACRO>
<NAME>GTK_CLIST_CHILD_HAS_FOCUS</NAME>
#define GTK_CLIST_CHILD_HAS_FOCUS(clist)   (GTK_CLIST_FLAGS (clist) & GTK_CLIST_CHILD_HAS_FOCUS)
</MACRO>
<MACRO>
<NAME>GTK_CLIST_ADD_MODE</NAME>
#define GTK_CLIST_ADD_MODE(clist)          (GTK_CLIST_FLAGS (clist) & GTK_CLIST_ADD_MODE)
</MACRO>
<MACRO>
<NAME>GTK_CLIST_AUTO_SORT</NAME>
#define GTK_CLIST_AUTO_SORT(clist)         (GTK_CLIST_FLAGS (clist) & GTK_CLIST_AUTO_SORT)
</MACRO>
<MACRO>
<NAME>GTK_CLIST_AUTO_RESIZE_BLOCKED</NAME>
#define GTK_CLIST_AUTO_RESIZE_BLOCKED(clist) (GTK_CLIST_FLAGS (clist) & GTK_CLIST_AUTO_RESIZE_BLOCKED)
</MACRO>
<MACRO>
<NAME>GTK_CLIST_REORDERABLE</NAME>
#define GTK_CLIST_REORDERABLE(clist)       (GTK_CLIST_FLAGS (clist) & GTK_CLIST_REORDERABLE)
</MACRO>
<MACRO>
<NAME>GTK_CLIST_USE_DRAG_ICONS</NAME>
#define GTK_CLIST_USE_DRAG_ICONS(clist)    (GTK_CLIST_FLAGS (clist) & GTK_CLIST_USE_DRAG_ICONS)
</MACRO>
<MACRO>
<NAME>GTK_CLIST_DRAW_DRAG_LINE</NAME>
#define GTK_CLIST_DRAW_DRAG_LINE(clist)    (GTK_CLIST_FLAGS (clist) & GTK_CLIST_DRAW_DRAG_LINE)
</MACRO>
<MACRO>
<NAME>GTK_CLIST_DRAW_DRAG_RECT</NAME>
#define GTK_CLIST_DRAW_DRAG_RECT(clist)    (GTK_CLIST_FLAGS (clist) & GTK_CLIST_DRAW_DRAG_RECT)
</MACRO>
<MACRO>
<NAME>GTK_CLIST_ROW</NAME>
#define GTK_CLIST_ROW(_glist_) ((GtkCListRow *)((_glist_)->data))
</MACRO>
<MACRO>
<NAME>GTK_CELL_TEXT</NAME>
#define GTK_CELL_TEXT(cell)     (((GtkCellText *) &(cell)))
</MACRO>
<MACRO>
<NAME>GTK_CELL_PIXMAP</NAME>
#define GTK_CELL_PIXMAP(cell)   (((GtkCellPixmap *) &(cell)))
</MACRO>
<MACRO>
<NAME>GTK_CELL_PIXTEXT</NAME>
#define GTK_CELL_PIXTEXT(cell)  (((GtkCellPixText *) &(cell)))
</MACRO>
<MACRO>
<NAME>GTK_CELL_WIDGET</NAME>
#define GTK_CELL_WIDGET(cell)   (((GtkCellWidget *) &(cell)))
</MACRO>
<STRUCT>
<NAME>GtkCList</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkCListClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkCListColumn</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkCListRow</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkCell</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkCellText</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkCellPixmap</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkCellPixText</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkCellWidget</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>GtkCListCompareFunc</NAME>
<RETURNS>gint </RETURNS>
GtkCList     *clist,
				     gconstpointer ptr1,
				     gconstpointer ptr2
</USER_FUNCTION>
<STRUCT>
<NAME>GtkCListCellInfo</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkCListDestInfo</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkCListCellInfo</NAME>
struct GtkCListCellInfo
{
  gint row;
  gint column;
};
</STRUCT>
<STRUCT>
<NAME>GtkCListDestInfo</NAME>
struct GtkCListDestInfo
{
  GtkCListCellInfo cell;
  GtkCListDragPos  insert_pos;
};
</STRUCT>
<STRUCT>
<NAME>GtkCList</NAME>
struct GtkCList
{
  GtkContainer container;
  
  guint16 flags;
  
  /* mem chunks */
  GMemChunk *row_mem_chunk;
  GMemChunk *cell_mem_chunk;

  guint freeze_count;
  
  /* allocation rectangle after the conatiner_border_width
   * and the width of the shadow border */
  GdkRectangle internal_allocation;
  
  /* rows */
  gint rows;
  gint row_center_offset;
  gint row_height;
  GList *row_list;
  GList *row_list_end;
  
  /* columns */
  gint columns;
  GdkRectangle column_title_area;
  GdkWindow *title_window;
  
  /* dynamicly allocated array of column structures */
  GtkCListColumn *column;
  
  /*the scrolling window and it's height and width to
   * make things a little speedier */
  GdkWindow *clist_window;
  gint clist_window_width;
  gint clist_window_height;
  
  /* offsets for scrolling */
  gint hoffset;
  gint voffset;
  
  /* border shadow style */
  GtkShadowType shadow_type;
  
  /* the list's selection mode (gtkenums.h) */
  GtkSelectionMode selection_mode;
  
  /* list of selected rows */
  GList *selection;
  GList *selection_end;
  
  GList *undo_selection;
  GList *undo_unselection;
  gint undo_anchor;
  
  /* mouse buttons */
  guint8 button_actions[5];

  guint8 drag_button;

  /* dnd */
  GtkCListCellInfo click_cell;

  /* scroll adjustments */
  GtkAdjustment *hadjustment;
  GtkAdjustment *vadjustment;
  
  /* xor GC for the vertical drag line */
  GdkGC *xor_gc;
  
  /* gc for drawing unselected cells */
  GdkGC *fg_gc;
  GdkGC *bg_gc;
  
  /* cursor used to indicate dragging */
  GdkCursor *cursor_drag;
  
  /* the current x-pixel location of the xor-drag line */
  gint x_drag;
  
  /* focus handling */
  gint focus_row;
  
  /* dragging the selection */
  gint anchor;
  GtkStateType anchor_state;
  gint drag_pos;
  gint htimer;
  gint vtimer;
  
  GtkSortType sort_type;
  GtkCListCompareFunc compare;
  gint sort_column;
};
</STRUCT>
<STRUCT>
<NAME>GtkCListColumn</NAME>
struct GtkCListColumn
{
  gchar *title;
  GdkRectangle area;
  
  GtkWidget *button;
  GdkWindow *window;
  
  gint width;
  gint min_width;
  gint max_width;
  GtkJustification justification;
  
  guint visible        : 1;  
  guint width_set      : 1;
  guint resizeable     : 1;
  guint auto_resize    : 1;
  guint button_passive : 1;
};
</STRUCT>
<STRUCT>
<NAME>GtkCListRow</NAME>
struct GtkCListRow
{
  GtkCell *cell;
  GtkStateType state;
  
  GdkColor foreground;
  GdkColor background;
  
  GtkStyle *style;

  gpointer data;
  GtkDestroyNotify destroy;
  
  guint fg_set     : 1;
  guint bg_set     : 1;
  guint selectable : 1;
};
</STRUCT>
<STRUCT>
<NAME>GtkCellText</NAME>
struct GtkCellText
{
  GtkCellType type;
  
  gint16 vertical;
  gint16 horizontal;
  
  GtkStyle *style;

  gchar *text;
};
</STRUCT>
<STRUCT>
<NAME>GtkCellPixmap</NAME>
struct GtkCellPixmap
{
  GtkCellType type;
  
  gint16 vertical;
  gint16 horizontal;
  
  GtkStyle *style;

  GdkPixmap *pixmap;
  GdkBitmap *mask;
};
</STRUCT>
<STRUCT>
<NAME>GtkCellPixText</NAME>
struct GtkCellPixText
{
  GtkCellType type;
  
  gint16 vertical;
  gint16 horizontal;
  
  GtkStyle *style;

  gchar *text;
  guint8 spacing;
  GdkPixmap *pixmap;
  GdkBitmap *mask;
};
</STRUCT>
<STRUCT>
<NAME>GtkCellWidget</NAME>
struct GtkCellWidget
{
  GtkCellType type;
  
  gint16 vertical;
  gint16 horizontal;
  
  GtkStyle *style;

  GtkWidget *widget;
};
</STRUCT>
<STRUCT>
<NAME>GtkCell</NAME>
struct GtkCell
{
  GtkCellType type;
  
  gint16 vertical;
  gint16 horizontal;
  
  GtkStyle *style;

  union {
    gchar *text;
    
    struct {
      GdkPixmap *pixmap;
      GdkBitmap *mask;
    } pm;
    
    struct {
      gchar *text;
      guint8 spacing;
      GdkPixmap *pixmap;
      GdkBitmap *mask;
    } pt;
    
    GtkWidget *widget;
  } u;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_clist_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_construct</NAME>
<RETURNS>void  </RETURNS>
GtkCList *clist,gint      columns,gchar    *titles[]
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
gint   columns
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_new_with_titles</NAME>
<RETURNS>GtkWidget *</RETURNS>
gint   columns,gchar *titles[]
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_set_hadjustment</NAME>
<RETURNS>void  </RETURNS>
GtkCList      *clist,GtkAdjustment *adjustment
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_set_vadjustment</NAME>
<RETURNS>void  </RETURNS>
GtkCList      *clist,GtkAdjustment *adjustment
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_get_hadjustment</NAME>
<RETURNS>GtkAdjustment *</RETURNS>
GtkCList *clist
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_get_vadjustment</NAME>
<RETURNS>GtkAdjustment *</RETURNS>
GtkCList *clist
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_set_shadow_type</NAME>
<RETURNS>void  </RETURNS>
GtkCList      *clist,GtkShadowType  type
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_set_selection_mode</NAME>
<RETURNS>void  </RETURNS>
GtkCList         *clist,GtkSelectionMode  mode
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_set_reorderable</NAME>
<RETURNS>void  </RETURNS>
GtkCList *clist,gboolean  reorderable
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_set_use_drag_icons</NAME>
<RETURNS>void  </RETURNS>
GtkCList *clist,gboolean  use_icons
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_set_button_actions</NAME>
<RETURNS>void  </RETURNS>
GtkCList *clist,guint     button,guint8    button_actions
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_freeze</NAME>
<RETURNS>void  </RETURNS>
GtkCList *clist
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_thaw</NAME>
<RETURNS>void  </RETURNS>
GtkCList *clist
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_column_titles_show</NAME>
<RETURNS>void  </RETURNS>
GtkCList *clist
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_column_titles_hide</NAME>
<RETURNS>void  </RETURNS>
GtkCList *clist
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_column_title_active</NAME>
<RETURNS>void  </RETURNS>
GtkCList *clist,gint      column
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_column_title_passive</NAME>
<RETURNS>void  </RETURNS>
GtkCList *clist,gint      column
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_column_titles_active</NAME>
<RETURNS>void  </RETURNS>
GtkCList *clist
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_column_titles_passive</NAME>
<RETURNS>void  </RETURNS>
GtkCList *clist
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_set_column_title</NAME>
<RETURNS>void  </RETURNS>
GtkCList    *clist,gint         column,const gchar *title
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_get_column_title</NAME>
<RETURNS>gchar  *</RETURNS>
GtkCList *clist,gint      column
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_set_column_widget</NAME>
<RETURNS>void  </RETURNS>
GtkCList  *clist,gint       column,GtkWidget *widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_get_column_widget</NAME>
<RETURNS>GtkWidget  *</RETURNS>
GtkCList *clist,gint      column
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_set_column_justification</NAME>
<RETURNS>void  </RETURNS>
GtkCList         *clist,gint              column,GtkJustification  justification
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_set_column_visibility</NAME>
<RETURNS>void  </RETURNS>
GtkCList *clist,gint      column,gboolean  visible
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_set_column_resizeable</NAME>
<RETURNS>void  </RETURNS>
GtkCList *clist,gint      column,gboolean  resizeable
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_set_column_auto_resize</NAME>
<RETURNS>void  </RETURNS>
GtkCList *clist,gint      column,gboolean  auto_resize
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_columns_autosize</NAME>
<RETURNS>gint  </RETURNS>
GtkCList *clist
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_optimal_column_width</NAME>
<RETURNS>gint  </RETURNS>
GtkCList *clist,gint      column
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_set_column_width</NAME>
<RETURNS>void  </RETURNS>
GtkCList *clist,gint      column,gint      width
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_set_column_min_width</NAME>
<RETURNS>void  </RETURNS>
GtkCList *clist,gint      column,gint      min_width
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_set_column_max_width</NAME>
<RETURNS>void  </RETURNS>
GtkCList *clist,gint      column,gint      max_width
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_set_row_height</NAME>
<RETURNS>void  </RETURNS>
GtkCList *clist,guint     height
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_moveto</NAME>
<RETURNS>void  </RETURNS>
GtkCList *clist,gint      row,gint      column,gfloat    row_align,gfloat    col_align
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_row_is_visible</NAME>
<RETURNS>GtkVisibility  </RETURNS>
GtkCList *clist,gint      row
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_get_cell_type</NAME>
<RETURNS>GtkCellType  </RETURNS>
GtkCList *clist,gint      row,gint      column
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_set_text</NAME>
<RETURNS>void  </RETURNS>
GtkCList    *clist,gint         row,gint         column,const gchar *text
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_get_text</NAME>
<RETURNS>gint  </RETURNS>
GtkCList  *clist,gint       row,gint       column,gchar    **text
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_set_pixmap</NAME>
<RETURNS>void  </RETURNS>
GtkCList  *clist,gint       row,gint       column,GdkPixmap *pixmap,GdkBitmap *mask
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_get_pixmap</NAME>
<RETURNS>gint  </RETURNS>
GtkCList   *clist,gint        row,gint        column,GdkPixmap **pixmap,GdkBitmap **mask
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_set_pixtext</NAME>
<RETURNS>void  </RETURNS>
GtkCList    *clist,gint         row,gint         column,const gchar *text,guint8       spacing,GdkPixmap   *pixmap,GdkBitmap   *mask
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_get_pixtext</NAME>
<RETURNS>gint  </RETURNS>
GtkCList   *clist,gint        row,gint        column,gchar     **text,guint8     *spacing,GdkPixmap **pixmap,GdkBitmap **mask
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_set_foreground</NAME>
<RETURNS>void  </RETURNS>
GtkCList *clist,gint      row,GdkColor *color
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_set_background</NAME>
<RETURNS>void  </RETURNS>
GtkCList *clist,gint      row,GdkColor *color
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_set_cell_style</NAME>
<RETURNS>void  </RETURNS>
GtkCList *clist,gint      row,gint      column,GtkStyle *style
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_get_cell_style</NAME>
<RETURNS>GtkStyle  *</RETURNS>
GtkCList *clist,gint      row,gint      column
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_set_row_style</NAME>
<RETURNS>void  </RETURNS>
GtkCList *clist,gint      row,GtkStyle *style
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_get_row_style</NAME>
<RETURNS>GtkStyle  *</RETURNS>
GtkCList *clist,gint      row
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_set_shift</NAME>
<RETURNS>void  </RETURNS>
GtkCList *clist,gint      row,gint      column,gint      vertical,gint      horizontal
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_set_selectable</NAME>
<RETURNS>void  </RETURNS>
GtkCList *clist,gint      row,gboolean  selectable
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_get_selectable</NAME>
<RETURNS>gboolean  </RETURNS>
GtkCList *clist,gint      row
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_prepend</NAME>
<RETURNS>gint  </RETURNS>
GtkCList    *clist,gchar       *text[]
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_append</NAME>
<RETURNS>gint  </RETURNS>
GtkCList    *clist,gchar       *text[]
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_insert</NAME>
<RETURNS>gint  </RETURNS>
GtkCList    *clist,gint         row,gchar       *text[]
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_remove</NAME>
<RETURNS>void  </RETURNS>
GtkCList *clist,gint      row
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_set_row_data</NAME>
<RETURNS>void  </RETURNS>
GtkCList *clist,gint      row,gpointer  data
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_set_row_data_full</NAME>
<RETURNS>void  </RETURNS>
GtkCList         *clist,gint              row,gpointer          data,GtkDestroyNotify  destroy
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_get_row_data</NAME>
<RETURNS>gpointer  </RETURNS>
GtkCList *clist,gint      row
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_find_row_from_data</NAME>
<RETURNS>gint  </RETURNS>
GtkCList *clist,gpointer  data
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_select_row</NAME>
<RETURNS>void  </RETURNS>
GtkCList *clist,gint      row,gint      column
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_unselect_row</NAME>
<RETURNS>void  </RETURNS>
GtkCList *clist,gint      row,gint      column
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_undo_selection</NAME>
<RETURNS>void  </RETURNS>
GtkCList *clist
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_clear</NAME>
<RETURNS>void  </RETURNS>
GtkCList *clist
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_get_selection_info</NAME>
<RETURNS>gint  </RETURNS>
GtkCList *clist,gint      x,gint      y,gint     *row,gint     *column
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_select_all</NAME>
<RETURNS>void  </RETURNS>
GtkCList *clist
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_unselect_all</NAME>
<RETURNS>void  </RETURNS>
GtkCList *clist
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_swap_rows</NAME>
<RETURNS>void  </RETURNS>
GtkCList *clist,gint      row1,gint      row2
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_row_move</NAME>
<RETURNS>void  </RETURNS>
GtkCList *clist,gint      source_row,gint      dest_row
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_set_compare_func</NAME>
<RETURNS>void  </RETURNS>
GtkCList            *clist,GtkCListCompareFunc  cmp_func
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_set_sort_column</NAME>
<RETURNS>void  </RETURNS>
GtkCList *clist,gint      column
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_set_sort_type</NAME>
<RETURNS>void  </RETURNS>
GtkCList    *clist,GtkSortType  sort_type
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_sort</NAME>
<RETURNS>void  </RETURNS>
GtkCList *clist
</FUNCTION>
<FUNCTION>
<NAME>gtk_clist_set_auto_sort</NAME>
<RETURNS>void  </RETURNS>
GtkCList *clist,gboolean  auto_sort
</FUNCTION>
<MACRO>
<NAME>GTK_COLOR_SELECTION</NAME>
#define GTK_COLOR_SELECTION(obj)          GTK_CHECK_CAST (obj, gtk_color_selection_get_type (), GtkColorSelection)
</MACRO>
<MACRO>
<NAME>GTK_COLOR_SELECTION_CLASS</NAME>
#define GTK_COLOR_SELECTION_CLASS(klass)  GTK_CHECK_CLASS_CAST (klass, gtk_color_selection_get_type (), GtkColorSelectionClass)
</MACRO>
<MACRO>
<NAME>GTK_IS_COLOR_SELECTION</NAME>
#define GTK_IS_COLOR_SELECTION(obj)       GTK_CHECK_TYPE (obj, gtk_color_selection_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_COLOR_SELECTION_DIALOG</NAME>
#define GTK_COLOR_SELECTION_DIALOG(obj)          GTK_CHECK_CAST (obj, gtk_color_selection_dialog_get_type (), GtkColorSelectionDialog)
</MACRO>
<MACRO>
<NAME>GTK_COLOR_SELECTION_DIALOG_CLASS</NAME>
#define GTK_COLOR_SELECTION_DIALOG_CLASS(klass)  GTK_CHECK_CLASS_CAST (klass, gtk_color_selection_dialog_get_type (), GtkColorSelectionDialogClass)
</MACRO>
<MACRO>
<NAME>GTK_IS_COLOR_SELECTION_DIALOG</NAME>
#define GTK_IS_COLOR_SELECTION_DIALOG(obj)       GTK_CHECK_TYPE (obj, gtk_color_selection_dialog_get_type ())
</MACRO>
<STRUCT>
<NAME>GtkColorSelection</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkColorSelectionClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkColorSelectionDialog</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkColorSelectionDialogClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkColorSelection</NAME>
struct GtkColorSelection
{
  GtkVBox vbox;

  GtkWidget *wheel_area;
  GtkWidget *value_area;
  GtkWidget *sample_area;
  GtkWidget *sample_area_eb;

  GtkWidget *scales[8];
  GtkWidget *entries[8];
  GtkWidget *opacity_label;

  GdkGC *wheel_gc;
  GdkGC *value_gc;
  GdkGC *sample_gc;

  GtkUpdateType policy;
  gint use_opacity;
  gint timer_active;
  gint timer_tag;
  gdouble values[8];
  gdouble old_values[8];

  guchar *wheel_buf;
  guchar *value_buf;
  guchar *sample_buf;
};
</STRUCT>
<STRUCT>
<NAME>GtkColorSelectionDialog</NAME>
struct GtkColorSelectionDialog
{
  GtkWindow window;

  GtkWidget *colorsel;
  GtkWidget *main_vbox;
  GtkWidget *ok_button;
  GtkWidget *reset_button;
  GtkWidget *cancel_button;
  GtkWidget *help_button;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_color_selection_get_type</NAME>
<RETURNS>guint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_color_selection_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_color_selection_set_update_policy</NAME>
<RETURNS>void  </RETURNS>
GtkColorSelection     *colorsel,GtkUpdateType          policy
</FUNCTION>
<FUNCTION>
<NAME>gtk_color_selection_set_opacity</NAME>
<RETURNS>void  </RETURNS>
GtkColorSelection     *colorsel,gint                   use_opacity
</FUNCTION>
<FUNCTION>
<NAME>gtk_color_selection_set_color</NAME>
<RETURNS>void  </RETURNS>
GtkColorSelection     *colorsel,gdouble               *color
</FUNCTION>
<FUNCTION>
<NAME>gtk_color_selection_get_color</NAME>
<RETURNS>void  </RETURNS>
GtkColorSelection     *colorsel,gdouble               *color
</FUNCTION>
<FUNCTION>
<NAME>gtk_color_selection_dialog_get_type</NAME>
<RETURNS>guint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_color_selection_dialog_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
const gchar *title
</FUNCTION>
<MACRO>
<NAME>GTK_COMBO</NAME>
#define GTK_COMBO(obj)			GTK_CHECK_CAST (obj, gtk_combo_get_type (), GtkCombo)
</MACRO>
<MACRO>
<NAME>GTK_COMBO_CLASS</NAME>
#define GTK_COMBO_CLASS(klass)	GTK_CHECK_CLASS_CAST (klass, gtk_combo_get_type (), GtkComboClass)
</MACRO>
<MACRO>
<NAME>GTK_IS_COMBO</NAME>
#define GTK_IS_COMBO(obj)       GTK_CHECK_TYPE (obj, gtk_combo_get_type ())
</MACRO>
<STRUCT>
<NAME>GtkCombo</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkComboClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkCombo</NAME>
struct GtkCombo {
	GtkHBox hbox;
	GtkWidget *entry;
	GtkWidget *button;
	GtkWidget *popup;
	GtkWidget *popwin;
	GtkWidget *list;

	guint entry_change_id;
	guint list_change_id;

	guint value_in_list:1;
	guint ok_if_empty:1;
	guint case_sensitive:1;
	guint use_arrows:1;
	guint use_arrows_always:1;

        guint16 current_button;
	guint activate_id;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_combo_get_type</NAME>
<RETURNS>guint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_combo_new</NAME>
<RETURNS>GtkWidget  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_combo_set_value_in_list</NAME>
<RETURNS>void  </RETURNS>
GtkCombo*    combo,gint         val,gint         ok_if_empty
</FUNCTION>
<FUNCTION>
<NAME>gtk_combo_set_use_arrows</NAME>
<RETURNS>void  </RETURNS>
GtkCombo*    combo,gint         val
</FUNCTION>
<FUNCTION>
<NAME>gtk_combo_set_use_arrows_always</NAME>
<RETURNS>void  </RETURNS>
GtkCombo*    combo,gint         val
</FUNCTION>
<FUNCTION>
<NAME>gtk_combo_set_case_sensitive</NAME>
<RETURNS>void  </RETURNS>
GtkCombo*    combo,gint         val
</FUNCTION>
<FUNCTION>
<NAME>gtk_combo_set_item_string</NAME>
<RETURNS>void  </RETURNS>
GtkCombo*    combo,GtkItem*     item,const gchar* item_value
</FUNCTION>
<FUNCTION>
<NAME>gtk_combo_set_popdown_strings</NAME>
<RETURNS>void  </RETURNS>
GtkCombo*    combo,GList        *strings
</FUNCTION>
<FUNCTION>
<NAME>gtk_combo_disable_activate</NAME>
<RETURNS>void  </RETURNS>
GtkCombo*    combo
</FUNCTION>
<MACRO>
<NAME>gtk_accel_label_accelerator_width</NAME>
#define	gtk_accel_label_accelerator_width	gtk_accel_label_get_accel_width
</MACRO>
<MACRO>
<NAME>gtk_container_border_width</NAME>
#define	gtk_container_border_width		gtk_container_set_border_width
</MACRO>
<MACRO>
<NAME>gtk_notebook_current_page</NAME>
#define	gtk_notebook_current_page               gtk_notebook_get_current_page
</MACRO>
<MACRO>
<NAME>gtk_packer_configure</NAME>
#define	gtk_packer_configure                    gtk_packer_set_child_packing
</MACRO>
<MACRO>
<NAME>gtk_paned_gutter_size</NAME>
#define	gtk_paned_gutter_size			gtk_paned_set_gutter_size
</MACRO>
<MACRO>
<NAME>gtk_paned_handle_size</NAME>
#define	gtk_paned_handle_size			gtk_paned_set_handle_size
</MACRO>
<MACRO>
<NAME>gtk_scale_value_width</NAME>
#define	gtk_scale_value_width                   gtk_scale_get_value_width
</MACRO>
<MACRO>
<NAME>gtk_window_position</NAME>
#define	gtk_window_position			gtk_window_set_position
</MACRO>
<MACRO>
<NAME>gtk_toggle_button_set_state</NAME>
#define	gtk_toggle_button_set_state		gtk_toggle_button_set_active
</MACRO>
<MACRO>
<NAME>gtk_check_menu_item_set_state</NAME>
#define	gtk_check_menu_item_set_state		gtk_check_menu_item_set_active
</MACRO>
<MACRO>
<NAME>gtk_ctree_set_reorderable</NAME>
#define	gtk_ctree_set_reorderable(t,r)		gtk_clist_set_reorderable((GtkCList*) (t),(r))
</MACRO>
<MACRO>
<NAME>gtk_style_apply_default_pixmap</NAME>
#define	gtk_style_apply_default_pixmap(s,gw,st,a,x,y,w,h) \
    gtk_style_apply_default_background (s,gw,TRUE,st,a,x,y,w,h)
</MACRO>
<MACRO>
<NAME>GTK_TYPE_CONTAINER</NAME>
#define GTK_TYPE_CONTAINER	        (gtk_container_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_CONTAINER</NAME>
#define GTK_CONTAINER(obj)	        (GTK_CHECK_CAST ((obj), GTK_TYPE_CONTAINER, GtkContainer))
</MACRO>
<MACRO>
<NAME>GTK_CONTAINER_CLASS</NAME>
#define GTK_CONTAINER_CLASS(klass)      (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_CONTAINER, GtkContainerClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_CONTAINER</NAME>
#define GTK_IS_CONTAINER(obj)	        (GTK_CHECK_TYPE ((obj), GTK_TYPE_CONTAINER))
</MACRO>
<MACRO>
<NAME>GTK_IS_CONTAINER_CLASS</NAME>
#define GTK_IS_CONTAINER_CLASS(klass)   (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_CONTAINER))
</MACRO>
<MACRO>
<NAME>GTK_IS_RESIZE_CONTAINER</NAME>
#define GTK_IS_RESIZE_CONTAINER(widget) (GTK_IS_CONTAINER (widget) && ((GtkContainer*) (widget))->resize_mode != GTK_RESIZE_PARENT)
</MACRO>
<STRUCT>
<NAME>GtkContainer</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkContainerClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkContainer</NAME>
struct GtkContainer
{
  GtkWidget widget;
  
  GtkWidget *focus_child;
  
  guint border_width : 16;
  guint need_resize : 1;
  guint resize_mode : 2;
  
  
  /* The list of children that requested a resize
   */
  GSList *resize_widgets;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_container_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_container_set_border_width</NAME>
<RETURNS>void  </RETURNS>
GtkContainer	   *container,guint		    border_width
</FUNCTION>
<FUNCTION>
<NAME>gtk_container_add</NAME>
<RETURNS>void  </RETURNS>
GtkContainer	   *container,GtkWidget	   *widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_container_remove</NAME>
<RETURNS>void  </RETURNS>
GtkContainer	   *container,GtkWidget	   *widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_container_set_resize_mode</NAME>
<RETURNS>void  </RETURNS>
GtkContainer     *container,GtkResizeMode     resize_mode
</FUNCTION>
<FUNCTION>
<NAME>gtk_container_check_resize</NAME>
<RETURNS>void  </RETURNS>
GtkContainer     *container
</FUNCTION>
<FUNCTION>
<NAME>gtk_container_foreach</NAME>
<RETURNS>void  </RETURNS>
GtkContainer	   *container,GtkCallback	    callback,gpointer	    callback_data
</FUNCTION>
<FUNCTION>
<NAME>gtk_container_foreach_full</NAME>
<RETURNS>void  </RETURNS>
GtkContainer	   *container,GtkCallback	    callback,GtkCallbackMarshal marshal,gpointer	    callback_data,GtkDestroyNotify  notify
</FUNCTION>
<FUNCTION>
<NAME>gtk_container_children</NAME>
<RETURNS>GList *</RETURNS>
GtkContainer	   *container
</FUNCTION>
<FUNCTION>
<NAME>gtk_container_focus</NAME>
<RETURNS>gint  </RETURNS>
GtkContainer     *container,GtkDirectionType  direction
</FUNCTION>
<FUNCTION>
<NAME>gtk_container_set_focus_child</NAME>
<RETURNS>void  </RETURNS>
GtkContainer     *container,GtkWidget	     *child
</FUNCTION>
<FUNCTION>
<NAME>gtk_container_set_focus_vadjustment</NAME>
<RETURNS>void  </RETURNS>
GtkContainer     *container,GtkAdjustment    *adjustment
</FUNCTION>
<FUNCTION>
<NAME>gtk_container_set_focus_hadjustment</NAME>
<RETURNS>void  </RETURNS>
GtkContainer     *container,GtkAdjustment    *adjustment
</FUNCTION>
<FUNCTION>
<NAME>gtk_container_register_toplevel</NAME>
<RETURNS>void  </RETURNS>
GtkContainer     *container
</FUNCTION>
<FUNCTION>
<NAME>gtk_container_unregister_toplevel</NAME>
<RETURNS>void  </RETURNS>
GtkContainer     *container
</FUNCTION>
<FUNCTION>
<NAME>gtk_container_get_toplevels</NAME>
<RETURNS>GList  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_container_resize_children</NAME>
<RETURNS>void  </RETURNS>
GtkContainer     *container
</FUNCTION>
<FUNCTION>
<NAME>gtk_container_child_type</NAME>
<RETURNS>GtkType  </RETURNS>
GtkContainer     *container
</FUNCTION>
<FUNCTION>
<NAME>gtk_container_add_child_arg_type</NAME>
<RETURNS>void  </RETURNS>
const gchar      *arg_name,GtkType           arg_type,guint             arg_flags,guint             arg_id
</FUNCTION>
<FUNCTION>
<NAME>gtk_container_query_child_args</NAME>
<RETURNS>GtkArg *</RETURNS>
GtkType	       class_type,guint32          **arg_flags,guint             *nargs
</FUNCTION>
<FUNCTION>
<NAME>gtk_container_child_getv</NAME>
<RETURNS>void  </RETURNS>
GtkContainer      *container,GtkWidget	      *child,guint	       n_args,GtkArg	      *args
</FUNCTION>
<FUNCTION>
<NAME>gtk_container_child_setv</NAME>
<RETURNS>void  </RETURNS>
GtkContainer      *container,GtkWidget	      *child,guint	       n_args,GtkArg	      *args
</FUNCTION>
<FUNCTION>
<NAME>gtk_container_add_with_args</NAME>
<RETURNS>void  </RETURNS>
GtkContainer      *container,GtkWidget	      *widget,const gchar	      *first_arg_name,...
</FUNCTION>
<FUNCTION>
<NAME>gtk_container_addv</NAME>
<RETURNS>void  </RETURNS>
GtkContainer      *container,GtkWidget	      *widget,guint	       n_args,GtkArg	      *args
</FUNCTION>
<FUNCTION>
<NAME>gtk_container_child_set</NAME>
<RETURNS>void 	</RETURNS>
GtkContainer      *container,GtkWidget         *child,const gchar	      *first_arg_name,...
</FUNCTION>
<FUNCTION>
<NAME>gtk_container_queue_resize</NAME>
<RETURNS>void 	</RETURNS>
GtkContainer *container
</FUNCTION>
<FUNCTION>
<NAME>gtk_container_clear_resize_widgets</NAME>
<RETURNS>void  </RETURNS>
GtkContainer *container
</FUNCTION>
<FUNCTION>
<NAME>gtk_container_arg_set</NAME>
<RETURNS>void  </RETURNS>
GtkContainer *container,GtkWidget	 *child,GtkArg       *arg,GtkArgInfo   *info
</FUNCTION>
<FUNCTION>
<NAME>gtk_container_arg_get</NAME>
<RETURNS>void  </RETURNS>
GtkContainer *container,GtkWidget	 *child,GtkArg       *arg,GtkArgInfo   *info
</FUNCTION>
<FUNCTION>
<NAME>gtk_container_child_args_collect</NAME>
<RETURNS>gchar *</RETURNS>
GtkType       object_type,GSList      **arg_list_p,GSList      **info_list_p,const gchar	 *first_arg_name,va_list       args
</FUNCTION>
<FUNCTION>
<NAME>gtk_container_child_arg_get_info</NAME>
<RETURNS>gchar *</RETURNS>
GtkType       object_type,const gchar  *arg_name,GtkArgInfo  **info_p
</FUNCTION>
<FUNCTION>
<NAME>gtk_container_forall</NAME>
<RETURNS>void  </RETURNS>
GtkContainer *container,GtkCallback	  callback,gpointer	  callback_data
</FUNCTION>
<FUNCTION>
<NAME>gtk_container_child_composite_name</NAME>
<RETURNS>gchar *</RETURNS>
GtkContainer *container,GtkWidget	 *child
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_CTREE</NAME>
#define GTK_TYPE_CTREE            (gtk_ctree_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_CTREE</NAME>
#define GTK_CTREE(obj)            (GTK_CHECK_CAST ((obj), GTK_TYPE_CTREE, GtkCTree))
</MACRO>
<MACRO>
<NAME>GTK_CTREE_CLASS</NAME>
#define GTK_CTREE_CLASS(klass)    (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_CTREE, GtkCTreeClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_CTREE</NAME>
#define GTK_IS_CTREE(obj)         (GTK_CHECK_TYPE ((obj), GTK_TYPE_CTREE))
</MACRO>
<MACRO>
<NAME>GTK_IS_CTREE_CLASS</NAME>
#define GTK_IS_CTREE_CLASS(klass) (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_CTREE))
</MACRO>
<MACRO>
<NAME>GTK_CTREE_ROW</NAME>
#define GTK_CTREE_ROW(_node_) ((GtkCTreeRow *)(((GList *)(_node_))->data))
</MACRO>
<MACRO>
<NAME>GTK_CTREE_NODE</NAME>
#define GTK_CTREE_NODE(_node_) ((GtkCTreeNode *)((_node_)))
</MACRO>
<MACRO>
<NAME>GTK_CTREE_NODE_NEXT</NAME>
#define GTK_CTREE_NODE_NEXT(_nnode_) ((GtkCTreeNode *)(((GList *)(_nnode_))->next))
</MACRO>
<MACRO>
<NAME>GTK_CTREE_NODE_PREV</NAME>
#define GTK_CTREE_NODE_PREV(_pnode_) ((GtkCTreeNode *)(((GList *)(_pnode_))->prev))
</MACRO>
<MACRO>
<NAME>GTK_CTREE_FUNC</NAME>
#define GTK_CTREE_FUNC(_func_) ((GtkCTreeFunc)(_func_))
</MACRO>
<ENUM>
<NAME>GtkCTreePos</NAME>
typedef enum
{
  GTK_CTREE_POS_BEFORE,
  GTK_CTREE_POS_AS_CHILD,
  GTK_CTREE_POS_AFTER
} GtkCTreePos;
</ENUM>
<ENUM>
<NAME>GtkCTreeLineStyle</NAME>
typedef enum
{
  GTK_CTREE_LINES_NONE,
  GTK_CTREE_LINES_SOLID,
  GTK_CTREE_LINES_DOTTED,
  GTK_CTREE_LINES_TABBED
} GtkCTreeLineStyle;
</ENUM>
<ENUM>
<NAME>GtkCTreeExpanderStyle</NAME>
typedef enum
{
  GTK_CTREE_EXPANDER_NONE,
  GTK_CTREE_EXPANDER_SQUARE,
  GTK_CTREE_EXPANDER_TRIANGLE,
  GTK_CTREE_EXPANDER_CIRCULAR
} GtkCTreeExpanderStyle;
</ENUM>
<ENUM>
<NAME>GtkCTreeExpansionType</NAME>
typedef enum
{
  GTK_CTREE_EXPANSION_EXPAND,
  GTK_CTREE_EXPANSION_EXPAND_RECURSIVE,
  GTK_CTREE_EXPANSION_COLLAPSE,
  GTK_CTREE_EXPANSION_COLLAPSE_RECURSIVE,
  GTK_CTREE_EXPANSION_TOGGLE,
  GTK_CTREE_EXPANSION_TOGGLE_RECURSIVE
} GtkCTreeExpansionType;
</ENUM>
<STRUCT>
<NAME>GtkCTree</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkCTreeClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkCTreeRow</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkCTreeNode</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>GtkCTreeFunc</NAME>
<RETURNS>void </RETURNS>
GtkCTree     *ctree,
			      GtkCTreeNode *node,
			      gpointer      data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GtkCTreeGNodeFunc</NAME>
<RETURNS>gboolean </RETURNS>
GtkCTree     *ctree,
                                       guint         depth,
                                       GNode        *gnode,
				       GtkCTreeNode *cnode,
                                       gpointer      data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GtkCTreeCompareDragFunc</NAME>
<RETURNS>gboolean </RETURNS>
GtkCTree     *ctree,
                                             GtkCTreeNode *source_node,
                                             GtkCTreeNode *new_parent,
                                             GtkCTreeNode *new_sibling
</USER_FUNCTION>
<STRUCT>
<NAME>GtkCTree</NAME>
struct GtkCTree
{
  GtkCList clist;
  
  GdkGC *lines_gc;
  
  gint tree_indent;
  gint tree_spacing;
  gint tree_column;

  guint line_style     : 2;
  guint expander_style : 2;
  guint show_stub      : 1;

  GtkCTreeCompareDragFunc drag_compare;
};
</STRUCT>
<STRUCT>
<NAME>GtkCTreeRow</NAME>
struct GtkCTreeRow
{
  GtkCListRow row;
  
  GtkCTreeNode *parent;
  GtkCTreeNode *sibling;
  GtkCTreeNode *children;
  
  GdkPixmap *pixmap_closed;
  GdkBitmap *mask_closed;
  GdkPixmap *pixmap_opened;
  GdkBitmap *mask_opened;
  
  guint16 level;
  
  guint is_leaf  : 1;
  guint expanded : 1;
};
</STRUCT>
<STRUCT>
<NAME>GtkCTreeNode</NAME>
struct GtkCTreeNode {
  GList list;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_ctree_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_construct</NAME>
<RETURNS>void  </RETURNS>
GtkCTree     *ctree,gint          columns,gint          tree_column,gchar        *titles[]
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_new_with_titles</NAME>
<RETURNS>GtkWidget  *</RETURNS>
gint          columns,gint          tree_column,gchar        *titles[]
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_new</NAME>
<RETURNS>GtkWidget  *</RETURNS>
gint          columns,gint          tree_column
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_insert_node</NAME>
<RETURNS>GtkCTreeNode  *</RETURNS>
GtkCTree     *ctree,GtkCTreeNode *parent,GtkCTreeNode *sibling,gchar        *text[],guint8        spacing,GdkPixmap    *pixmap_closed,GdkBitmap    *mask_closed,GdkPixmap    *pixmap_opened,GdkBitmap    *mask_opened,gboolean      is_leaf,gboolean      expanded
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_remove_node</NAME>
<RETURNS>void  </RETURNS>
GtkCTree     *ctree,GtkCTreeNode *node
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_insert_gnode</NAME>
<RETURNS>GtkCTreeNode  *</RETURNS>
GtkCTree          *ctree,GtkCTreeNode      *parent,GtkCTreeNode      *sibling,GNode             *gnode,GtkCTreeGNodeFunc  func,gpointer           data
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_export_to_gnode</NAME>
<RETURNS>GNode  *</RETURNS>
GtkCTree          *ctree,GNode             *parent,GNode             *sibling,GtkCTreeNode      *node,GtkCTreeGNodeFunc  func,gpointer           data
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_post_recursive</NAME>
<RETURNS>void  </RETURNS>
GtkCTree     *ctree,GtkCTreeNode *node,GtkCTreeFunc  func,gpointer      data
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_post_recursive_to_depth</NAME>
<RETURNS>void  </RETURNS>
GtkCTree     *ctree,GtkCTreeNode *node,gint          depth,GtkCTreeFunc  func,gpointer      data
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_pre_recursive</NAME>
<RETURNS>void  </RETURNS>
GtkCTree     *ctree,GtkCTreeNode *node,GtkCTreeFunc  func,gpointer      data
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_pre_recursive_to_depth</NAME>
<RETURNS>void  </RETURNS>
GtkCTree     *ctree,GtkCTreeNode *node,gint          depth,GtkCTreeFunc  func,gpointer      data
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_is_viewable</NAME>
<RETURNS>gboolean  </RETURNS>
GtkCTree     *ctree,GtkCTreeNode *node
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_last</NAME>
<RETURNS>GtkCTreeNode  *</RETURNS>
GtkCTree     *ctree,GtkCTreeNode *node
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_find_node_ptr</NAME>
<RETURNS>GtkCTreeNode  *</RETURNS>
GtkCTree     *ctree,GtkCTreeRow  *ctree_row
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_node_nth</NAME>
<RETURNS>GtkCTreeNode  *</RETURNS>
GtkCTree     *ctree,guint         row
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_find</NAME>
<RETURNS>gboolean  </RETURNS>
GtkCTree     *ctree,GtkCTreeNode *node,GtkCTreeNode *child
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_is_ancestor</NAME>
<RETURNS>gboolean  </RETURNS>
GtkCTree     *ctree,GtkCTreeNode *node,GtkCTreeNode *child
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_find_by_row_data</NAME>
<RETURNS>GtkCTreeNode  *</RETURNS>
GtkCTree     *ctree,GtkCTreeNode *node,gpointer      data
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_find_all_by_row_data</NAME>
<RETURNS>GList  *</RETURNS>
GtkCTree     *ctree,GtkCTreeNode *node,gpointer      data
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_find_by_row_data_custom</NAME>
<RETURNS>GtkCTreeNode  *</RETURNS>
GtkCTree     *ctree,GtkCTreeNode *node,gpointer      data,GCompareFunc  func
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_find_all_by_row_data_custom</NAME>
<RETURNS>GList  *</RETURNS>
GtkCTree     *ctree,GtkCTreeNode *node,gpointer      data,GCompareFunc  func
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_is_hot_spot</NAME>
<RETURNS>gboolean  </RETURNS>
GtkCTree     *ctree,gint          x,gint          y
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_move</NAME>
<RETURNS>void  </RETURNS>
GtkCTree     *ctree,GtkCTreeNode *node,GtkCTreeNode *new_parent,GtkCTreeNode *new_sibling
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_expand</NAME>
<RETURNS>void  </RETURNS>
GtkCTree     *ctree,GtkCTreeNode *node
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_expand_recursive</NAME>
<RETURNS>void  </RETURNS>
GtkCTree     *ctree,GtkCTreeNode *node
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_expand_to_depth</NAME>
<RETURNS>void  </RETURNS>
GtkCTree     *ctree,GtkCTreeNode *node,gint          depth
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_collapse</NAME>
<RETURNS>void  </RETURNS>
GtkCTree     *ctree,GtkCTreeNode *node
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_collapse_recursive</NAME>
<RETURNS>void  </RETURNS>
GtkCTree     *ctree,GtkCTreeNode *node
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_collapse_to_depth</NAME>
<RETURNS>void  </RETURNS>
GtkCTree     *ctree,GtkCTreeNode *node,gint          depth
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_toggle_expansion</NAME>
<RETURNS>void  </RETURNS>
GtkCTree     *ctree,GtkCTreeNode *node
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_toggle_expansion_recursive</NAME>
<RETURNS>void  </RETURNS>
GtkCTree     *ctree,GtkCTreeNode *node
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_select</NAME>
<RETURNS>void  </RETURNS>
GtkCTree     *ctree,GtkCTreeNode *node
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_select_recursive</NAME>
<RETURNS>void  </RETURNS>
GtkCTree     *ctree,GtkCTreeNode *node
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_unselect</NAME>
<RETURNS>void  </RETURNS>
GtkCTree     *ctree,GtkCTreeNode *node
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_unselect_recursive</NAME>
<RETURNS>void  </RETURNS>
GtkCTree     *ctree,GtkCTreeNode *node
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_real_select_recursive</NAME>
<RETURNS>void  </RETURNS>
GtkCTree     *ctree,GtkCTreeNode *node,gint          state
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_node_set_text</NAME>
<RETURNS>void  </RETURNS>
GtkCTree     *ctree,GtkCTreeNode *node,gint          column,const gchar  *text
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_node_set_pixmap</NAME>
<RETURNS>void  </RETURNS>
GtkCTree     *ctree,GtkCTreeNode *node,gint          column,GdkPixmap    *pixmap,GdkBitmap    *mask
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_node_set_pixtext</NAME>
<RETURNS>void  </RETURNS>
GtkCTree     *ctree,GtkCTreeNode *node,gint          column,const gchar  *text,guint8        spacing,GdkPixmap    *pixmap,GdkBitmap    *mask
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_set_node_info</NAME>
<RETURNS>void  </RETURNS>
GtkCTree     *ctree,GtkCTreeNode *node,const gchar  *text,guint8        spacing,GdkPixmap    *pixmap_closed,GdkBitmap    *mask_closed,GdkPixmap    *pixmap_opened,GdkBitmap    *mask_opened,gboolean      is_leaf,gboolean      expanded
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_node_set_shift</NAME>
<RETURNS>void  </RETURNS>
GtkCTree     *ctree,GtkCTreeNode *node,gint          column,gint          vertical,gint          horizontal
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_node_set_selectable</NAME>
<RETURNS>void  </RETURNS>
GtkCTree     *ctree,GtkCTreeNode *node,gboolean      selectable
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_node_get_selectable</NAME>
<RETURNS>gboolean  </RETURNS>
GtkCTree     *ctree,GtkCTreeNode *node
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_node_get_cell_type</NAME>
<RETURNS>GtkCellType  </RETURNS>
GtkCTree     *ctree,GtkCTreeNode *node,gint          column
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_node_get_text</NAME>
<RETURNS>gint  </RETURNS>
GtkCTree     *ctree,GtkCTreeNode *node,gint          column,gchar       **text
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_node_get_pixmap</NAME>
<RETURNS>gint  </RETURNS>
GtkCTree     *ctree,GtkCTreeNode *node,gint          column,GdkPixmap   **pixmap,GdkBitmap   **mask
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_node_get_pixtext</NAME>
<RETURNS>gint  </RETURNS>
GtkCTree     *ctree,GtkCTreeNode *node,gint          column,gchar       **text,guint8       *spacing,GdkPixmap   **pixmap,GdkBitmap   **mask
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_get_node_info</NAME>
<RETURNS>gint  </RETURNS>
GtkCTree     *ctree,GtkCTreeNode *node,gchar       **text,guint8       *spacing,GdkPixmap   **pixmap_closed,GdkBitmap   **mask_closed,GdkPixmap   **pixmap_opened,GdkBitmap   **mask_opened,gboolean     *is_leaf,gboolean     *expanded
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_node_set_row_style</NAME>
<RETURNS>void  </RETURNS>
GtkCTree     *ctree,GtkCTreeNode *node,GtkStyle     *style
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_node_get_row_style</NAME>
<RETURNS>GtkStyle  *</RETURNS>
GtkCTree     *ctree,GtkCTreeNode *node
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_node_set_cell_style</NAME>
<RETURNS>void  </RETURNS>
GtkCTree     *ctree,GtkCTreeNode *node,gint          column,GtkStyle     *style
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_node_get_cell_style</NAME>
<RETURNS>GtkStyle  *</RETURNS>
GtkCTree     *ctree,GtkCTreeNode *node,gint          column
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_node_set_foreground</NAME>
<RETURNS>void  </RETURNS>
GtkCTree     *ctree,GtkCTreeNode *node,GdkColor     *color
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_node_set_background</NAME>
<RETURNS>void  </RETURNS>
GtkCTree     *ctree,GtkCTreeNode *node,GdkColor     *color
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_node_set_row_data</NAME>
<RETURNS>void  </RETURNS>
GtkCTree     *ctree,GtkCTreeNode *node,gpointer      data
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_node_set_row_data_full</NAME>
<RETURNS>void  </RETURNS>
GtkCTree     *ctree,GtkCTreeNode *node,gpointer      data,GtkDestroyNotify destroy
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_node_get_row_data</NAME>
<RETURNS>gpointer  </RETURNS>
GtkCTree     *ctree,GtkCTreeNode *node
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_node_moveto</NAME>
<RETURNS>void  </RETURNS>
GtkCTree     *ctree,GtkCTreeNode *node,gint          column,gfloat        row_align,gfloat        col_align
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_node_is_visible</NAME>
<RETURNS>GtkVisibility  </RETURNS>
GtkCTree     *ctree,GtkCTreeNode *node
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_set_indent</NAME>
<RETURNS>void  </RETURNS>
GtkCTree                *ctree,gint                     indent
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_set_spacing</NAME>
<RETURNS>void  </RETURNS>
GtkCTree                *ctree,gint                     spacing
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_set_show_stub</NAME>
<RETURNS>void  </RETURNS>
GtkCTree                *ctree,gboolean                 show_stub
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_set_line_style</NAME>
<RETURNS>void  </RETURNS>
GtkCTree                *ctree,GtkCTreeLineStyle        line_style
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_set_expander_style</NAME>
<RETURNS>void  </RETURNS>
GtkCTree                *ctree,GtkCTreeExpanderStyle    expander_style
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_set_drag_compare_func</NAME>
<RETURNS>void  </RETURNS>
GtkCTree     	      *ctree,GtkCTreeCompareDragFunc  cmp_func
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_sort_node</NAME>
<RETURNS>void  </RETURNS>
GtkCTree     *ctree,GtkCTreeNode *node
</FUNCTION>
<FUNCTION>
<NAME>gtk_ctree_sort_recursive</NAME>
<RETURNS>void  </RETURNS>
GtkCTree     *ctree,GtkCTreeNode *node
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_CURVE</NAME>
#define GTK_TYPE_CURVE                  (gtk_curve_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_CURVE</NAME>
#define GTK_CURVE(obj)                  (GTK_CHECK_CAST ((obj), GTK_TYPE_CURVE, GtkCurve))
</MACRO>
<MACRO>
<NAME>GTK_CURVE_CLASS</NAME>
#define GTK_CURVE_CLASS(klass)          (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_CURVE, GtkCurveClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_CURVE</NAME>
#define GTK_IS_CURVE(obj)               (GTK_CHECK_TYPE ((obj), GTK_TYPE_CURVE))
</MACRO>
<MACRO>
<NAME>GTK_IS_CURVE_CLASS</NAME>
#define GTK_IS_CURVE_CLASS(klass)       (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_CURVE))
</MACRO>
<STRUCT>
<NAME>GtkCurve</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkCurveClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkCurve</NAME>
struct GtkCurve
{
  GtkDrawingArea graph;

  gint cursor_type;
  gfloat min_x;
  gfloat max_x;
  gfloat min_y;
  gfloat max_y;
  GdkPixmap *pixmap;
  GtkCurveType curve_type;
  gint height;                  /* (cached) graph height in pixels */
  gint grab_point;              /* point currently grabbed */
  gint last;

  /* (cached) curve points: */
  gint num_points;
  GdkPoint *point;

  /* control points: */
  gint num_ctlpoints;           /* number of control points */
  gfloat (*ctlpoint)[2];        /* array of control points */
};
</STRUCT>
<FUNCTION>
<NAME>gtk_curve_get_type</NAME>
<RETURNS>GtkType 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_curve_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_curve_reset</NAME>
<RETURNS>void 	</RETURNS>
GtkCurve *curve
</FUNCTION>
<FUNCTION>
<NAME>gtk_curve_set_gamma</NAME>
<RETURNS>void 	</RETURNS>
GtkCurve *curve, gfloat gamma
</FUNCTION>
<FUNCTION>
<NAME>gtk_curve_set_range</NAME>
<RETURNS>void 	</RETURNS>
GtkCurve *curve,gfloat min_x, gfloat max_x,gfloat min_y, gfloat max_y
</FUNCTION>
<FUNCTION>
<NAME>gtk_curve_get_vector</NAME>
<RETURNS>void 	</RETURNS>
GtkCurve *curve,int veclen, gfloat vector[]
</FUNCTION>
<FUNCTION>
<NAME>gtk_curve_set_vector</NAME>
<RETURNS>void 	</RETURNS>
GtkCurve *curve,int veclen, gfloat vector[]
</FUNCTION>
<FUNCTION>
<NAME>gtk_curve_set_curve_type</NAME>
<RETURNS>void 	</RETURNS>
GtkCurve *curve, GtkCurveType type
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_DATA</NAME>
#define GTK_TYPE_DATA		 (gtk_data_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_DATA</NAME>
#define GTK_DATA(obj)		 (GTK_CHECK_CAST ((obj), GTK_TYPE_DATA, GtkData))
</MACRO>
<MACRO>
<NAME>GTK_DATA_CLASS</NAME>
#define GTK_DATA_CLASS(klass)	 (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_DATA, GtkDataClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_DATA</NAME>
#define GTK_IS_DATA(obj)	 (GTK_CHECK_TYPE ((obj), GTK_TYPE_DATA))
</MACRO>
<MACRO>
<NAME>GTK_IS_DATA_CLASS</NAME>
#define GTK_IS_DATA_CLASS(klass) (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_DATA))
</MACRO>
<STRUCT>
<NAME>GtkData</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkDataClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkData</NAME>
struct GtkData
{
  GtkObject object;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_data_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GtkDebugFlag</NAME>
typedef enum {
  GTK_DEBUG_OBJECTS    = 1 << 0,
  GTK_DEBUG_MISC       = 1 << 1,
  GTK_DEBUG_SIGNALS    = 1 << 2,
  GTK_DEBUG_DND        = 1 << 3,
  GTK_DEBUG_PLUGSOCKET = 1 << 4
} GtkDebugFlag;
</ENUM>
<MACRO>
<NAME>GTK_NOTE</NAME>
#define GTK_NOTE(type,action)                G_STMT_START { \
    if (gtk_debug_flags & GTK_DEBUG_##type)                 \
       { action; };                          } G_STMT_END
</MACRO>
<MACRO>
<NAME>GTK_NOTE</NAME>
#define GTK_NOTE(type, action)
</MACRO>
<VARIABLE>
<NAME>gtk_debug_flags</NAME>
extern guint gtk_debug_flags;
</VARIABLE>
<MACRO>
<NAME>GTK_TYPE_DIALOG</NAME>
#define GTK_TYPE_DIALOG                  (gtk_dialog_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_DIALOG</NAME>
#define GTK_DIALOG(obj)                  (GTK_CHECK_CAST ((obj), GTK_TYPE_DIALOG, GtkDialog))
</MACRO>
<MACRO>
<NAME>GTK_DIALOG_CLASS</NAME>
#define GTK_DIALOG_CLASS(klass)          (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_DIALOG, GtkDialogClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_DIALOG</NAME>
#define GTK_IS_DIALOG(obj)               (GTK_CHECK_TYPE ((obj), GTK_TYPE_DIALOG))
</MACRO>
<MACRO>
<NAME>GTK_IS_DIALOG_CLASS</NAME>
#define GTK_IS_DIALOG_CLASS(klass)       (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_DIALOG))
</MACRO>
<STRUCT>
<NAME>GtkDialog</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkDialogClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkDialogButton</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkDialog</NAME>
struct GtkDialog
{
  GtkWindow window;

  GtkWidget *vbox;
  GtkWidget *action_area;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_dialog_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_dialog_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GtkDestDefaults</NAME>
typedef enum {
  GTK_DEST_DEFAULT_MOTION     = 1 << 0, /* respond to "drag_motion" */
  GTK_DEST_DEFAULT_HIGHLIGHT  = 1 << 1, /* auto-highlight */
  GTK_DEST_DEFAULT_DROP       = 1 << 2, /* respond to "drag_drop" */
  GTK_DEST_DEFAULT_ALL        = 0x07
} GtkDestDefaults;
</ENUM>
<ENUM>
<NAME>GtkTargetFlags</NAME>
typedef enum {
  GTK_TARGET_SAME_APP = 1 << 0,    /*< nick=same-app >*/
  GTK_TARGET_SAME_WIDGET = 1 << 1  /*< nick=same-widget >*/
} GtkTargetFlags;
</ENUM>
<FUNCTION>
<NAME>gtk_drag_get_data</NAME>
<RETURNS>void  </RETURNS>
GtkWidget      *widget,GdkDragContext *context,GdkAtom         target,guint32         time
</FUNCTION>
<FUNCTION>
<NAME>gtk_drag_finish</NAME>
<RETURNS>void  </RETURNS>
GdkDragContext *context,gboolean        success,gboolean        del,guint32         time
</FUNCTION>
<FUNCTION>
<NAME>gtk_drag_get_source_widget</NAME>
<RETURNS>GtkWidget  *</RETURNS>
GdkDragContext *context
</FUNCTION>
<FUNCTION>
<NAME>gtk_drag_highlight</NAME>
<RETURNS>void  </RETURNS>
GtkWidget  *widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_drag_unhighlight</NAME>
<RETURNS>void  </RETURNS>
GtkWidget  *widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_drag_dest_set</NAME>
<RETURNS>void  </RETURNS>
GtkWidget            *widget,GtkDestDefaults       flags,const GtkTargetEntry *targets,gint                  n_targets,GdkDragAction         actions
</FUNCTION>
<FUNCTION>
<NAME>gtk_drag_dest_set_proxy</NAME>
<RETURNS>void  </RETURNS>
GtkWidget      *widget,GdkWindow      *proxy_window,GdkDragProtocol protocol,gboolean        use_coordinates
</FUNCTION>
<FUNCTION>
<NAME>gtk_drag_dest_unset</NAME>
<RETURNS>void  </RETURNS>
GtkWidget          *widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_drag_source_set</NAME>
<RETURNS>void  </RETURNS>
GtkWidget            *widget,GdkModifierType       start_button_mask,const GtkTargetEntry *targets,gint                  n_targets,GdkDragAction         actions
</FUNCTION>
<FUNCTION>
<NAME>gtk_drag_source_unset</NAME>
<RETURNS>void  </RETURNS>
GtkWidget        *widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_drag_source_set_icon</NAME>
<RETURNS>void  </RETURNS>
GtkWidget     *widget,GdkColormap   *colormap,GdkPixmap     *pixmap,GdkBitmap     *mask
</FUNCTION>
<FUNCTION>
<NAME>gtk_drag_begin</NAME>
<RETURNS>GdkDragContext  *</RETURNS>
GtkWidget         *widget,GtkTargetList     *targets,GdkDragAction      actions,gint               button,GdkEvent          *event
</FUNCTION>
<FUNCTION>
<NAME>gtk_drag_set_icon_widget</NAME>
<RETURNS>void  </RETURNS>
GdkDragContext    *context,GtkWidget         *widget,gint               hot_x,gint               hot_y
</FUNCTION>
<FUNCTION>
<NAME>gtk_drag_set_icon_pixmap</NAME>
<RETURNS>void  </RETURNS>
GdkDragContext    *context,GdkColormap       *colormap,GdkPixmap         *pixmap,GdkBitmap         *mask,gint               hot_x,gint               hot_y
</FUNCTION>
<FUNCTION>
<NAME>gtk_drag_set_icon_default</NAME>
<RETURNS>void  </RETURNS>
GdkDragContext    *context
</FUNCTION>
<FUNCTION>
<NAME>gtk_drag_set_default_icon</NAME>
<RETURNS>void  </RETURNS>
GdkColormap   *colormap,GdkPixmap     *pixmap,GdkBitmap     *mask,gint           hot_x,gint           hot_y
</FUNCTION>
<FUNCTION>
<NAME>gtk_drag_source_handle_event</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *widget,GdkEvent  *event
</FUNCTION>
<FUNCTION>
<NAME>gtk_drag_dest_handle_event</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *toplevel,GdkEvent  *event
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_DRAWING_AREA</NAME>
#define GTK_TYPE_DRAWING_AREA            (gtk_drawing_area_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_DRAWING_AREA</NAME>
#define GTK_DRAWING_AREA(obj)            (GTK_CHECK_CAST ((obj), GTK_TYPE_DRAWING_AREA, GtkDrawingArea))
</MACRO>
<MACRO>
<NAME>GTK_DRAWING_AREA_CLASS</NAME>
#define GTK_DRAWING_AREA_CLASS(klass)    (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_DRAWING_AREA, GtkDrawingAreaClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_DRAWING_AREA</NAME>
#define GTK_IS_DRAWING_AREA(obj)         (GTK_CHECK_TYPE ((obj), GTK_TYPE_DRAWING_AREA))
</MACRO>
<MACRO>
<NAME>GTK_IS_DRAWING_AREA_CLASS</NAME>
#define GTK_IS_DRAWING_AREA_CLASS(klass) (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_DRAWING_AREA))
</MACRO>
<STRUCT>
<NAME>GtkDrawingArea</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkDrawingAreaClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkDrawingArea</NAME>
struct GtkDrawingArea
{
  GtkWidget widget;

  gpointer draw_data;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_drawing_area_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_drawing_area_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_drawing_area_size</NAME>
<RETURNS>void  </RETURNS>
GtkDrawingArea      *darea,gint                 width,gint                 height
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_EDITABLE</NAME>
#define GTK_TYPE_EDITABLE            (gtk_editable_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_EDITABLE</NAME>
#define GTK_EDITABLE(obj)            (GTK_CHECK_CAST ((obj), GTK_TYPE_EDITABLE, GtkEditable))
</MACRO>
<MACRO>
<NAME>GTK_EDITABLE_CLASS</NAME>
#define GTK_EDITABLE_CLASS(klass)    (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_EDITABLE, GtkEditableClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_EDITABLE</NAME>
#define GTK_IS_EDITABLE(obj)         (GTK_CHECK_TYPE ((obj), GTK_TYPE_EDITABLE))
</MACRO>
<MACRO>
<NAME>GTK_IS_EDITABLE_CLASS</NAME>
#define GTK_IS_EDITABLE_CLASS(klass) (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_EDITABLE))
</MACRO>
<STRUCT>
<NAME>GtkEditable</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkEditableClass</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>GtkTextFunction</NAME>
<RETURNS>void </RETURNS>
GtkEditable  *editable, guint32 time
</USER_FUNCTION>
<STRUCT>
<NAME>GtkEditable</NAME>
struct GtkEditable
{
  GtkWidget widget;

  /*< public >*/
  guint      current_pos;

  guint      selection_start_pos;
  guint      selection_end_pos;
  guint      has_selection : 1;

  /*< private >*/
  guint      editable : 1;
  guint      visible : 1;
  GdkIC     *ic;
  GdkICAttr *ic_attr;
  
  gchar *clipboard_text;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_editable_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_editable_select_region</NAME>
<RETURNS>void  </RETURNS>
GtkEditable      *editable,gint              start,gint              end
</FUNCTION>
<FUNCTION>
<NAME>gtk_editable_insert_text</NAME>
<RETURNS>void  </RETURNS>
GtkEditable       *editable,const gchar      *new_text,gint              new_text_length,gint             *position
</FUNCTION>
<FUNCTION>
<NAME>gtk_editable_delete_text</NAME>
<RETURNS>void  </RETURNS>
GtkEditable      *editable,gint              start_pos,gint              end_pos
</FUNCTION>
<FUNCTION>
<NAME>gtk_editable_get_chars</NAME>
<RETURNS>gchar *</RETURNS>
GtkEditable      *editable,gint              start_pos,gint              end_pos
</FUNCTION>
<FUNCTION>
<NAME>gtk_editable_cut_clipboard</NAME>
<RETURNS>void  </RETURNS>
GtkEditable      *editable
</FUNCTION>
<FUNCTION>
<NAME>gtk_editable_copy_clipboard</NAME>
<RETURNS>void  </RETURNS>
GtkEditable      *editable
</FUNCTION>
<FUNCTION>
<NAME>gtk_editable_paste_clipboard</NAME>
<RETURNS>void  </RETURNS>
GtkEditable     *editable
</FUNCTION>
<FUNCTION>
<NAME>gtk_editable_claim_selection</NAME>
<RETURNS>void  </RETURNS>
GtkEditable     *editable,gboolean         claim,guint32          time
</FUNCTION>
<FUNCTION>
<NAME>gtk_editable_delete_selection</NAME>
<RETURNS>void  </RETURNS>
GtkEditable    *editable
</FUNCTION>
<FUNCTION>
<NAME>gtk_editable_changed</NAME>
<RETURNS>void  </RETURNS>
GtkEditable    *editable
</FUNCTION>
<FUNCTION>
<NAME>gtk_editable_set_position</NAME>
<RETURNS>void  </RETURNS>
GtkEditable    *editable,gint            position
</FUNCTION>
<FUNCTION>
<NAME>gtk_editable_get_position</NAME>
<RETURNS>gint  </RETURNS>
GtkEditable    *editable
</FUNCTION>
<FUNCTION>
<NAME>gtk_editable_set_editable</NAME>
<RETURNS>void  </RETURNS>
GtkEditable    *editable,gboolean        is_editable
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_ENTRY</NAME>
#define GTK_TYPE_ENTRY                  (gtk_entry_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_ENTRY</NAME>
#define GTK_ENTRY(obj)                  (GTK_CHECK_CAST ((obj), GTK_TYPE_ENTRY, GtkEntry))
</MACRO>
<MACRO>
<NAME>GTK_ENTRY_CLASS</NAME>
#define GTK_ENTRY_CLASS(klass)          (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_ENTRY, GtkEntryClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_ENTRY</NAME>
#define GTK_IS_ENTRY(obj)               (GTK_CHECK_TYPE ((obj), GTK_TYPE_ENTRY))
</MACRO>
<MACRO>
<NAME>GTK_IS_ENTRY_CLASS</NAME>
#define GTK_IS_ENTRY_CLASS(klass)       (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_ENTRY))
</MACRO>
<STRUCT>
<NAME>GtkEntry</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkEntryClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkEntry</NAME>
struct GtkEntry
{
  GtkEditable editable;

  GdkWindow *text_area;
  GdkPixmap *backing_pixmap;
  GdkCursor *cursor;
  GdkWChar  *text;

  guint16 text_size;	/* allocated size */
  guint16 text_length;	/* length in use */
  guint16 text_max_length;
  gint    scroll_offset;
  guint   visible : 1;	/* deprecated - see editable->visible */
  guint32 timer;
  guint   button;

  /* The x-offset of each character (including the last insertion position)
   * only valid when the widget is realized */
  gint   *char_offset;

  /* Same as 'text', but in multibyte */
  gchar  *text_mb;
  /* If true, 'text' and 'text_mb' are not coherent */
  guint   text_mb_dirty : 1;
  /* If true, we use the encoding of wchar_t as the encoding of 'text'.
   * Otherwise we use the encoding of multi-byte characters instead. */
  guint   use_wchar : 1;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_entry_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_entry_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_entry_new_with_max_length</NAME>
<RETURNS>GtkWidget *</RETURNS>
guint16       max
</FUNCTION>
<FUNCTION>
<NAME>gtk_entry_set_text</NAME>
<RETURNS>void  </RETURNS>
GtkEntry      *entry,const gchar   *text
</FUNCTION>
<FUNCTION>
<NAME>gtk_entry_append_text</NAME>
<RETURNS>void  </RETURNS>
GtkEntry      *entry,const gchar   *text
</FUNCTION>
<FUNCTION>
<NAME>gtk_entry_prepend_text</NAME>
<RETURNS>void  </RETURNS>
GtkEntry      *entry,const gchar   *text
</FUNCTION>
<FUNCTION>
<NAME>gtk_entry_set_position</NAME>
<RETURNS>void  </RETURNS>
GtkEntry      *entry,gint           position
</FUNCTION>
<FUNCTION>
<NAME>gtk_entry_get_text</NAME>
<RETURNS>gchar *</RETURNS>
GtkEntry      *entry
</FUNCTION>
<FUNCTION>
<NAME>gtk_entry_select_region</NAME>
<RETURNS>void  </RETURNS>
GtkEntry      *entry,gint           start,gint           end
</FUNCTION>
<FUNCTION>
<NAME>gtk_entry_set_visibility</NAME>
<RETURNS>void  </RETURNS>
GtkEntry      *entry,gboolean       visible
</FUNCTION>
<FUNCTION>
<NAME>gtk_entry_set_editable</NAME>
<RETURNS>void  </RETURNS>
GtkEntry      *entry,gboolean       editable
</FUNCTION>
<FUNCTION>
<NAME>gtk_entry_set_max_length</NAME>
<RETURNS>void  </RETURNS>
GtkEntry      *entry,guint16        max
</FUNCTION>
<ENUM>
<NAME>GtkArrowType</NAME>
typedef enum
{
  GTK_ARROW_UP,
  GTK_ARROW_DOWN,
  GTK_ARROW_LEFT,
  GTK_ARROW_RIGHT
} GtkArrowType;
</ENUM>
<ENUM>
<NAME>GtkAttachOptions</NAME>
typedef enum
{
  GTK_EXPAND = 1 << 0,
  GTK_SHRINK = 1 << 1,
  GTK_FILL   = 1 << 2
} GtkAttachOptions;
</ENUM>
<ENUM>
<NAME>GtkButtonBoxStyle</NAME>
typedef enum 
{
  GTK_BUTTONBOX_DEFAULT_STYLE,
  GTK_BUTTONBOX_SPREAD,
  GTK_BUTTONBOX_EDGE,
  GTK_BUTTONBOX_START,
  GTK_BUTTONBOX_END
} GtkButtonBoxStyle;
</ENUM>
<ENUM>
<NAME>GtkCurveType</NAME>
typedef enum
{
  GTK_CURVE_TYPE_LINEAR,       /* linear interpolation */
  GTK_CURVE_TYPE_SPLINE,       /* spline interpolation */
  GTK_CURVE_TYPE_FREE          /* free form curve */
} GtkCurveType;
</ENUM>
<ENUM>
<NAME>GtkDirectionType</NAME>
typedef enum
{
  GTK_DIR_TAB_FORWARD,
  GTK_DIR_TAB_BACKWARD,
  GTK_DIR_UP,
  GTK_DIR_DOWN,
  GTK_DIR_LEFT,
  GTK_DIR_RIGHT
} GtkDirectionType;
</ENUM>
<ENUM>
<NAME>GtkJustification</NAME>
typedef enum
{
  GTK_JUSTIFY_LEFT,
  GTK_JUSTIFY_RIGHT,
  GTK_JUSTIFY_CENTER,
  GTK_JUSTIFY_FILL
} GtkJustification;
</ENUM>
<ENUM>
<NAME>GtkMatchType</NAME>
typedef enum
{
  GTK_MATCH_ALL,       /* "*A?A*" */
  GTK_MATCH_ALL_TAIL,  /* "*A?AA" */
  GTK_MATCH_HEAD,      /* "AAAA*" */
  GTK_MATCH_TAIL,      /* "*AAAA" */
  GTK_MATCH_EXACT,     /* "AAAAA" */
  GTK_MATCH_LAST
} GtkMatchType;
</ENUM>
<ENUM>
<NAME>GtkMenuDirectionType</NAME>
typedef enum
{
  GTK_MENU_DIR_PARENT,
  GTK_MENU_DIR_CHILD,
  GTK_MENU_DIR_NEXT,
  GTK_MENU_DIR_PREV
} GtkMenuDirectionType;
</ENUM>
<ENUM>
<NAME>GtkMenuFactoryType</NAME>
typedef enum
{
  GTK_MENU_FACTORY_MENU,
  GTK_MENU_FACTORY_MENU_BAR,
  GTK_MENU_FACTORY_OPTION_MENU
} GtkMenuFactoryType;
</ENUM>
<ENUM>
<NAME>GtkMetricType</NAME>
typedef enum
{
  GTK_PIXELS,
  GTK_INCHES,
  GTK_CENTIMETERS
} GtkMetricType;
</ENUM>
<ENUM>
<NAME>GtkOrientation</NAME>
typedef enum
{
  GTK_ORIENTATION_HORIZONTAL,
  GTK_ORIENTATION_VERTICAL
} GtkOrientation;
</ENUM>
<ENUM>
<NAME>GtkCornerType</NAME>
typedef enum
{
  GTK_CORNER_TOP_LEFT,
  GTK_CORNER_BOTTOM_LEFT,
  GTK_CORNER_TOP_RIGHT,
  GTK_CORNER_BOTTOM_RIGHT
} GtkCornerType;
</ENUM>
<ENUM>
<NAME>GtkPackType</NAME>
typedef enum
{
  GTK_PACK_START,
  GTK_PACK_END
} GtkPackType;
</ENUM>
<ENUM>
<NAME>GtkPathPriorityType</NAME>
typedef enum
{
  GTK_PATH_PRIO_LOWEST      = 0,
  GTK_PATH_PRIO_GTK	    = 4,
  GTK_PATH_PRIO_APPLICATION = 8,
  GTK_PATH_PRIO_RC          = 12,
  GTK_PATH_PRIO_HIGHEST     = 15,
  GTK_PATH_PRIO_MASK        = 0x0f
} GtkPathPriorityType;
</ENUM>
<ENUM>
<NAME>GtkPathType</NAME>
typedef enum
{
  GTK_PATH_WIDGET,
  GTK_PATH_WIDGET_CLASS,
  GTK_PATH_CLASS
} GtkPathType;
</ENUM>
<ENUM>
<NAME>GtkPolicyType</NAME>
typedef enum
{
  GTK_POLICY_ALWAYS,
  GTK_POLICY_AUTOMATIC,
  GTK_POLICY_NEVER
} GtkPolicyType;
</ENUM>
<ENUM>
<NAME>GtkPositionType</NAME>
typedef enum
{
  GTK_POS_LEFT,
  GTK_POS_RIGHT,
  GTK_POS_TOP,
  GTK_POS_BOTTOM
} GtkPositionType;
</ENUM>
<ENUM>
<NAME>GtkPreviewType</NAME>
typedef enum
{
  GTK_PREVIEW_COLOR,
  GTK_PREVIEW_GRAYSCALE
} GtkPreviewType;
</ENUM>
<ENUM>
<NAME>GtkReliefStyle</NAME>
typedef enum
{
  GTK_RELIEF_NORMAL,
  GTK_RELIEF_HALF,
  GTK_RELIEF_NONE
} GtkReliefStyle;
</ENUM>
<ENUM>
<NAME>GtkResizeMode</NAME>
typedef enum
{
  GTK_RESIZE_PARENT,		/* Pass resize request to the parent */
  GTK_RESIZE_QUEUE,		/* Queue resizes on this widget */
  GTK_RESIZE_IMMEDIATE		/* Perform the resizes now */
} GtkResizeMode;
</ENUM>
<ENUM>
<NAME>GtkSignalRunType</NAME>
typedef enum			/*< flags >*/
{
  GTK_RUN_FIRST      = 1 << 0,
  GTK_RUN_LAST       = 1 << 1,
  GTK_RUN_BOTH       = (GTK_RUN_FIRST | GTK_RUN_LAST),
  GTK_RUN_NO_RECURSE = 1 << 2,
  GTK_RUN_ACTION     = 1 << 3,
  GTK_RUN_NO_HOOKS   = 1 << 4
} GtkSignalRunType;
</ENUM>
<ENUM>
<NAME>GtkScrollType</NAME>
typedef enum
{
  GTK_SCROLL_NONE,
  GTK_SCROLL_STEP_BACKWARD,
  GTK_SCROLL_STEP_FORWARD,
  GTK_SCROLL_PAGE_BACKWARD,
  GTK_SCROLL_PAGE_FORWARD,
  GTK_SCROLL_JUMP
} GtkScrollType;
</ENUM>
<ENUM>
<NAME>GtkSelectionMode</NAME>
typedef enum
{
  GTK_SELECTION_SINGLE,
  GTK_SELECTION_BROWSE,
  GTK_SELECTION_MULTIPLE,
  GTK_SELECTION_EXTENDED
} GtkSelectionMode;
</ENUM>
<ENUM>
<NAME>GtkShadowType</NAME>
typedef enum
{
  GTK_SHADOW_NONE,
  GTK_SHADOW_IN,
  GTK_SHADOW_OUT,
  GTK_SHADOW_ETCHED_IN,
  GTK_SHADOW_ETCHED_OUT
} GtkShadowType;
</ENUM>
<ENUM>
<NAME>GtkStateType</NAME>
typedef enum
{
  GTK_STATE_NORMAL,
  GTK_STATE_ACTIVE,
  GTK_STATE_PRELIGHT,
  GTK_STATE_SELECTED,
  GTK_STATE_INSENSITIVE
} GtkStateType;
</ENUM>
<ENUM>
<NAME>GtkSubmenuDirection</NAME>
typedef enum
{
  GTK_DIRECTION_LEFT,
  GTK_DIRECTION_RIGHT
} GtkSubmenuDirection;
</ENUM>
<ENUM>
<NAME>GtkSubmenuPlacement</NAME>
typedef enum
{
  GTK_TOP_BOTTOM,
  GTK_LEFT_RIGHT
} GtkSubmenuPlacement;
</ENUM>
<ENUM>
<NAME>GtkToolbarStyle</NAME>
typedef enum
{
  GTK_TOOLBAR_ICONS,
  GTK_TOOLBAR_TEXT,
  GTK_TOOLBAR_BOTH
} GtkToolbarStyle;
</ENUM>
<ENUM>
<NAME>GtkTroughType</NAME>
typedef enum
{
  GTK_TROUGH_NONE,
  GTK_TROUGH_START,
  GTK_TROUGH_END,
  GTK_TROUGH_JUMP
} GtkTroughType;
</ENUM>
<ENUM>
<NAME>GtkUpdateType</NAME>
typedef enum
{
  GTK_UPDATE_CONTINUOUS,
  GTK_UPDATE_DISCONTINUOUS,
  GTK_UPDATE_DELAYED
} GtkUpdateType;
</ENUM>
<ENUM>
<NAME>GtkVisibility</NAME>
typedef enum
{
  GTK_VISIBILITY_NONE,
  GTK_VISIBILITY_PARTIAL,
  GTK_VISIBILITY_FULL
} GtkVisibility;
</ENUM>
<ENUM>
<NAME>GtkWindowPosition</NAME>
typedef enum
{
  GTK_WIN_POS_NONE,
  GTK_WIN_POS_CENTER,
  GTK_WIN_POS_MOUSE
} GtkWindowPosition;
</ENUM>
<ENUM>
<NAME>GtkWindowType</NAME>
typedef enum
{
  GTK_WINDOW_TOPLEVEL,
  GTK_WINDOW_DIALOG,
  GTK_WINDOW_POPUP
} GtkWindowType;
</ENUM>
<ENUM>
<NAME>GtkSortType</NAME>
typedef enum
{
  GTK_SORT_ASCENDING,
  GTK_SORT_DESCENDING
} GtkSortType;
</ENUM>
<MACRO>
<NAME>GTK_TYPE_EVENT_BOX</NAME>
#define GTK_TYPE_EVENT_BOX		(gtk_event_box_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_EVENT_BOX</NAME>
#define GTK_EVENT_BOX(obj)		(GTK_CHECK_CAST ((obj), GTK_TYPE_EVENT_BOX, GtkEventBox))
</MACRO>
<MACRO>
<NAME>GTK_EVENT_BOX_CLASS</NAME>
#define GTK_EVENT_BOX_CLASS(klass)	(GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_EVENT_BOX, GtkEventBoxClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_EVENT_BOX</NAME>
#define GTK_IS_EVENT_BOX(obj)		(GTK_CHECK_TYPE ((obj), GTK_TYPE_EVENT_BOX))
</MACRO>
<MACRO>
<NAME>GTK_IS_EVENT_BOX_CLASS</NAME>
#define GTK_IS_EVENT_BOX_CLASS(klass)	(GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_EVENT_BOX))
</MACRO>
<STRUCT>
<NAME>GtkEventBox</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkEventBoxClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkEventBox</NAME>
struct GtkEventBox
{
  GtkBin bin;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_event_box_get_type</NAME>
<RETURNS>GtkType 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_event_box_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GTK_MAJOR_VERSION</NAME>
#define GTK_MAJOR_VERSION				(1)
</MACRO>
<MACRO>
<NAME>GTK_MINOR_VERSION</NAME>
#define GTK_MINOR_VERSION				(2)
</MACRO>
<MACRO>
<NAME>GTK_MICRO_VERSION</NAME>
#define GTK_MICRO_VERSION				(3)
</MACRO>
<MACRO>
<NAME>GTK_BINARY_AGE</NAME>
#define GTK_BINARY_AGE					(3)
</MACRO>
<MACRO>
<NAME>GTK_INTERFACE_AGE</NAME>
#define GTK_INTERFACE_AGE				(1)
</MACRO>
<MACRO>
<NAME>GTK_CHECK_VERSION</NAME>
#define	GTK_CHECK_VERSION(major,minor,micro)	\
    (GTK_MAJOR_VERSION > (major) || \
     (GTK_MAJOR_VERSION == (major) && GTK_MINOR_VERSION > (minor)) || \
     (GTK_MAJOR_VERSION == (major) && GTK_MINOR_VERSION == (minor) && \
      GTK_MICRO_VERSION >= (micro)))
</MACRO>
<MACRO>
<NAME>GTK_HAVE_CONTAINER_FOCUS_ADJUSTMENTS</NAME>
#define GTK_HAVE_CONTAINER_FOCUS_ADJUSTMENTS		1-0-1
</MACRO>
<MACRO>
<NAME>GTK_HAVE_SIGNAL_INIT</NAME>
#define GTK_HAVE_SIGNAL_INIT				1-0-2
</MACRO>
<MACRO>
<NAME>GTK_HAVE_FEATURES_1_1_0</NAME>
#define GTK_HAVE_FEATURES_1_1_0				1-1-0
</MACRO>
<MACRO>
<NAME>GTK_HAVE_FEATURES_1_1_2</NAME>
#define GTK_HAVE_FEATURES_1_1_2				1-1-2
</MACRO>
<MACRO>
<NAME>GTK_HAVE_FEATURES_1_1_4</NAME>
#define GTK_HAVE_FEATURES_1_1_4				1-1-4
</MACRO>
<MACRO>
<NAME>GTK_HAVE_FEATURES_1_1_5</NAME>
#define GTK_HAVE_FEATURES_1_1_5				1-1-5
</MACRO>
<MACRO>
<NAME>GTK_HAVE_FEATURES_1_1_6</NAME>
#define GTK_HAVE_FEATURES_1_1_6				1-1-6
</MACRO>
<MACRO>
<NAME>GTK_HAVE_FEATURES_1_1_7</NAME>
#define GTK_HAVE_FEATURES_1_1_7				1-1-7
</MACRO>
<MACRO>
<NAME>GTK_HAVE_FEATURES_1_1_8</NAME>
#define GTK_HAVE_FEATURES_1_1_8				1-1-8
</MACRO>
<MACRO>
<NAME>GTK_HAVE_FEATURES_1_1_9</NAME>
#define GTK_HAVE_FEATURES_1_1_9				1-1-9
</MACRO>
<MACRO>
<NAME>GTK_HAVE_FEATURES_1_1_10</NAME>
#define GTK_HAVE_FEATURES_1_1_10			1-1-10
</MACRO>
<MACRO>
<NAME>GTK_HAVE_FEATURES_1_1_11</NAME>
#define GTK_HAVE_FEATURES_1_1_11			1-1-11
</MACRO>
<MACRO>
<NAME>GTK_HAVE_FEATURES_1_1_12</NAME>
#define GTK_HAVE_FEATURES_1_1_12			1-1-12
</MACRO>
<MACRO>
<NAME>GTK_HAVE_FEATURES_1_1_13</NAME>
#define GTK_HAVE_FEATURES_1_1_13			1-1-13
</MACRO>
<MACRO>
<NAME>GTK_HAVE_FEATURES_1_1_14</NAME>
#define GTK_HAVE_FEATURES_1_1_14			1-1-14
</MACRO>
<MACRO>
<NAME>GTK_TYPE_FILE_SELECTION</NAME>
#define GTK_TYPE_FILE_SELECTION            (gtk_file_selection_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_FILE_SELECTION</NAME>
#define GTK_FILE_SELECTION(obj)            (GTK_CHECK_CAST ((obj), GTK_TYPE_FILE_SELECTION, GtkFileSelection))
</MACRO>
<MACRO>
<NAME>GTK_FILE_SELECTION_CLASS</NAME>
#define GTK_FILE_SELECTION_CLASS(klass)    (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_FILE_SELECTION, GtkFileSelectionClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_FILE_SELECTION</NAME>
#define GTK_IS_FILE_SELECTION(obj)         (GTK_CHECK_TYPE ((obj), GTK_TYPE_FILE_SELECTION))
</MACRO>
<MACRO>
<NAME>GTK_IS_FILE_SELECTION_CLASS</NAME>
#define GTK_IS_FILE_SELECTION_CLASS(klass) (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_FILE_SELECTION))
</MACRO>
<STRUCT>
<NAME>GtkFileSelection</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkFileSelectionClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkFileSelection</NAME>
struct GtkFileSelection
{
  GtkWindow window;

  GtkWidget *dir_list;
  GtkWidget *file_list;
  GtkWidget *selection_entry;
  GtkWidget *selection_text;
  GtkWidget *main_vbox;
  GtkWidget *ok_button;
  GtkWidget *cancel_button;
  GtkWidget *help_button;
  GtkWidget *history_pulldown;
  GtkWidget *history_menu;
  GList     *history_list;
  GtkWidget *fileop_dialog;
  GtkWidget *fileop_entry;
  gchar     *fileop_file;
  gpointer   cmpl_state;
  
  GtkWidget *fileop_c_dir;
  GtkWidget *fileop_del_file;
  GtkWidget *fileop_ren_file;
  
  GtkWidget *button_area;
  GtkWidget *action_area;
  
};
</STRUCT>
<FUNCTION>
<NAME>gtk_file_selection_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_file_selection_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
const gchar      *title
</FUNCTION>
<FUNCTION>
<NAME>gtk_file_selection_set_filename</NAME>
<RETURNS>void  </RETURNS>
GtkFileSelection *filesel,const gchar      *filename
</FUNCTION>
<FUNCTION>
<NAME>gtk_file_selection_get_filename</NAME>
<RETURNS>gchar *</RETURNS>
GtkFileSelection *filesel
</FUNCTION>
<FUNCTION>
<NAME>gtk_file_selection_complete</NAME>
<RETURNS>void 	</RETURNS>
GtkFileSelection *filesel,const gchar	    *pattern
</FUNCTION>
<FUNCTION>
<NAME>gtk_file_selection_show_fileop_buttons</NAME>
<RETURNS>void  </RETURNS>
GtkFileSelection *filesel
</FUNCTION>
<FUNCTION>
<NAME>gtk_file_selection_hide_fileop_buttons</NAME>
<RETURNS>void  </RETURNS>
GtkFileSelection *filesel
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_FIXED</NAME>
#define GTK_TYPE_FIXED                  (gtk_fixed_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_FIXED</NAME>
#define GTK_FIXED(obj)                  (GTK_CHECK_CAST ((obj), GTK_TYPE_FIXED, GtkFixed))
</MACRO>
<MACRO>
<NAME>GTK_FIXED_CLASS</NAME>
#define GTK_FIXED_CLASS(klass)          (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_FIXED, GtkFixedClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_FIXED</NAME>
#define GTK_IS_FIXED(obj)               (GTK_CHECK_TYPE ((obj), GTK_TYPE_FIXED))
</MACRO>
<MACRO>
<NAME>GTK_IS_FIXED_CLASS</NAME>
#define GTK_IS_FIXED_CLASS(klass)       (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_FIXED))
</MACRO>
<STRUCT>
<NAME>GtkFixed</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkFixedClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkFixedChild</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkFixed</NAME>
struct GtkFixed
{
  GtkContainer container;

  GList *children;
};
</STRUCT>
<STRUCT>
<NAME>GtkFixedChild</NAME>
struct GtkFixedChild
{
  GtkWidget *widget;
  gint16 x;
  gint16 y;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_fixed_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_fixed_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_fixed_put</NAME>
<RETURNS>void  </RETURNS>
GtkFixed       *fixed,GtkWidget      *widget,gint16         x,gint16         y
</FUNCTION>
<FUNCTION>
<NAME>gtk_fixed_move</NAME>
<RETURNS>void  </RETURNS>
GtkFixed       *fixed,GtkWidget      *widget,gint16         x,gint16         y
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_FONT_SELECTION</NAME>
#define GTK_TYPE_FONT_SELECTION		     (gtk_font_selection_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_FONT_SELECTION</NAME>
#define GTK_FONT_SELECTION(obj)		     (GTK_CHECK_CAST ((obj), GTK_TYPE_FONT_SELECTION, GtkFontSelection))
</MACRO>
<MACRO>
<NAME>GTK_FONT_SELECTION_CLASS</NAME>
#define GTK_FONT_SELECTION_CLASS(klass)	     (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_FONT_SELECTION, GtkFontSelectionClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_FONT_SELECTION</NAME>
#define GTK_IS_FONT_SELECTION(obj)	     (GTK_CHECK_TYPE ((obj), GTK_TYPE_FONT_SELECTION))
</MACRO>
<MACRO>
<NAME>GTK_IS_FONT_SELECTION_CLASS</NAME>
#define GTK_IS_FONT_SELECTION_CLASS(klass)   (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_FONT_SELECTION))
</MACRO>
<MACRO>
<NAME>GTK_TYPE_FONT_SELECTION_DIALOG</NAME>
#define GTK_TYPE_FONT_SELECTION_DIALOG		    (gtk_font_selection_dialog_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_FONT_SELECTION_DIALOG</NAME>
#define GTK_FONT_SELECTION_DIALOG(obj)		    (GTK_CHECK_CAST ((obj), GTK_TYPE_FONT_SELECTION_DIALOG, GtkFontSelectionDialog))
</MACRO>
<MACRO>
<NAME>GTK_FONT_SELECTION_DIALOG_CLASS</NAME>
#define GTK_FONT_SELECTION_DIALOG_CLASS(klass)	    (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_FONT_SELECTION_DIALOG, GtkFontSelectionDialogClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_FONT_SELECTION_DIALOG</NAME>
#define GTK_IS_FONT_SELECTION_DIALOG(obj)	    (GTK_CHECK_TYPE ((obj), GTK_TYPE_FONT_SELECTION_DIALOG))
</MACRO>
<MACRO>
<NAME>GTK_IS_FONT_SELECTION_DIALOG_CLASS</NAME>
#define GTK_IS_FONT_SELECTION_DIALOG_CLASS(klass)   (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_FONT_SELECTION_DIALOG))
</MACRO>
<STRUCT>
<NAME>GtkFontSelection</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkFontSelectionClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkFontSelectionDialog</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkFontSelectionDialogClass</NAME>
</STRUCT>
<MACRO>
<NAME>GTK_NUM_FONT_PROPERTIES</NAME>
#define GTK_NUM_FONT_PROPERTIES	 6
</MACRO>
<MACRO>
<NAME>GTK_NUM_STYLE_PROPERTIES</NAME>
#define GTK_NUM_STYLE_PROPERTIES 5
</MACRO>
<ENUM>
<NAME>GtkFontMetricType</NAME>
typedef enum
{
  GTK_FONT_METRIC_PIXELS,
  GTK_FONT_METRIC_POINTS
} GtkFontMetricType;
</ENUM>
<ENUM>
<NAME>GtkFontType</NAME>
typedef enum
{
  GTK_FONT_BITMAP		= 1 << 0,
  GTK_FONT_SCALABLE		= 1 << 1,
  GTK_FONT_SCALABLE_BITMAP	= 1 << 2,

  GTK_FONT_ALL			= 0x07
} GtkFontType;
</ENUM>
<MACRO>
<NAME>GTK_NUM_FONT_FILTERS</NAME>
#define	GTK_NUM_FONT_FILTERS	2
</MACRO>
<ENUM>
<NAME>GtkFontFilterType</NAME>
typedef enum
{
  GTK_FONT_FILTER_BASE,
  GTK_FONT_FILTER_USER
} GtkFontFilterType;
</ENUM>
<STRUCT>
<NAME>GtkFontFilter</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkFontFilter</NAME>
struct GtkFontFilter
{
  gint font_type;
  guint16 *property_filters[GTK_NUM_FONT_PROPERTIES];
  guint16 property_nfilters[GTK_NUM_FONT_PROPERTIES];
};
</STRUCT>
<STRUCT>
<NAME>GtkFontSelection</NAME>
struct GtkFontSelection
{
  GtkNotebook notebook;
  
  /* These are on the font page. */
  GtkWidget *main_vbox;
  GtkWidget *font_label;
  GtkWidget *font_entry;
  GtkWidget *font_clist;
  GtkWidget *font_style_entry;
  GtkWidget *font_style_clist;
  GtkWidget *size_entry;
  GtkWidget *size_clist;
  GtkWidget *pixels_button;
  GtkWidget *points_button;
  GtkWidget *filter_button;
  GtkWidget *preview_entry;
  GtkWidget *message_label;
  
  /* These are on the font info page. */
  GtkWidget *info_vbox;
  GtkWidget *info_clist;
  GtkWidget *requested_font_name;
  GtkWidget *actual_font_name;
  
  /* These are on the filter page. */
  GtkWidget *filter_vbox;
  GtkWidget *type_bitmaps_button;
  GtkWidget *type_scalable_button;
  GtkWidget *type_scaled_bitmaps_button;
  GtkWidget *filter_clists[GTK_NUM_FONT_PROPERTIES];
  
  GdkFont *font;
  gint font_index;
  gint style;
  GtkFontMetricType metric;
  /* The size is either in pixels or deci-points, depending on the metric. */
  gint size;
  
  /* This is the last size explicitly selected. When the user selects different
     fonts we try to find the nearest size to this. */
  gint selected_size;
  
  /* These are the current property settings. They are indexes into the
     strings in the GtkFontSelInfo properties array. */
  guint16 property_values[GTK_NUM_STYLE_PROPERTIES];
  
  /* These are the base and user font filters. */
  GtkFontFilter filters[GTK_NUM_FONT_FILTERS];
};
</STRUCT>
<STRUCT>
<NAME>GtkFontSelectionDialog</NAME>
struct GtkFontSelectionDialog
{
  GtkWindow window;
  
  GtkWidget *fontsel;
  
  GtkWidget *main_vbox;
  GtkWidget *action_area;
  GtkWidget *ok_button;
  /* The 'Apply' button is not shown by default but you can show/hide it. */
  GtkWidget *apply_button;
  GtkWidget *cancel_button;
  
  /* If the user changes the width of the dialog, we turn auto-shrink off. */
  gint dialog_width;
  gboolean auto_resize;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_font_selection_get_type</NAME>
<RETURNS>GtkType 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_font_selection_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_font_selection_get_font_name</NAME>
<RETURNS>gchar *</RETURNS>
GtkFontSelection *fontsel
</FUNCTION>
<FUNCTION>
<NAME>gtk_font_selection_get_font</NAME>
<RETURNS>GdkFont *</RETURNS>
GtkFontSelection *fontsel
</FUNCTION>
<FUNCTION>
<NAME>gtk_font_selection_set_font_name</NAME>
<RETURNS>gboolean  </RETURNS>
GtkFontSelection *fontsel,const gchar	  *fontname
</FUNCTION>
<FUNCTION>
<NAME>gtk_font_selection_set_filter</NAME>
<RETURNS>void 	</RETURNS>
GtkFontSelection *fontsel,GtkFontFilterType filter_type,GtkFontType	   font_type,gchar		 **foundries,gchar		 **weights,gchar		 **slants,gchar		 **setwidths,gchar		 **spacings,gchar		 **charsets
</FUNCTION>
<FUNCTION>
<NAME>gtk_font_selection_get_preview_text</NAME>
<RETURNS>gchar *</RETURNS>
GtkFontSelection *fontsel
</FUNCTION>
<FUNCTION>
<NAME>gtk_font_selection_set_preview_text</NAME>
<RETURNS>void 	</RETURNS>
GtkFontSelection *fontsel,const gchar	  *text
</FUNCTION>
<FUNCTION>
<NAME>gtk_font_selection_dialog_get_type</NAME>
<RETURNS>GtkType 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_font_selection_dialog_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
const gchar	  *title
</FUNCTION>
<FUNCTION>
<NAME>gtk_font_selection_dialog_get_font_name</NAME>
<RETURNS>gchar *</RETURNS>
GtkFontSelectionDialog *fsd
</FUNCTION>
<FUNCTION>
<NAME>gtk_font_selection_dialog_get_font</NAME>
<RETURNS>GdkFont *</RETURNS>
GtkFontSelectionDialog *fsd
</FUNCTION>
<FUNCTION>
<NAME>gtk_font_selection_dialog_set_font_name</NAME>
<RETURNS>gboolean  </RETURNS>
GtkFontSelectionDialog *fsd,const gchar	*fontname
</FUNCTION>
<FUNCTION>
<NAME>gtk_font_selection_dialog_set_filter</NAME>
<RETURNS>void 	</RETURNS>
GtkFontSelectionDialog *fsd,GtkFontFilterType filter_type,GtkFontType	   font_type,gchar		 **foundries,gchar		 **weights,gchar		 **slants,gchar		 **setwidths,gchar		 **spacings,gchar		 **charsets
</FUNCTION>
<FUNCTION>
<NAME>gtk_font_selection_dialog_get_preview_text</NAME>
<RETURNS>gchar *</RETURNS>
GtkFontSelectionDialog *fsd
</FUNCTION>
<FUNCTION>
<NAME>gtk_font_selection_dialog_set_preview_text</NAME>
<RETURNS>void 	</RETURNS>
GtkFontSelectionDialog *fsd,const gchar	    *text
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_FRAME</NAME>
#define GTK_TYPE_FRAME                  (gtk_frame_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_FRAME</NAME>
#define GTK_FRAME(obj)                  (GTK_CHECK_CAST ((obj), GTK_TYPE_FRAME, GtkFrame))
</MACRO>
<MACRO>
<NAME>GTK_FRAME_CLASS</NAME>
#define GTK_FRAME_CLASS(klass)          (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_FRAME, GtkFrameClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_FRAME</NAME>
#define GTK_IS_FRAME(obj)               (GTK_CHECK_TYPE ((obj), GTK_TYPE_FRAME))
</MACRO>
<MACRO>
<NAME>GTK_IS_FRAME_CLASS</NAME>
#define GTK_IS_FRAME_CLASS(klass)       (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_FRAME))
</MACRO>
<STRUCT>
<NAME>GtkFrame</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkFrameClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkFrame</NAME>
struct GtkFrame
{
  GtkBin bin;
  
  gchar *label;
  gint16 shadow_type;
  gint16 label_width;
  gint16 label_height;
  gfloat label_xalign;
  gfloat label_yalign;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_frame_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_frame_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
const gchar   *label
</FUNCTION>
<FUNCTION>
<NAME>gtk_frame_set_label</NAME>
<RETURNS>void  </RETURNS>
GtkFrame      *frame,const gchar   *label
</FUNCTION>
<FUNCTION>
<NAME>gtk_frame_set_label_align</NAME>
<RETURNS>void  </RETURNS>
GtkFrame      *frame,gfloat         xalign,gfloat         yalign
</FUNCTION>
<FUNCTION>
<NAME>gtk_frame_set_shadow_type</NAME>
<RETURNS>void  </RETURNS>
GtkFrame      *frame,GtkShadowType  type
</FUNCTION>
<MACRO>
<NAME>GTK_GAMMA_CURVE</NAME>
#define GTK_GAMMA_CURVE(obj) \
   GTK_CHECK_CAST (obj, gtk_gamma_curve_get_type (), GtkGammaCurve)
</MACRO>
<MACRO>
<NAME>GTK_GAMMA_CURVE_CLASS</NAME>
#define GTK_GAMMA_CURVE_CLASS(klass) \
   GTK_CHECK_CLASS_CAST (klass, gtk_gamma_curve_get_type, GtkGammaCurveClass)
</MACRO>
<MACRO>
<NAME>GTK_IS_GAMMA_CURVE</NAME>
#define GTK_IS_GAMMA_CURVE(obj) \
   GTK_CHECK_TYPE (obj, gtk_gamma_curve_get_type ())
</MACRO>
<STRUCT>
<NAME>GtkGammaCurve</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkGammaCurveClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkGammaCurve</NAME>
struct GtkGammaCurve
{
  GtkVBox vbox;

  GtkWidget *table;
  GtkWidget *curve;
  GtkWidget *button[5];	/* spline, linear, free, gamma, reset */

  gfloat gamma;
  GtkWidget *gamma_dialog;
  GtkWidget *gamma_text;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_gamma_curve_get_type</NAME>
<RETURNS>guint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_gamma_curve_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_gc_get</NAME>
<RETURNS>GdkGC *</RETURNS>
gint             depth,GdkColormap     *colormap,GdkGCValues     *values,GdkGCValuesMask  values_mask
</FUNCTION>
<FUNCTION>
<NAME>gtk_gc_release</NAME>
<RETURNS>void  </RETURNS>
GdkGC           *gc
</FUNCTION>
<MACRO>
<NAME>GTK_HANDLE_BOX</NAME>
#define GTK_HANDLE_BOX(obj)          GTK_CHECK_CAST (obj, gtk_handle_box_get_type (), GtkHandleBox)
</MACRO>
<MACRO>
<NAME>GTK_HANDLE_BOX_CLASS</NAME>
#define GTK_HANDLE_BOX_CLASS(klass)  GTK_CHECK_CLASS_CAST (klass, gtk_handle_box_get_type (), GtkHandleBoxClass)
</MACRO>
<MACRO>
<NAME>GTK_IS_HANDLE_BOX</NAME>
#define GTK_IS_HANDLE_BOX(obj)       GTK_CHECK_TYPE (obj, gtk_handle_box_get_type ())
</MACRO>
<STRUCT>
<NAME>GtkHandleBox</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkHandleBoxClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkHandleBox</NAME>
struct GtkHandleBox
{
  GtkBin bin;

  GdkWindow      *bin_window;	/* parent window for children */
  GdkWindow      *float_window;
  GtkShadowType   shadow_type;
  guint		  handle_position : 2;
  guint		  float_window_mapped : 1;
  guint		  child_detached : 1;
  guint		  in_drag : 1;
  guint		  shrink_on_detach : 1;

  gint            snap_edge : 3; /* -1 == unset */
  
  /* Variables used during a drag
   */
  gint deskoff_x, deskoff_y; /* Offset between root relative coordinates
			      * and deskrelative coordinates */
  GtkAllocation   attach_allocation;
  GtkAllocation   float_allocation;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_handle_box_get_type</NAME>
<RETURNS>guint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_handle_box_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_handle_box_set_shadow_type</NAME>
<RETURNS>void  </RETURNS>
GtkHandleBox    *handle_box,GtkShadowType    type
</FUNCTION>
<FUNCTION>
<NAME>gtk_handle_box_set_handle_position</NAME>
<RETURNS>void  </RETURNS>
GtkHandleBox    *handle_box,GtkPositionType  position
</FUNCTION>
<FUNCTION>
<NAME>gtk_handle_box_set_snap_edge</NAME>
<RETURNS>void  </RETURNS>
GtkHandleBox    *handle_box,GtkPositionType  edge
</FUNCTION>
<MACRO>
<NAME>GTK_HBUTTON_BOX</NAME>
#define GTK_HBUTTON_BOX(obj)          GTK_CHECK_CAST (obj, gtk_hbutton_box_get_type (), GtkHButtonBox)
</MACRO>
<MACRO>
<NAME>GTK_HBUTTON_BOX_CLASS</NAME>
#define GTK_HBUTTON_BOX_CLASS(klass)  GTK_CHECK_CLASS_CAST (klass, gtk_hbutton_box_get_type (), GtkHButtonBoxClass)
</MACRO>
<MACRO>
<NAME>GTK_IS_HBUTTON_BOX</NAME>
#define GTK_IS_HBUTTON_BOX(obj)       GTK_CHECK_TYPE (obj, gtk_hbutton_box_get_type ())
</MACRO>
<STRUCT>
<NAME>GtkHButtonBox</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkHButtonBoxClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkHButtonBox</NAME>
struct GtkHButtonBox
{
  GtkButtonBox button_box;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_hbutton_box_get_type</NAME>
<RETURNS>guint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_hbutton_box_new</NAME>
<RETURNS>GtkWidget  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_hbutton_box_get_spacing_default</NAME>
<RETURNS>gint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_hbutton_box_get_layout_default</NAME>
<RETURNS>GtkButtonBoxStyle  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_hbutton_box_set_spacing_default</NAME>
<RETURNS>void  </RETURNS>
gint spacing
</FUNCTION>
<FUNCTION>
<NAME>gtk_hbutton_box_set_layout_default</NAME>
<RETURNS>void  </RETURNS>
GtkButtonBoxStyle layout
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_HBOX</NAME>
#define GTK_TYPE_HBOX		 (gtk_hbox_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_HBOX</NAME>
#define GTK_HBOX(obj)		 (GTK_CHECK_CAST ((obj), GTK_TYPE_HBOX, GtkHBox))
</MACRO>
<MACRO>
<NAME>GTK_HBOX_CLASS</NAME>
#define GTK_HBOX_CLASS(klass)	 (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_HBOX, GtkHBoxClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_HBOX</NAME>
#define GTK_IS_HBOX(obj)	 (GTK_CHECK_TYPE ((obj), GTK_TYPE_HBOX))
</MACRO>
<MACRO>
<NAME>GTK_IS_HBOX_CLASS</NAME>
#define GTK_IS_HBOX_CLASS(klass) (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_HBOX))
</MACRO>
<STRUCT>
<NAME>GtkHBox</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkHBoxClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkHBox</NAME>
struct GtkHBox
{
  GtkBox box;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_hbox_get_type</NAME>
<RETURNS>GtkType 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_hbox_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
gboolean homogeneous,gint spacing
</FUNCTION>
<MACRO>
<NAME>GTK_HPANED</NAME>
#define GTK_HPANED(obj)          GTK_CHECK_CAST (obj, gtk_hpaned_get_type (), GtkHPaned)
</MACRO>
<MACRO>
<NAME>GTK_HPANED_CLASS</NAME>
#define GTK_HPANED_CLASS(klass)  GTK_CHECK_CLASS_CAST (klass, gtk_hpaned_get_type (), GtkHPanedClass)
</MACRO>
<MACRO>
<NAME>GTK_IS_HPANED</NAME>
#define GTK_IS_HPANED(obj)       GTK_CHECK_TYPE (obj, gtk_hpaned_get_type ())
</MACRO>
<STRUCT>
<NAME>GtkHPaned</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkHPanedClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkHPaned</NAME>
struct GtkHPaned
{
  GtkPaned paned;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_hpaned_get_type</NAME>
<RETURNS>guint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_hpaned_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GTK_HRULER</NAME>
#define GTK_HRULER(obj)          GTK_CHECK_CAST (obj, gtk_hruler_get_type (), GtkHRuler)
</MACRO>
<MACRO>
<NAME>GTK_HRULER_CLASS</NAME>
#define GTK_HRULER_CLASS(klass)  GTK_CHECK_CLASS_CAST (klass, gtk_hruler_get_type (), GtkHRulerClass)
</MACRO>
<MACRO>
<NAME>GTK_IS_HRULER</NAME>
#define GTK_IS_HRULER(obj)       GTK_CHECK_TYPE (obj, gtk_hruler_get_type ())
</MACRO>
<STRUCT>
<NAME>GtkHRuler</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkHRulerClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkHRuler</NAME>
struct GtkHRuler
{
  GtkRuler ruler;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_hruler_get_type</NAME>
<RETURNS>guint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_hruler_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_HSCALE</NAME>
#define GTK_TYPE_HSCALE            (gtk_hscale_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_HSCALE</NAME>
#define GTK_HSCALE(obj)            (GTK_CHECK_CAST ((obj), GTK_TYPE_HSCALE, GtkHScale))
</MACRO>
<MACRO>
<NAME>GTK_HSCALE_CLASS</NAME>
#define GTK_HSCALE_CLASS(klass)    (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_HSCALE, GtkHScaleClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_HSCALE</NAME>
#define GTK_IS_HSCALE(obj)         (GTK_CHECK_TYPE ((obj), GTK_TYPE_HSCALE))
</MACRO>
<MACRO>
<NAME>GTK_IS_HSCALE_CLASS</NAME>
#define GTK_IS_HSCALE_CLASS(klass) (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_HSCALE))
</MACRO>
<STRUCT>
<NAME>GtkHScale</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkHScaleClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkHScale</NAME>
struct GtkHScale
{
  GtkScale scale;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_hscale_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_hscale_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GtkAdjustment *adjustment
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_HSCROLLBAR</NAME>
#define GTK_TYPE_HSCROLLBAR            (gtk_hscrollbar_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_HSCROLLBAR</NAME>
#define GTK_HSCROLLBAR(obj)            (GTK_CHECK_CAST ((obj), GTK_TYPE_HSCROLLBAR, GtkHScrollbar))
</MACRO>
<MACRO>
<NAME>GTK_HSCROLLBAR_CLASS</NAME>
#define GTK_HSCROLLBAR_CLASS(klass)    (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_HSCROLLBAR, GtkHScrollbarClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_HSCROLLBAR</NAME>
#define GTK_IS_HSCROLLBAR(obj)         (GTK_CHECK_TYPE ((obj), GTK_TYPE_HSCROLLBAR))
</MACRO>
<MACRO>
<NAME>GTK_IS_HSCROLLBAR_CLASS</NAME>
#define GTK_IS_HSCROLLBAR_CLASS(klass) (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_HSCROLLBAR))
</MACRO>
<STRUCT>
<NAME>GtkHScrollbar</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkHScrollbarClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkHScrollbar</NAME>
struct GtkHScrollbar
{
  GtkScrollbar scrollbar;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_hscrollbar_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_hscrollbar_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GtkAdjustment *adjustment
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_HSEPARATOR</NAME>
#define GTK_TYPE_HSEPARATOR                  (gtk_hseparator_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_HSEPARATOR</NAME>
#define GTK_HSEPARATOR(obj)                  (GTK_CHECK_CAST ((obj), GTK_TYPE_HSEPARATOR, GtkHSeparator))
</MACRO>
<MACRO>
<NAME>GTK_HSEPARATOR_CLASS</NAME>
#define GTK_HSEPARATOR_CLASS(klass)          (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_HSEPARATOR, GtkHSeparatorClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_HSEPARATOR</NAME>
#define GTK_IS_HSEPARATOR(obj)               (GTK_CHECK_TYPE ((obj), GTK_TYPE_HSEPARATOR))
</MACRO>
<MACRO>
<NAME>GTK_IS_HSEPARATOR_CLASS</NAME>
#define GTK_IS_HSEPARATOR_CLASS(klass)       (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_HSEPARATOR))
</MACRO>
<STRUCT>
<NAME>GtkHSeparator</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkHSeparatorClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkHSeparator</NAME>
struct GtkHSeparator
{
  GtkSeparator separator;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_hseparator_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_hseparator_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_IMAGE</NAME>
#define GTK_TYPE_IMAGE                  (gtk_image_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_IMAGE</NAME>
#define GTK_IMAGE(obj)                  (GTK_CHECK_CAST ((obj), GTK_TYPE_IMAGE, GtkImage))
</MACRO>
<MACRO>
<NAME>GTK_IMAGE_CLASS</NAME>
#define GTK_IMAGE_CLASS(klass)          (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_IMAGE, GtkImageClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_IMAGE</NAME>
#define GTK_IS_IMAGE(obj)               (GTK_CHECK_TYPE ((obj), GTK_TYPE_IMAGE))
</MACRO>
<MACRO>
<NAME>GTK_IS_IMAGE_CLASS</NAME>
#define GTK_IS_IMAGE_CLASS(klass)       (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_IMAGE))
</MACRO>
<STRUCT>
<NAME>GtkImage</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkImageClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkImage</NAME>
struct GtkImage
{
  GtkMisc misc;

  GdkImage *image;
  GdkBitmap *mask;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_image_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_image_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GdkImage   *val,GdkBitmap  *mask
</FUNCTION>
<FUNCTION>
<NAME>gtk_image_set</NAME>
<RETURNS>void  </RETURNS>
GtkImage   *image,GdkImage   *val,GdkBitmap  *mask
</FUNCTION>
<FUNCTION>
<NAME>gtk_image_get</NAME>
<RETURNS>void  </RETURNS>
GtkImage   *image,GdkImage  **val,GdkBitmap **mask
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_INPUT_DIALOG</NAME>
#define GTK_TYPE_INPUT_DIALOG              (gtk_input_dialog_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_INPUT_DIALOG</NAME>
#define GTK_INPUT_DIALOG(obj)              (GTK_CHECK_CAST ((obj), GTK_TYPE_INPUT_DIALOG, GtkInputDialog))
</MACRO>
<MACRO>
<NAME>GTK_INPUT_DIALOG_CLASS</NAME>
#define GTK_INPUT_DIALOG_CLASS(klass)      (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_INPUT_DIALOG, GtkInputDialogClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_INPUT_DIALOG</NAME>
#define GTK_IS_INPUT_DIALOG(obj)           (GTK_CHECK_TYPE ((obj), GTK_TYPE_INPUT_DIALOG))
</MACRO>
<MACRO>
<NAME>GTK_IS_INPUT_DIALOG_CLASS</NAME>
#define GTK_IS_INPUT_DIALOG_CLASS(klass)   (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_INPUT_DIALOG))
</MACRO>
<STRUCT>
<NAME>GtkInputDialog</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkInputDialogClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkInputDialog</NAME>
struct GtkInputDialog
{
  GtkDialog dialog;

  GtkWidget *axis_list;
  GtkWidget *axis_listbox;
  GtkWidget *mode_optionmenu;

  GtkWidget *close_button;
  GtkWidget *save_button;
  
  GtkWidget *axis_items[GDK_AXIS_LAST];
  guint32    current_device;

  GtkWidget *keys_list;
  GtkWidget *keys_listbox;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_input_dialog_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_input_dialog_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_INVISIBLE</NAME>
#define GTK_TYPE_INVISIBLE		(gtk_invisible_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_INVISIBLE</NAME>
#define GTK_INVISIBLE(obj)		(GTK_CHECK_CAST ((obj), GTK_TYPE_INVISIBLE, GtkInvisible))
</MACRO>
<MACRO>
<NAME>GTK_INVISIBLE_CLASS</NAME>
#define GTK_INVISIBLE_CLASS(klass)	(GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_INVISIBLE, GtkInvisibleClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_INVISIBLE</NAME>
#define GTK_IS_INVISIBLE(obj)		(GTK_CHECK_TYPE ((obj), GTK_TYPE_INVISIBLE))
</MACRO>
<MACRO>
<NAME>GTK_IS_INVISIBLE_CLASS</NAME>
#define GTK_IS_INVISIBLE_CLASS(klass)	(GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_INVISIBLE))
</MACRO>
<STRUCT>
<NAME>GtkInvisible</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkInvisibleClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkInvisible</NAME>
struct GtkInvisible
{
  GtkBin bin;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_invisible_get_type</NAME>
<RETURNS>GtkType 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_invisible_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_ITEM</NAME>
#define GTK_TYPE_ITEM                  (gtk_item_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_ITEM</NAME>
#define GTK_ITEM(obj)                  (GTK_CHECK_CAST ((obj), GTK_TYPE_ITEM, GtkItem))
</MACRO>
<MACRO>
<NAME>GTK_ITEM_CLASS</NAME>
#define GTK_ITEM_CLASS(klass)          (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_ITEM, GtkItemClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_ITEM</NAME>
#define GTK_IS_ITEM(obj)               (GTK_CHECK_TYPE ((obj), GTK_TYPE_ITEM))
</MACRO>
<MACRO>
<NAME>GTK_IS_ITEM_CLASS</NAME>
#define GTK_IS_ITEM_CLASS(klass)       (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_ITEM))
</MACRO>
<STRUCT>
<NAME>GtkItem</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkItemClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkItem</NAME>
struct GtkItem
{
  GtkBin bin;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_item_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_item_select</NAME>
<RETURNS>void  </RETURNS>
GtkItem *item
</FUNCTION>
<FUNCTION>
<NAME>gtk_item_deselect</NAME>
<RETURNS>void  </RETURNS>
GtkItem *item
</FUNCTION>
<FUNCTION>
<NAME>gtk_item_toggle</NAME>
<RETURNS>void  </RETURNS>
GtkItem *item
</FUNCTION>
<USER_FUNCTION>
<NAME>GtkPrintFunc</NAME>
<RETURNS>void </RETURNS>
gpointer		 func_data,
					    gchar		*str
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GtkTranslateFunc</NAME>
<RETURNS>gchar *</RETURNS>
const gchar		*path,
					    gpointer             func_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GtkItemFactoryCallback</NAME>
<RETURNS>void </RETURNS>

</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GtkItemFactoryCallback1</NAME>
<RETURNS>void </RETURNS>
gpointer		 callback_data,
					    guint		 callback_action,
					    GtkWidget		*widget
</USER_FUNCTION>
<MACRO>
<NAME>GTK_TYPE_ITEM_FACTORY</NAME>
#define	GTK_TYPE_ITEM_FACTORY		 (gtk_item_factory_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_ITEM_FACTORY</NAME>
#define	GTK_ITEM_FACTORY(object)	 (GTK_CHECK_CAST (object, GTK_TYPE_ITEM_FACTORY, GtkItemFactory))
</MACRO>
<MACRO>
<NAME>GTK_ITEM_FACTORY_CLASS</NAME>
#define	GTK_ITEM_FACTORY_CLASS(klass)	 (GTK_CHECK_CLASS_CAST (klass, GTK_TYPE_ITEM_FACTORY, GtkItemFactoryClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_ITEM_FACTORY</NAME>
#define	GTK_IS_ITEM_FACTORY(object)	 (GTK_CHECK_TYPE (object, GTK_TYPE_ITEM_FACTORY))
</MACRO>
<MACRO>
<NAME>GTK_IS_ITEM_FACTORY_CLASS</NAME>
#define	GTK_IS_ITEM_FACTORY_CLASS(klass) (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_ITEM_FACTORY))
</MACRO>
<STRUCT>
<NAME>GtkItemFactory</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkItemFactoryClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkItemFactoryEntry</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkItemFactoryItem</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkItemFactory</NAME>
struct GtkItemFactory
{
  GtkObject		 object;

  gchar			*path;
  GtkAccelGroup		*accel_group;
  GtkWidget		*widget;
  GSList		*items;

  GtkTranslateFunc       translate_func;
  gpointer               translate_data;
  GtkDestroyNotify       translate_notify;   
};
</STRUCT>
<STRUCT>
<NAME>GtkItemFactoryEntry</NAME>
struct GtkItemFactoryEntry
{
  gchar *path;
  gchar *accelerator;

  GtkItemFactoryCallback callback;
  guint			 callback_action;

  /* possible values:
   * NULL		-> "<Item>"
   * ""			-> "<Item>"
   * "<Title>"		-> create a title item
   * "<Item>"		-> create a simple item
   * "<CheckItem>"	-> create a check item
   * "<ToggleItem>"	-> create a toggle item
   * "<RadioItem>"	-> create a radio item
   * <path>		-> path of a radio item to link against
   * "<Separator>"	-> create a separator
   * "<Branch>"		-> create an item to hold sub items
   * "<LastBranch>"	-> create a right justified item to hold sub items
   */
  gchar		 *item_type;
};
</STRUCT>
<STRUCT>
<NAME>GtkItemFactoryItem</NAME>
struct GtkItemFactoryItem
{
  gchar *path;
  guint  accelerator_key;
  guint  accelerator_mods;
  guint	 modified : 1;
  guint  in_propagation : 1;
  gchar *dummy;

  GSList *widgets;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_item_factory_get_type</NAME>
<RETURNS>GtkType 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_item_factory_new</NAME>
<RETURNS>GtkItemFactory *</RETURNS>
GtkType		 container_type,const gchar		*path,GtkAccelGroup       *accel_group
</FUNCTION>
<FUNCTION>
<NAME>gtk_item_factory_construct</NAME>
<RETURNS>void 	</RETURNS>
GtkItemFactory	*ifactory,GtkType		 container_type,const gchar		*path,GtkAccelGroup       *accel_group
</FUNCTION>
<FUNCTION>
<NAME>gtk_item_factory_parse_rc</NAME>
<RETURNS>void 	</RETURNS>
const gchar    *file_name
</FUNCTION>
<FUNCTION>
<NAME>gtk_item_factory_parse_rc_string</NAME>
<RETURNS>void 	</RETURNS>
const gchar    *rc_string
</FUNCTION>
<FUNCTION>
<NAME>gtk_item_factory_parse_rc_scanner</NAME>
<RETURNS>void 	</RETURNS>
GScanner	    *scanner
</FUNCTION>
<FUNCTION>
<NAME>gtk_item_factory_add_foreign</NAME>
<RETURNS>void 	</RETURNS>
GtkWidget	    *accel_widget,const gchar    *full_path,GtkAccelGroup  *accel_group,guint	     keyval,GdkModifierType modifiers
</FUNCTION>
<FUNCTION>
<NAME>gtk_item_factory_from_widget</NAME>
<RETURNS>GtkItemFactory *</RETURNS>
GtkWidget	      *widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_item_factory_path_from_widget</NAME>
<RETURNS>gchar *</RETURNS>
GtkWidget	      *widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_item_factory_get_item</NAME>
<RETURNS>GtkWidget *</RETURNS>
GtkItemFactory *ifactory,const gchar    *path
</FUNCTION>
<FUNCTION>
<NAME>gtk_item_factory_get_widget</NAME>
<RETURNS>GtkWidget *</RETURNS>
GtkItemFactory *ifactory,const gchar    *path
</FUNCTION>
<FUNCTION>
<NAME>gtk_item_factory_get_widget_by_action</NAME>
<RETURNS>GtkWidget *</RETURNS>
GtkItemFactory *ifactory,guint	       action
</FUNCTION>
<FUNCTION>
<NAME>gtk_item_factory_get_item_by_action</NAME>
<RETURNS>GtkWidget *</RETURNS>
GtkItemFactory *ifactory,guint	       action
</FUNCTION>
<FUNCTION>
<NAME>gtk_item_factory_dump_items</NAME>
<RETURNS>void 	</RETURNS>
GtkPatternSpec		*path_pspec,gboolean		 modified_only,GtkPrintFunc		 print_func,gpointer		 func_data
</FUNCTION>
<FUNCTION>
<NAME>gtk_item_factory_dump_rc</NAME>
<RETURNS>void 	</RETURNS>
const gchar		*file_name,GtkPatternSpec		*path_pspec,gboolean		 modified_only
</FUNCTION>
<FUNCTION>
<NAME>gtk_item_factory_print_func</NAME>
<RETURNS>void 	</RETURNS>
gpointer		 FILE_pointer,gchar			*string
</FUNCTION>
<FUNCTION>
<NAME>gtk_item_factory_create_item</NAME>
<RETURNS>void 	</RETURNS>
GtkItemFactory		*ifactory,GtkItemFactoryEntry	*entry,gpointer		 callback_data,guint			 callback_type
</FUNCTION>
<FUNCTION>
<NAME>gtk_item_factory_create_items</NAME>
<RETURNS>void 	</RETURNS>
GtkItemFactory		*ifactory,guint			 n_entries,GtkItemFactoryEntry	*entries,gpointer		 callback_data
</FUNCTION>
<FUNCTION>
<NAME>gtk_item_factory_delete_item</NAME>
<RETURNS>void 	</RETURNS>
GtkItemFactory		*ifactory,const gchar		*path
</FUNCTION>
<FUNCTION>
<NAME>gtk_item_factory_delete_entry</NAME>
<RETURNS>void 	</RETURNS>
GtkItemFactory		*ifactory,GtkItemFactoryEntry	*entry
</FUNCTION>
<FUNCTION>
<NAME>gtk_item_factory_delete_entries</NAME>
<RETURNS>void 	</RETURNS>
GtkItemFactory		*ifactory,guint			 n_entries,GtkItemFactoryEntry	*entries
</FUNCTION>
<FUNCTION>
<NAME>gtk_item_factory_popup</NAME>
<RETURNS>void 	</RETURNS>
GtkItemFactory		*ifactory,guint			 x,guint			 y,guint			 mouse_button,guint32		 time
</FUNCTION>
<FUNCTION>
<NAME>gtk_item_factory_popup_with_data</NAME>
<RETURNS>void 	</RETURNS>
GtkItemFactory		*ifactory,gpointer		 popup_data,GtkDestroyNotify	 destroy,guint			 x,guint			 y,guint			 mouse_button,guint32		 time
</FUNCTION>
<FUNCTION>
<NAME>gtk_item_factory_popup_data</NAME>
<RETURNS>gpointer  </RETURNS>
GtkItemFactory		*ifactory
</FUNCTION>
<FUNCTION>
<NAME>gtk_item_factory_popup_data_from_widget</NAME>
<RETURNS>gpointer  </RETURNS>
GtkWidget	*widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_item_factory_set_translate_func</NAME>
<RETURNS>void  </RETURNS>
GtkItemFactory      *ifactory,GtkTranslateFunc     func,gpointer             data,GtkDestroyNotify     notify
</FUNCTION>
<FUNCTION>
<NAME>gtk_item_factory_from_path</NAME>
<RETURNS>GtkItemFactory *</RETURNS>
const gchar       *path
</FUNCTION>
<FUNCTION>
<NAME>gtk_item_factory_create_menu_entries</NAME>
<RETURNS>void 	</RETURNS>
guint		 n_entries,GtkMenuEntry      *entries
</FUNCTION>
<FUNCTION>
<NAME>gtk_item_factories_path_delete</NAME>
<RETURNS>void 	</RETURNS>
const gchar		*ifactory_path,const gchar		*path
</FUNCTION>
<USER_FUNCTION>
<NAME>GtkItemFactoryCallback2</NAME>
<RETURNS>void </RETURNS>
GtkWidget		*widget,
					    gpointer		 callback_data,
					    guint		 callback_action
</USER_FUNCTION>
<FUNCTION>
<NAME>gtk_item_factory_create_items_ac</NAME>
<RETURNS>void 	</RETURNS>
GtkItemFactory	*ifactory,guint			 n_entries,GtkItemFactoryEntry	*entries,gpointer		 callback_data,guint			 callback_type
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_LABEL</NAME>
#define GTK_TYPE_LABEL			(gtk_label_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_LABEL</NAME>
#define GTK_LABEL(obj)			(GTK_CHECK_CAST ((obj), GTK_TYPE_LABEL, GtkLabel))
</MACRO>
<MACRO>
<NAME>GTK_LABEL_CLASS</NAME>
#define GTK_LABEL_CLASS(klass)		(GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_LABEL, GtkLabelClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_LABEL</NAME>
#define GTK_IS_LABEL(obj)		(GTK_CHECK_TYPE ((obj), GTK_TYPE_LABEL))
</MACRO>
<MACRO>
<NAME>GTK_IS_LABEL_CLASS</NAME>
#define GTK_IS_LABEL_CLASS(klass)	(GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_LABEL))
</MACRO>
<STRUCT>
<NAME>GtkLabel</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkLabelClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkLabelWord</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkLabel</NAME>
struct GtkLabel
{
  GtkMisc misc;

  gchar    *label;
  GdkWChar *label_wc;
  gchar    *pattern;

  GtkLabelWord *words;

  guint	  max_width : 16;
  guint   jtype : 2;
  gboolean wrap;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_label_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_label_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
const gchar       *str
</FUNCTION>
<FUNCTION>
<NAME>gtk_label_set_text</NAME>
<RETURNS>void  </RETURNS>
GtkLabel          *label,const gchar       *str
</FUNCTION>
<FUNCTION>
<NAME>gtk_label_set_justify</NAME>
<RETURNS>void  </RETURNS>
GtkLabel          *label,GtkJustification   jtype
</FUNCTION>
<FUNCTION>
<NAME>gtk_label_set_pattern</NAME>
<RETURNS>void 	</RETURNS>
GtkLabel	      *label,const gchar	      *pattern
</FUNCTION>
<FUNCTION>
<NAME>gtk_label_set_line_wrap</NAME>
<RETURNS>void 	</RETURNS>
GtkLabel	      *label,gboolean           wrap
</FUNCTION>
<FUNCTION>
<NAME>gtk_label_get</NAME>
<RETURNS>void  </RETURNS>
GtkLabel          *label,gchar            **str
</FUNCTION>
<FUNCTION>
<NAME>gtk_label_parse_uline</NAME>
<RETURNS>guint  </RETURNS>
GtkLabel         *label,const gchar      *string
</FUNCTION>
<MACRO>
<NAME>gtk_label_set</NAME>
#  define gtk_label_set				gtk_label_set_text
</MACRO>
<MACRO>
<NAME>GTK_TYPE_LAYOUT</NAME>
#define GTK_TYPE_LAYOUT            (gtk_layout_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_LAYOUT</NAME>
#define GTK_LAYOUT(obj)            (GTK_CHECK_CAST ((obj), GTK_TYPE_LAYOUT, GtkLayout))
</MACRO>
<MACRO>
<NAME>GTK_LAYOUT_CLASS</NAME>
#define GTK_LAYOUT_CLASS(klass)    (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_LAYOUT, GtkLayoutClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_LAYOUT</NAME>
#define GTK_IS_LAYOUT(obj)         (GTK_CHECK_TYPE ((obj), GTK_TYPE_LAYOUT))
</MACRO>
<MACRO>
<NAME>GTK_IS_LAYOUT_CLASS</NAME>
#define GTK_IS_LAYOUT_CLASS(klass) (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_LAYOUT))
</MACRO>
<STRUCT>
<NAME>GtkLayout</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkLayoutClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkLayout</NAME>
struct GtkLayout {
  GtkContainer container;

  GList *children;

  guint width;
  guint height;

  guint xoffset;
  guint yoffset;

  GtkAdjustment *hadjustment;
  GtkAdjustment *vadjustment;
  
  GdkWindow *bin_window;

  GdkVisibilityState visibility;
  gulong configure_serial;
  gint scroll_x;
  gint scroll_y;

  guint freeze_count;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_layout_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_layout_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GtkAdjustment *hadjustment,GtkAdjustment *vadjustment
</FUNCTION>
<FUNCTION>
<NAME>gtk_layout_put</NAME>
<RETURNS>void  </RETURNS>
GtkLayout     *layout,GtkWidget     *widget,gint           x,gint           y
</FUNCTION>
<FUNCTION>
<NAME>gtk_layout_move</NAME>
<RETURNS>void  </RETURNS>
GtkLayout     *layout,GtkWidget     *widget,gint           x,gint           y
</FUNCTION>
<FUNCTION>
<NAME>gtk_layout_set_size</NAME>
<RETURNS>void  </RETURNS>
GtkLayout     *layout,guint          width,guint          height
</FUNCTION>
<FUNCTION>
<NAME>gtk_layout_get_hadjustment</NAME>
<RETURNS>GtkAdjustment *</RETURNS>
GtkLayout     *layout
</FUNCTION>
<FUNCTION>
<NAME>gtk_layout_get_vadjustment</NAME>
<RETURNS>GtkAdjustment *</RETURNS>
GtkLayout     *layout
</FUNCTION>
<FUNCTION>
<NAME>gtk_layout_set_hadjustment</NAME>
<RETURNS>void  </RETURNS>
GtkLayout     *layout,GtkAdjustment *adjustment
</FUNCTION>
<FUNCTION>
<NAME>gtk_layout_set_vadjustment</NAME>
<RETURNS>void  </RETURNS>
GtkLayout     *layout,GtkAdjustment *adjustment
</FUNCTION>
<FUNCTION>
<NAME>gtk_layout_freeze</NAME>
<RETURNS>void  </RETURNS>
GtkLayout     *layout
</FUNCTION>
<FUNCTION>
<NAME>gtk_layout_thaw</NAME>
<RETURNS>void  </RETURNS>
GtkLayout     *layout
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_LIST</NAME>
#define GTK_TYPE_LIST                  (gtk_list_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_LIST</NAME>
#define GTK_LIST(obj)                  (GTK_CHECK_CAST ((obj), GTK_TYPE_LIST, GtkList))
</MACRO>
<MACRO>
<NAME>GTK_LIST_CLASS</NAME>
#define GTK_LIST_CLASS(klass)          (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_LIST, GtkListClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_LIST</NAME>
#define GTK_IS_LIST(obj)               (GTK_CHECK_TYPE ((obj), GTK_TYPE_LIST))
</MACRO>
<MACRO>
<NAME>GTK_IS_LIST_CLASS</NAME>
#define GTK_IS_LIST_CLASS(klass)       (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_LIST))
</MACRO>
<STRUCT>
<NAME>GtkList</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkListClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkList</NAME>
struct GtkList
{
  GtkContainer container;

  GList *children;
  GList *selection;

  GList *undo_selection;
  GList *undo_unselection;

  GtkWidget *last_focus_child;
  GtkWidget *undo_focus_child;

  guint htimer;
  guint vtimer;

  gint anchor;
  gint drag_pos;
  GtkStateType anchor_state;

  guint selection_mode : 2;
  guint drag_selection:1;
  guint add_mode:1;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_list_get_type</NAME>
<RETURNS>GtkType 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_list_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_list_insert_items</NAME>
<RETURNS>void 	</RETURNS>
GtkList	    *list,GList	    *items,gint		     position
</FUNCTION>
<FUNCTION>
<NAME>gtk_list_append_items</NAME>
<RETURNS>void 	</RETURNS>
GtkList	    *list,GList	    *items
</FUNCTION>
<FUNCTION>
<NAME>gtk_list_prepend_items</NAME>
<RETURNS>void 	</RETURNS>
GtkList	    *list,GList	    *items
</FUNCTION>
<FUNCTION>
<NAME>gtk_list_remove_items</NAME>
<RETURNS>void 	</RETURNS>
GtkList	    *list,GList	    *items
</FUNCTION>
<FUNCTION>
<NAME>gtk_list_remove_items_no_unref</NAME>
<RETURNS>void 	</RETURNS>
GtkList	    *list,GList	    *items
</FUNCTION>
<FUNCTION>
<NAME>gtk_list_clear_items</NAME>
<RETURNS>void 	</RETURNS>
GtkList	    *list,gint		     start,gint		     end
</FUNCTION>
<FUNCTION>
<NAME>gtk_list_select_item</NAME>
<RETURNS>void 	</RETURNS>
GtkList	    *list,gint		     item
</FUNCTION>
<FUNCTION>
<NAME>gtk_list_unselect_item</NAME>
<RETURNS>void 	</RETURNS>
GtkList	    *list,gint		     item
</FUNCTION>
<FUNCTION>
<NAME>gtk_list_select_child</NAME>
<RETURNS>void 	</RETURNS>
GtkList	    *list,GtkWidget	    *child
</FUNCTION>
<FUNCTION>
<NAME>gtk_list_unselect_child</NAME>
<RETURNS>void 	</RETURNS>
GtkList	    *list,GtkWidget	    *child
</FUNCTION>
<FUNCTION>
<NAME>gtk_list_child_position</NAME>
<RETURNS>gint 	</RETURNS>
GtkList	    *list,GtkWidget	    *child
</FUNCTION>
<FUNCTION>
<NAME>gtk_list_set_selection_mode</NAME>
<RETURNS>void 	</RETURNS>
GtkList	    *list,GtkSelectionMode  mode
</FUNCTION>
<FUNCTION>
<NAME>gtk_list_extend_selection</NAME>
<RETURNS>void  </RETURNS>
GtkList          *list,GtkScrollType     scroll_type,gfloat            position,gboolean          auto_start_selection
</FUNCTION>
<FUNCTION>
<NAME>gtk_list_start_selection</NAME>
<RETURNS>void  </RETURNS>
GtkList          *list
</FUNCTION>
<FUNCTION>
<NAME>gtk_list_end_selection</NAME>
<RETURNS>void  </RETURNS>
GtkList          *list
</FUNCTION>
<FUNCTION>
<NAME>gtk_list_select_all</NAME>
<RETURNS>void  </RETURNS>
GtkList          *list
</FUNCTION>
<FUNCTION>
<NAME>gtk_list_unselect_all</NAME>
<RETURNS>void  </RETURNS>
GtkList          *list
</FUNCTION>
<FUNCTION>
<NAME>gtk_list_scroll_horizontal</NAME>
<RETURNS>void  </RETURNS>
GtkList          *list,GtkScrollType     scroll_type,gfloat            position
</FUNCTION>
<FUNCTION>
<NAME>gtk_list_scroll_vertical</NAME>
<RETURNS>void  </RETURNS>
GtkList          *list,GtkScrollType     scroll_type,gfloat            position
</FUNCTION>
<FUNCTION>
<NAME>gtk_list_toggle_add_mode</NAME>
<RETURNS>void  </RETURNS>
GtkList          *list
</FUNCTION>
<FUNCTION>
<NAME>gtk_list_toggle_focus_row</NAME>
<RETURNS>void  </RETURNS>
GtkList          *list
</FUNCTION>
<FUNCTION>
<NAME>gtk_list_toggle_row</NAME>
<RETURNS>void  </RETURNS>
GtkList          *list,GtkWidget        *item
</FUNCTION>
<FUNCTION>
<NAME>gtk_list_undo_selection</NAME>
<RETURNS>void  </RETURNS>
GtkList          *list
</FUNCTION>
<FUNCTION>
<NAME>gtk_list_end_drag_selection</NAME>
<RETURNS>void  </RETURNS>
GtkList          *list
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_LIST_ITEM</NAME>
#define GTK_TYPE_LIST_ITEM              (gtk_list_item_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_LIST_ITEM</NAME>
#define GTK_LIST_ITEM(obj)              (GTK_CHECK_CAST ((obj), GTK_TYPE_LIST_ITEM, GtkListItem))
</MACRO>
<MACRO>
<NAME>GTK_LIST_ITEM_CLASS</NAME>
#define GTK_LIST_ITEM_CLASS(klass)      (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_LIST_ITEM, GtkListItemClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_LIST_ITEM</NAME>
#define GTK_IS_LIST_ITEM(obj)           (GTK_CHECK_TYPE ((obj), GTK_TYPE_LIST_ITEM))
</MACRO>
<MACRO>
<NAME>GTK_IS_LIST_ITEM_CLASS</NAME>
#define GTK_IS_LIST_ITEM_CLASS(klass)   (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_LIST_ITEM))
</MACRO>
<STRUCT>
<NAME>GtkListItem</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkListItemClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkListItem</NAME>
struct GtkListItem
{
  GtkItem item;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_list_item_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_list_item_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_list_item_new_with_label</NAME>
<RETURNS>GtkWidget *</RETURNS>
const gchar      *label
</FUNCTION>
<FUNCTION>
<NAME>gtk_list_item_select</NAME>
<RETURNS>void  </RETURNS>
GtkListItem      *list_item
</FUNCTION>
<FUNCTION>
<NAME>gtk_list_item_deselect</NAME>
<RETURNS>void  </RETURNS>
GtkListItem      *list_item
</FUNCTION>
<MACRO>
<NAME>GTK_PRIORITY_REDRAW</NAME>
#define GTK_PRIORITY_REDRAW     (G_PRIORITY_HIGH_IDLE + 20)
</MACRO>
<MACRO>
<NAME>GTK_PRIORITY_RESIZE</NAME>
#define GTK_PRIORITY_RESIZE     (G_PRIORITY_HIGH_IDLE + 10)
</MACRO>
<MACRO>
<NAME>GTK_PRIORITY_HIGH</NAME>
#define GTK_PRIORITY_HIGH       G_PRIORITY_HIGH
</MACRO>
<MACRO>
<NAME>GTK_PRIORITY_INTERNAL</NAME>
#define GTK_PRIORITY_INTERNAL   GTK_PRIORITY_REDRAW
</MACRO>
<MACRO>
<NAME>GTK_PRIORITY_DEFAULT</NAME>
#define GTK_PRIORITY_DEFAULT	G_PRIORITY_DEFAULT_IDLE
</MACRO>
<MACRO>
<NAME>GTK_PRIORITY_LOW</NAME>
#define GTK_PRIORITY_LOW	G_PRIORITY_LOW
</MACRO>
<USER_FUNCTION>
<NAME>GtkModuleInitFunc</NAME>
<RETURNS>void </RETURNS>
gint		*argc,
					 gchar	      ***argv
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GtkKeySnoopFunc</NAME>
<RETURNS>gint </RETURNS>
GtkWidget	*grab_widget,
					 GdkEventKey	*event,
					 gpointer	 func_data
</USER_FUNCTION>
<VARIABLE>
<NAME>gtk_major_version</NAME>
extern const guint gtk_major_version;
</VARIABLE>
<VARIABLE>
<NAME>gtk_minor_version</NAME>
extern const guint gtk_minor_version;
</VARIABLE>
<VARIABLE>
<NAME>gtk_micro_version</NAME>
extern const guint gtk_micro_version;
</VARIABLE>
<VARIABLE>
<NAME>gtk_binary_age</NAME>
extern const guint gtk_binary_age;
</VARIABLE>
<VARIABLE>
<NAME>gtk_interface_age</NAME>
extern const guint gtk_interface_age;
</VARIABLE>
<FUNCTION>
<NAME>gtk_check_version</NAME>
<RETURNS>gchar *</RETURNS>
guint	required_major,guint	required_minor,guint	required_micro
</FUNCTION>
<FUNCTION>
<NAME>gtk_init</NAME>
<RETURNS>void 	</RETURNS>
int	       *argc,char	     ***argv
</FUNCTION>
<FUNCTION>
<NAME>gtk_init_check</NAME>
<RETURNS>gboolean  </RETURNS>
int	       *argc,char	     ***argv
</FUNCTION>
<FUNCTION>
<NAME>gtk_exit</NAME>
<RETURNS>void 	</RETURNS>
gint		error_code
</FUNCTION>
<FUNCTION>
<NAME>gtk_set_locale</NAME>
<RETURNS>gchar *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_events_pending</NAME>
<RETURNS>gint 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_main_do_event</NAME>
<RETURNS>void  </RETURNS>
GdkEvent           *event
</FUNCTION>
<FUNCTION>
<NAME>gtk_main</NAME>
<RETURNS>void 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_main_level</NAME>
<RETURNS>guint 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_main_quit</NAME>
<RETURNS>void 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_main_iteration</NAME>
<RETURNS>gint 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_main_iteration_do</NAME>
<RETURNS>gint 	</RETURNS>
gboolean blocking
</FUNCTION>
<FUNCTION>
<NAME>gtk_true</NAME>
<RETURNS>gint 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_false</NAME>
<RETURNS>gint 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_grab_add</NAME>
<RETURNS>void 	</RETURNS>
GtkWidget	       *widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_grab_get_current</NAME>
<RETURNS>GtkWidget *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_grab_remove</NAME>
<RETURNS>void 	</RETURNS>
GtkWidget	       *widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_init_add</NAME>
<RETURNS>void 	</RETURNS>
GtkFunction	       function,gpointer	       data
</FUNCTION>
<FUNCTION>
<NAME>gtk_quit_add_destroy</NAME>
<RETURNS>void 	</RETURNS>
guint	       main_level,GtkObject	      *object
</FUNCTION>
<FUNCTION>
<NAME>gtk_quit_add</NAME>
<RETURNS>guint 	</RETURNS>
guint	       main_level,GtkFunction	       function,gpointer	       data
</FUNCTION>
<FUNCTION>
<NAME>gtk_quit_add_full</NAME>
<RETURNS>guint 	</RETURNS>
guint	       main_level,GtkFunction	       function,GtkCallbackMarshal marshal,gpointer	       data,GtkDestroyNotify   destroy
</FUNCTION>
<FUNCTION>
<NAME>gtk_quit_remove</NAME>
<RETURNS>void 	</RETURNS>
guint	       quit_handler_id
</FUNCTION>
<FUNCTION>
<NAME>gtk_quit_remove_by_data</NAME>
<RETURNS>void 	</RETURNS>
gpointer	       data
</FUNCTION>
<FUNCTION>
<NAME>gtk_timeout_add</NAME>
<RETURNS>guint 	</RETURNS>
guint32	       interval,GtkFunction	       function,gpointer	       data
</FUNCTION>
<FUNCTION>
<NAME>gtk_timeout_add_full</NAME>
<RETURNS>guint 	</RETURNS>
guint32	       interval,GtkFunction	       function,GtkCallbackMarshal marshal,gpointer	       data,GtkDestroyNotify   destroy
</FUNCTION>
<FUNCTION>
<NAME>gtk_timeout_remove</NAME>
<RETURNS>void 	</RETURNS>
guint	       timeout_handler_id
</FUNCTION>
<FUNCTION>
<NAME>gtk_idle_add</NAME>
<RETURNS>guint 	</RETURNS>
GtkFunction	       function,gpointer	       data
</FUNCTION>
<FUNCTION>
<NAME>gtk_idle_add_priority</NAME>
<RETURNS>guint 	</RETURNS>
gint	       priority,GtkFunction	       function,gpointer	       data
</FUNCTION>
<FUNCTION>
<NAME>gtk_idle_add_full</NAME>
<RETURNS>guint 	</RETURNS>
gint	       priority,GtkFunction	       function,GtkCallbackMarshal marshal,gpointer	       data,GtkDestroyNotify   destroy
</FUNCTION>
<FUNCTION>
<NAME>gtk_idle_remove</NAME>
<RETURNS>void 	</RETURNS>
guint	       idle_handler_id
</FUNCTION>
<FUNCTION>
<NAME>gtk_idle_remove_by_data</NAME>
<RETURNS>void 	</RETURNS>
gpointer	       data
</FUNCTION>
<FUNCTION>
<NAME>gtk_input_add_full</NAME>
<RETURNS>guint 	</RETURNS>
gint	       source,GdkInputCondition  condition,GdkInputFunction   function,GtkCallbackMarshal marshal,gpointer	       data,GtkDestroyNotify   destroy
</FUNCTION>
<FUNCTION>
<NAME>gtk_input_remove</NAME>
<RETURNS>void 	</RETURNS>
guint	       input_handler_id
</FUNCTION>
<FUNCTION>
<NAME>gtk_key_snooper_install</NAME>
<RETURNS>guint 	</RETURNS>
GtkKeySnoopFunc snooper,gpointer	    func_data
</FUNCTION>
<FUNCTION>
<NAME>gtk_key_snooper_remove</NAME>
<RETURNS>void 	</RETURNS>
guint	    snooper_handler_id
</FUNCTION>
<FUNCTION>
<NAME>gtk_get_current_event</NAME>
<RETURNS>GdkEvent *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_get_event_widget</NAME>
<RETURNS>GtkWidget *</RETURNS>
GdkEvent	   *event
</FUNCTION>
<FUNCTION>
<NAME>gtk_propagate_event</NAME>
<RETURNS>void  </RETURNS>
GtkWidget         *widget,GdkEvent          *event
</FUNCTION>
<MACRO>
<NAME>gtk_signal_default_marshaller</NAME>
#define gtk_signal_default_marshaller gtk_marshal_NONE__NONE
</MACRO>
<FUNCTION>
<NAME>gtk_marshal_BOOL__NONE</NAME>
<RETURNS>void  </RETURNS>
GtkObject * object,GtkSignalFunc func,gpointer func_data,GtkArg * args
</FUNCTION>
<FUNCTION>
<NAME>gtk_marshal_BOOL__POINTER</NAME>
<RETURNS>void  </RETURNS>
GtkObject * object,GtkSignalFunc func,gpointer func_data,GtkArg * args
</FUNCTION>
<FUNCTION>
<NAME>gtk_marshal_BOOL__POINTER_POINTER_INT_INT</NAME>
<RETURNS>void  </RETURNS>
GtkObject * object,GtkSignalFunc func,gpointer func_data,GtkArg * args
</FUNCTION>
<FUNCTION>
<NAME>gtk_marshal_BOOL__POINTER_INT_INT</NAME>
<RETURNS>void  </RETURNS>
GtkObject * object,GtkSignalFunc func,gpointer func_data,GtkArg * args
</FUNCTION>
<MACRO>
<NAME>gtk_marshal_BOOL__POINTER_INT_INT_UINT</NAME>
#define gtk_marshal_BOOL__POINTER_INT_INT_UINT gtk_marshal_BOOL__POINTER_INT_INT_INT
</MACRO>
<FUNCTION>
<NAME>gtk_marshal_BOOL__POINTER_INT_INT_INT</NAME>
<RETURNS>void  </RETURNS>
GtkObject * object,GtkSignalFunc func,gpointer func_data,GtkArg * args
</FUNCTION>
<MACRO>
<NAME>gtk_marshal_BOOL__POINTER_STRING_STRING_POINTER</NAME>
#define gtk_marshal_BOOL__POINTER_STRING_STRING_POINTER gtk_marshal_BOOL__POINTER_POINTER_POINTER_POINTER
</MACRO>
<FUNCTION>
<NAME>gtk_marshal_BOOL__POINTER_POINTER_POINTER_POINTER</NAME>
<RETURNS>void  </RETURNS>
GtkObject * object,GtkSignalFunc func,gpointer func_data,GtkArg * args
</FUNCTION>
<MACRO>
<NAME>gtk_marshal_ENUM__ENUM</NAME>
#define gtk_marshal_ENUM__ENUM gtk_marshal_INT__INT
</MACRO>
<FUNCTION>
<NAME>gtk_marshal_INT__INT</NAME>
<RETURNS>void  </RETURNS>
GtkObject * object,GtkSignalFunc func,gpointer func_data,GtkArg * args
</FUNCTION>
<FUNCTION>
<NAME>gtk_marshal_INT__POINTER</NAME>
<RETURNS>void  </RETURNS>
GtkObject * object,GtkSignalFunc func,gpointer func_data,GtkArg * args
</FUNCTION>
<FUNCTION>
<NAME>gtk_marshal_INT__POINTER_CHAR_CHAR</NAME>
<RETURNS>void  </RETURNS>
GtkObject * object,GtkSignalFunc func,gpointer func_data,GtkArg * args
</FUNCTION>
<FUNCTION>
<NAME>gtk_marshal_NONE__BOOL</NAME>
<RETURNS>void  </RETURNS>
GtkObject * object,GtkSignalFunc func,gpointer func_data,GtkArg * args
</FUNCTION>
<MACRO>
<NAME>gtk_marshal_NONE__BOXED</NAME>
#define gtk_marshal_NONE__BOXED gtk_marshal_NONE__POINTER
</MACRO>
<FUNCTION>
<NAME>gtk_marshal_NONE__POINTER</NAME>
<RETURNS>void  </RETURNS>
GtkObject * object,GtkSignalFunc func,gpointer func_data,GtkArg * args
</FUNCTION>
<FUNCTION>
<NAME>gtk_marshal_NONE__C_CALLBACK</NAME>
<RETURNS>void  </RETURNS>
GtkObject * object,GtkSignalFunc func,gpointer func_data,GtkArg * args
</FUNCTION>
<FUNCTION>
<NAME>gtk_marshal_NONE__C_CALLBACK_C_CALLBACK</NAME>
<RETURNS>void  </RETURNS>
GtkObject * object,GtkSignalFunc func,gpointer func_data,GtkArg * args
</FUNCTION>
<MACRO>
<NAME>gtk_marshal_NONE__ENUM</NAME>
#define gtk_marshal_NONE__ENUM gtk_marshal_NONE__INT
</MACRO>
<FUNCTION>
<NAME>gtk_marshal_NONE__INT</NAME>
<RETURNS>void  </RETURNS>
GtkObject * object,GtkSignalFunc func,gpointer func_data,GtkArg * args
</FUNCTION>
<MACRO>
<NAME>gtk_marshal_NONE__ENUM_FLOAT</NAME>
#define gtk_marshal_NONE__ENUM_FLOAT gtk_marshal_NONE__INT_FLOAT
</MACRO>
<FUNCTION>
<NAME>gtk_marshal_NONE__INT_FLOAT</NAME>
<RETURNS>void  </RETURNS>
GtkObject * object,GtkSignalFunc func,gpointer func_data,GtkArg * args
</FUNCTION>
<MACRO>
<NAME>gtk_marshal_NONE__ENUM_FLOAT_BOOL</NAME>
#define gtk_marshal_NONE__ENUM_FLOAT_BOOL gtk_marshal_NONE__INT_FLOAT_BOOL
</MACRO>
<FUNCTION>
<NAME>gtk_marshal_NONE__INT_FLOAT_BOOL</NAME>
<RETURNS>void  </RETURNS>
GtkObject * object,GtkSignalFunc func,gpointer func_data,GtkArg * args
</FUNCTION>
<FUNCTION>
<NAME>gtk_marshal_NONE__INT_INT</NAME>
<RETURNS>void  </RETURNS>
GtkObject * object,GtkSignalFunc func,gpointer func_data,GtkArg * args
</FUNCTION>
<FUNCTION>
<NAME>gtk_marshal_NONE__INT_INT_POINTER</NAME>
<RETURNS>void  </RETURNS>
GtkObject * object,GtkSignalFunc func,gpointer func_data,GtkArg * args
</FUNCTION>
<FUNCTION>
<NAME>gtk_marshal_NONE__NONE</NAME>
<RETURNS>void  </RETURNS>
GtkObject * object,GtkSignalFunc func,gpointer func_data,GtkArg * args
</FUNCTION>
<MACRO>
<NAME>gtk_marshal_NONE__OBJECT</NAME>
#define gtk_marshal_NONE__OBJECT gtk_marshal_NONE__POINTER
</MACRO>
<FUNCTION>
<NAME>gtk_marshal_NONE__POINTER_INT</NAME>
<RETURNS>void  </RETURNS>
GtkObject * object,GtkSignalFunc func,gpointer func_data,GtkArg * args
</FUNCTION>
<FUNCTION>
<NAME>gtk_marshal_NONE__POINTER_POINTER</NAME>
<RETURNS>void  </RETURNS>
GtkObject * object,GtkSignalFunc func,gpointer func_data,GtkArg * args
</FUNCTION>
<FUNCTION>
<NAME>gtk_marshal_NONE__POINTER_POINTER_POINTER</NAME>
<RETURNS>void  </RETURNS>
GtkObject * object,GtkSignalFunc func,gpointer func_data,GtkArg * args
</FUNCTION>
<MACRO>
<NAME>gtk_marshal_NONE__POINTER_STRING_STRING</NAME>
#define gtk_marshal_NONE__POINTER_STRING_STRING gtk_marshal_NONE__POINTER_POINTER_POINTER
</MACRO>
<MACRO>
<NAME>gtk_marshal_NONE__POINTER_UINT</NAME>
#define gtk_marshal_NONE__POINTER_UINT gtk_marshal_NONE__POINTER_INT
</MACRO>
<MACRO>
<NAME>gtk_marshal_NONE__POINTER_UINT_ENUM</NAME>
#define gtk_marshal_NONE__POINTER_UINT_ENUM gtk_marshal_NONE__POINTER_INT_INT
</MACRO>
<FUNCTION>
<NAME>gtk_marshal_NONE__POINTER_INT_INT</NAME>
<RETURNS>void  </RETURNS>
GtkObject * object,GtkSignalFunc func,gpointer func_data,GtkArg * args
</FUNCTION>
<MACRO>
<NAME>gtk_marshal_NONE__POINTER_POINTER_UINT_UINT</NAME>
#define gtk_marshal_NONE__POINTER_POINTER_UINT_UINT gtk_marshal_NONE__POINTER_POINTER_INT_INT
</MACRO>
<FUNCTION>
<NAME>gtk_marshal_NONE__POINTER_POINTER_INT_INT</NAME>
<RETURNS>void  </RETURNS>
GtkObject * object,GtkSignalFunc func,gpointer func_data,GtkArg * args
</FUNCTION>
<MACRO>
<NAME>gtk_marshal_NONE__POINTER_INT_INT_POINTER_UINT_UINT</NAME>
#define gtk_marshal_NONE__POINTER_INT_INT_POINTER_UINT_UINT gtk_marshal_NONE__POINTER_INT_INT_POINTER_INT_INT
</MACRO>
<FUNCTION>
<NAME>gtk_marshal_NONE__POINTER_INT_INT_POINTER_INT_INT</NAME>
<RETURNS>void  </RETURNS>
GtkObject * object,GtkSignalFunc func,gpointer func_data,GtkArg * args
</FUNCTION>
<MACRO>
<NAME>gtk_marshal_NONE__POINTER_UINT_UINT</NAME>
#define gtk_marshal_NONE__POINTER_UINT_UINT gtk_marshal_NONE__POINTER_INT_INT
</MACRO>
<MACRO>
<NAME>gtk_marshal_NONE__STRING</NAME>
#define gtk_marshal_NONE__STRING gtk_marshal_NONE__POINTER
</MACRO>
<MACRO>
<NAME>gtk_marshal_NONE__STRING_INT_POINTER</NAME>
#define gtk_marshal_NONE__STRING_INT_POINTER gtk_marshal_NONE__POINTER_INT_POINTER
</MACRO>
<FUNCTION>
<NAME>gtk_marshal_NONE__POINTER_INT_POINTER</NAME>
<RETURNS>void  </RETURNS>
GtkObject * object,GtkSignalFunc func,gpointer func_data,GtkArg * args
</FUNCTION>
<MACRO>
<NAME>gtk_marshal_NONE__UINT</NAME>
#define gtk_marshal_NONE__UINT gtk_marshal_NONE__INT
</MACRO>
<MACRO>
<NAME>gtk_marshal_NONE__UINT_POINTER_UINT_ENUM_ENUM_POINTER</NAME>
#define gtk_marshal_NONE__UINT_POINTER_UINT_ENUM_ENUM_POINTER gtk_marshal_NONE__INT_POINTER_INT_INT_INT_POINTER
</MACRO>
<FUNCTION>
<NAME>gtk_marshal_NONE__INT_POINTER_INT_INT_INT_POINTER</NAME>
<RETURNS>void  </RETURNS>
GtkObject * object,GtkSignalFunc func,gpointer func_data,GtkArg * args
</FUNCTION>
<MACRO>
<NAME>gtk_marshal_NONE__UINT_POINTER_UINT_UINT_ENUM</NAME>
#define gtk_marshal_NONE__UINT_POINTER_UINT_UINT_ENUM gtk_marshal_NONE__INT_POINTER_INT_INT_INT
</MACRO>
<FUNCTION>
<NAME>gtk_marshal_NONE__INT_POINTER_INT_INT_INT</NAME>
<RETURNS>void  </RETURNS>
GtkObject * object,GtkSignalFunc func,gpointer func_data,GtkArg * args
</FUNCTION>
<MACRO>
<NAME>gtk_marshal_NONE__UINT_STRING</NAME>
#define gtk_marshal_NONE__UINT_STRING gtk_marshal_NONE__INT_POINTER
</MACRO>
<FUNCTION>
<NAME>gtk_marshal_NONE__INT_POINTER</NAME>
<RETURNS>void  </RETURNS>
GtkObject * object,GtkSignalFunc func,gpointer func_data,GtkArg * args
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_MENU</NAME>
#define GTK_TYPE_MENU			(gtk_menu_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_MENU</NAME>
#define GTK_MENU(obj)			(GTK_CHECK_CAST ((obj), GTK_TYPE_MENU, GtkMenu))
</MACRO>
<MACRO>
<NAME>GTK_MENU_CLASS</NAME>
#define GTK_MENU_CLASS(klass)		(GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_MENU, GtkMenuClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_MENU</NAME>
#define GTK_IS_MENU(obj)		(GTK_CHECK_TYPE ((obj), GTK_TYPE_MENU))
</MACRO>
<MACRO>
<NAME>GTK_IS_MENU_CLASS</NAME>
#define GTK_IS_MENU_CLASS(klass)	(GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_MENU))
</MACRO>
<STRUCT>
<NAME>GtkMenu</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkMenuClass</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>GtkMenuPositionFunc</NAME>
<RETURNS>void </RETURNS>
GtkMenu   *menu,
				     gint      *x,
				     gint      *y,
				     gpointer	user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GtkMenuDetachFunc</NAME>
<RETURNS>void </RETURNS>
GtkWidget *attach_widget,
				     GtkMenu   *menu
</USER_FUNCTION>
<STRUCT>
<NAME>GtkMenu</NAME>
struct GtkMenu
{
  GtkMenuShell menu_shell;
  
  GtkWidget *parent_menu_item;
  GtkWidget *old_active_menu_item;
  
  GtkAccelGroup *accel_group;
  GtkMenuPositionFunc position_func;
  gpointer position_func_data;

  /* Do _not_ touch these widgets directly. We hide the reference
   * count from the toplevel to the menu, so it must be restored
   * before operating on these widgets
   */
  GtkWidget *toplevel;
  GtkWidget *tearoff_window;

  guint torn_off : 1;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_menu_get_type</NAME>
<RETURNS>GtkType 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_menu_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_menu_append</NAME>
<RETURNS>void 	</RETURNS>
GtkMenu	       *menu,GtkWidget	       *child
</FUNCTION>
<FUNCTION>
<NAME>gtk_menu_prepend</NAME>
<RETURNS>void 	</RETURNS>
GtkMenu	       *menu,GtkWidget	       *child
</FUNCTION>
<FUNCTION>
<NAME>gtk_menu_insert</NAME>
<RETURNS>void 	</RETURNS>
GtkMenu	       *menu,GtkWidget	       *child,gint			position
</FUNCTION>
<FUNCTION>
<NAME>gtk_menu_popup</NAME>
<RETURNS>void 	</RETURNS>
GtkMenu	       *menu,GtkWidget	       *parent_menu_shell,GtkWidget	       *parent_menu_item,GtkMenuPositionFunc	func,gpointer		data,guint		button,guint32		activate_time
</FUNCTION>
<FUNCTION>
<NAME>gtk_menu_reposition</NAME>
<RETURNS>void 	</RETURNS>
GtkMenu	       *menu
</FUNCTION>
<FUNCTION>
<NAME>gtk_menu_popdown</NAME>
<RETURNS>void 	</RETURNS>
GtkMenu	       *menu
</FUNCTION>
<FUNCTION>
<NAME>gtk_menu_get_active</NAME>
<RETURNS>GtkWidget *</RETURNS>
GtkMenu	       *menu
</FUNCTION>
<FUNCTION>
<NAME>gtk_menu_set_active</NAME>
<RETURNS>void 	</RETURNS>
GtkMenu	       *menu,guint		index
</FUNCTION>
<FUNCTION>
<NAME>gtk_menu_set_accel_group</NAME>
<RETURNS>void 	</RETURNS>
GtkMenu	       *menu,GtkAccelGroup       *accel_group
</FUNCTION>
<FUNCTION>
<NAME>gtk_menu_get_accel_group</NAME>
<RETURNS>GtkAccelGroup *</RETURNS>
GtkMenu	       *menu
</FUNCTION>
<FUNCTION>
<NAME>gtk_menu_get_uline_accel_group</NAME>
<RETURNS>GtkAccelGroup *</RETURNS>
GtkMenu         *menu
</FUNCTION>
<FUNCTION>
<NAME>gtk_menu_ensure_uline_accel_group</NAME>
<RETURNS>GtkAccelGroup *</RETURNS>
GtkMenu         *menu
</FUNCTION>
<FUNCTION>
<NAME>gtk_menu_attach_to_widget</NAME>
<RETURNS>void 	</RETURNS>
GtkMenu	       *menu,GtkWidget	       *attach_widget,GtkMenuDetachFunc	detacher
</FUNCTION>
<FUNCTION>
<NAME>gtk_menu_detach</NAME>
<RETURNS>void 	</RETURNS>
GtkMenu	       *menu
</FUNCTION>
<FUNCTION>
<NAME>gtk_menu_get_attach_widget</NAME>
<RETURNS>GtkWidget *</RETURNS>
GtkMenu	       *menu
</FUNCTION>
<FUNCTION>
<NAME>gtk_menu_detach</NAME>
<RETURNS>void 	</RETURNS>
GtkMenu	       *menu
</FUNCTION>
<FUNCTION>
<NAME>gtk_menu_set_tearoff_state</NAME>
<RETURNS>void  </RETURNS>
GtkMenu             *menu,gboolean             torn_off
</FUNCTION>
<FUNCTION>
<NAME>gtk_menu_set_title</NAME>
<RETURNS>void  </RETURNS>
GtkMenu             *menu,const gchar         *title
</FUNCTION>
<FUNCTION>
<NAME>gtk_menu_reorder_child</NAME>
<RETURNS>void  </RETURNS>
GtkMenu             *menu,GtkWidget           *child,gint                position
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_MENU_BAR</NAME>
#define	GTK_TYPE_MENU_BAR		(gtk_menu_bar_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_MENU_BAR</NAME>
#define GTK_MENU_BAR(obj)		(GTK_CHECK_CAST ((obj), GTK_TYPE_MENU_BAR, GtkMenuBar))
</MACRO>
<MACRO>
<NAME>GTK_MENU_BAR_CLASS</NAME>
#define GTK_MENU_BAR_CLASS(klass)	(GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_MENU_BAR, GtkMenuBarClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_MENU_BAR</NAME>
#define GTK_IS_MENU_BAR(obj)		(GTK_CHECK_TYPE ((obj), GTK_TYPE_MENU_BAR))
</MACRO>
<MACRO>
<NAME>GTK_IS_MENU_BAR_CLASS</NAME>
#define GTK_IS_MENU_BAR_CLASS(klass)	(GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_MENU_BAR))
</MACRO>
<STRUCT>
<NAME>GtkMenuBar</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkMenuBarClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkMenuBar</NAME>
struct GtkMenuBar
{
  GtkMenuShell menu_shell;

  GtkShadowType shadow_type;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_menu_bar_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_menu_bar_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_menu_bar_append</NAME>
<RETURNS>void  </RETURNS>
GtkMenuBar    *menu_bar,GtkWidget     *child
</FUNCTION>
<FUNCTION>
<NAME>gtk_menu_bar_prepend</NAME>
<RETURNS>void  </RETURNS>
GtkMenuBar    *menu_bar,GtkWidget     *child
</FUNCTION>
<FUNCTION>
<NAME>gtk_menu_bar_insert</NAME>
<RETURNS>void  </RETURNS>
GtkMenuBar    *menu_bar,GtkWidget     *child,gint           position
</FUNCTION>
<FUNCTION>
<NAME>gtk_menu_bar_set_shadow_type</NAME>
<RETURNS>void  </RETURNS>
GtkMenuBar    *menu_bar,GtkShadowType  type
</FUNCTION>
<STRUCT>
<NAME>GtkMenuEntry</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkMenuPath</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkMenuFactory</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>GtkMenuCallback</NAME>
<RETURNS>void </RETURNS>
GtkWidget *widget,
				 gpointer   user_data
</USER_FUNCTION>
<STRUCT>
<NAME>GtkMenuEntry</NAME>
struct GtkMenuEntry
{
  gchar *path;
  gchar *accelerator;
  GtkMenuCallback callback;
  gpointer callback_data;
  GtkWidget *widget;
};
</STRUCT>
<STRUCT>
<NAME>GtkMenuPath</NAME>
struct GtkMenuPath
{
  char *path;
  GtkWidget *widget;
};
</STRUCT>
<STRUCT>
<NAME>GtkMenuFactory</NAME>
struct GtkMenuFactory
{
  gchar *path;
  GtkMenuFactoryType type;
  GtkAccelGroup *accel_group;
  GtkWidget *widget;
  GList *subfactories;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_menu_factory_new</NAME>
<RETURNS>GtkMenuFactory *</RETURNS>
GtkMenuFactoryType	type
</FUNCTION>
<FUNCTION>
<NAME>gtk_menu_factory_destroy</NAME>
<RETURNS>void 	</RETURNS>
GtkMenuFactory     *factory
</FUNCTION>
<FUNCTION>
<NAME>gtk_menu_factory_add_entries</NAME>
<RETURNS>void 	</RETURNS>
GtkMenuFactory     *factory,GtkMenuEntry       *entries,int			nentries
</FUNCTION>
<FUNCTION>
<NAME>gtk_menu_factory_add_subfactory</NAME>
<RETURNS>void 	</RETURNS>
GtkMenuFactory     *factory,GtkMenuFactory     *subfactory,const char	       *path
</FUNCTION>
<FUNCTION>
<NAME>gtk_menu_factory_remove_paths</NAME>
<RETURNS>void 	</RETURNS>
GtkMenuFactory     *factory,char	      **paths,int			npaths
</FUNCTION>
<FUNCTION>
<NAME>gtk_menu_factory_remove_entries</NAME>
<RETURNS>void 	</RETURNS>
GtkMenuFactory     *factory,GtkMenuEntry       *entries,int			nentries
</FUNCTION>
<FUNCTION>
<NAME>gtk_menu_factory_remove_subfactory</NAME>
<RETURNS>void 	</RETURNS>
GtkMenuFactory     *factory,GtkMenuFactory     *subfactory,const char	       *path
</FUNCTION>
<FUNCTION>
<NAME>gtk_menu_factory_find</NAME>
<RETURNS>GtkMenuPath *</RETURNS>
GtkMenuFactory     *factory,const char	       *path
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_MENU_ITEM</NAME>
#define	GTK_TYPE_MENU_ITEM		(gtk_menu_item_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_MENU_ITEM</NAME>
#define GTK_MENU_ITEM(obj)		(GTK_CHECK_CAST ((obj), GTK_TYPE_MENU_ITEM, GtkMenuItem))
</MACRO>
<MACRO>
<NAME>GTK_MENU_ITEM_CLASS</NAME>
#define GTK_MENU_ITEM_CLASS(klass)	(GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_MENU_ITEM, GtkMenuItemClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_MENU_ITEM</NAME>
#define GTK_IS_MENU_ITEM(obj)		(GTK_CHECK_TYPE ((obj), GTK_TYPE_MENU_ITEM))
</MACRO>
<MACRO>
<NAME>GTK_IS_MENU_ITEM_CLASS</NAME>
#define GTK_IS_MENU_ITEM_CLASS(klass)	(GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_MENU_ITEM))
</MACRO>
<STRUCT>
<NAME>GtkMenuItem</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkMenuItemClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkMenuItem</NAME>
struct GtkMenuItem
{
  GtkItem item;
  
  GtkWidget *submenu;
  
  guint	  accelerator_signal;
  guint16 toggle_size;
  guint16 accelerator_width;
  
  guint show_toggle_indicator : 1;
  guint show_submenu_indicator : 1;
  guint submenu_placement : 1;
  guint submenu_direction : 1;
  guint right_justify: 1;
  guint timer;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_menu_item_get_type</NAME>
<RETURNS>GtkType 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_menu_item_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_menu_item_new_with_label</NAME>
<RETURNS>GtkWidget *</RETURNS>
const gchar	       *label
</FUNCTION>
<FUNCTION>
<NAME>gtk_menu_item_set_submenu</NAME>
<RETURNS>void 	</RETURNS>
GtkMenuItem	       *menu_item,GtkWidget	       *submenu
</FUNCTION>
<FUNCTION>
<NAME>gtk_menu_item_remove_submenu</NAME>
<RETURNS>void 	</RETURNS>
GtkMenuItem	       *menu_item
</FUNCTION>
<FUNCTION>
<NAME>gtk_menu_item_set_placement</NAME>
<RETURNS>void 	</RETURNS>
GtkMenuItem	       *menu_item,GtkSubmenuPlacement	placement
</FUNCTION>
<FUNCTION>
<NAME>gtk_menu_item_configure</NAME>
<RETURNS>void 	</RETURNS>
GtkMenuItem	       *menu_item,gint			show_toggle_indicator,gint			show_submenu_indicator
</FUNCTION>
<FUNCTION>
<NAME>gtk_menu_item_select</NAME>
<RETURNS>void 	</RETURNS>
GtkMenuItem	       *menu_item
</FUNCTION>
<FUNCTION>
<NAME>gtk_menu_item_deselect</NAME>
<RETURNS>void 	</RETURNS>
GtkMenuItem	       *menu_item
</FUNCTION>
<FUNCTION>
<NAME>gtk_menu_item_activate</NAME>
<RETURNS>void 	</RETURNS>
GtkMenuItem	       *menu_item
</FUNCTION>
<FUNCTION>
<NAME>gtk_menu_item_right_justify</NAME>
<RETURNS>void 	</RETURNS>
GtkMenuItem	       *menu_item
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_MENU_SHELL</NAME>
#define	GTK_TYPE_MENU_SHELL		(gtk_menu_shell_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_MENU_SHELL</NAME>
#define GTK_MENU_SHELL(obj)		(GTK_CHECK_CAST ((obj), GTK_TYPE_MENU_SHELL, GtkMenuShell))
</MACRO>
<MACRO>
<NAME>GTK_MENU_SHELL_CLASS</NAME>
#define GTK_MENU_SHELL_CLASS(klass)	(GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_MENU_SHELL, GtkMenuShellClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_MENU_SHELL</NAME>
#define GTK_IS_MENU_SHELL(obj)		(GTK_CHECK_TYPE ((obj), GTK_TYPE_MENU_SHELL))
</MACRO>
<MACRO>
<NAME>GTK_IS_MENU_SHELL_CLASS</NAME>
#define GTK_IS_MENU_SHELL_CLASS(klass)	(GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_MENU_SHELL))
</MACRO>
<STRUCT>
<NAME>GtkMenuShell</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkMenuShellClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkMenuShell</NAME>
struct GtkMenuShell
{
  GtkContainer container;
  
  GList *children;
  GtkWidget *active_menu_item;
  GtkWidget *parent_menu_shell;
  
  guint active : 1;
  guint have_grab : 1;
  guint have_xgrab : 1;
  guint button : 2;
  guint ignore_leave : 1;
  guint menu_flag : 1;
  guint ignore_enter : 1;
  
  guint32 activate_time;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_menu_shell_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_menu_shell_append</NAME>
<RETURNS>void 	</RETURNS>
GtkMenuShell *menu_shell,GtkWidget	*child
</FUNCTION>
<FUNCTION>
<NAME>gtk_menu_shell_prepend</NAME>
<RETURNS>void 	</RETURNS>
GtkMenuShell *menu_shell,GtkWidget	*child
</FUNCTION>
<FUNCTION>
<NAME>gtk_menu_shell_insert</NAME>
<RETURNS>void 	</RETURNS>
GtkMenuShell *menu_shell,GtkWidget	*child,gint		 position
</FUNCTION>
<FUNCTION>
<NAME>gtk_menu_shell_deactivate</NAME>
<RETURNS>void 	</RETURNS>
GtkMenuShell *menu_shell
</FUNCTION>
<FUNCTION>
<NAME>gtk_menu_shell_select_item</NAME>
<RETURNS>void  </RETURNS>
GtkMenuShell      *menu_shell,GtkWidget         *menu_item
</FUNCTION>
<FUNCTION>
<NAME>gtk_menu_shell_deselect</NAME>
<RETURNS>void  </RETURNS>
GtkMenuShell      *menu_shell
</FUNCTION>
<FUNCTION>
<NAME>gtk_menu_shell_activate_item</NAME>
<RETURNS>void  </RETURNS>
GtkMenuShell      *menu_shell,GtkWidget         *menu_item,gboolean           force_deactivate
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_MISC</NAME>
#define GTK_TYPE_MISC		       (gtk_misc_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_MISC</NAME>
#define GTK_MISC(obj)		       (GTK_CHECK_CAST ((obj), GTK_TYPE_MISC, GtkMisc))
</MACRO>
<MACRO>
<NAME>GTK_MISC_CLASS</NAME>
#define GTK_MISC_CLASS(klass)	       (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_MISC, GtkMiscClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_MISC</NAME>
#define GTK_IS_MISC(obj)	       (GTK_CHECK_TYPE ((obj), GTK_TYPE_MISC))
</MACRO>
<MACRO>
<NAME>GTK_IS_MISC_CLASS</NAME>
#define GTK_IS_MISC_CLASS(klass)       (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_MISC))
</MACRO>
<STRUCT>
<NAME>GtkMisc</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkMiscClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkMisc</NAME>
struct GtkMisc
{
  GtkWidget widget;
  
  gfloat xalign;
  gfloat yalign;
  
  guint16 xpad;
  guint16 ypad;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_misc_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_misc_set_alignment</NAME>
<RETURNS>void 	</RETURNS>
GtkMisc *misc,gfloat	 xalign,gfloat	 yalign
</FUNCTION>
<FUNCTION>
<NAME>gtk_misc_set_padding</NAME>
<RETURNS>void 	</RETURNS>
GtkMisc *misc,gint	 xpad,gint	 ypad
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_NOTEBOOK</NAME>
#define GTK_TYPE_NOTEBOOK                  (gtk_notebook_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_NOTEBOOK</NAME>
#define GTK_NOTEBOOK(obj)                  (GTK_CHECK_CAST ((obj), GTK_TYPE_NOTEBOOK, GtkNotebook))
</MACRO>
<MACRO>
<NAME>GTK_NOTEBOOK_CLASS</NAME>
#define GTK_NOTEBOOK_CLASS(klass)          (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_NOTEBOOK, GtkNotebookClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_NOTEBOOK</NAME>
#define GTK_IS_NOTEBOOK(obj)               (GTK_CHECK_TYPE ((obj), GTK_TYPE_NOTEBOOK))
</MACRO>
<MACRO>
<NAME>GTK_IS_NOTEBOOK_CLASS</NAME>
#define GTK_IS_NOTEBOOK_CLASS(klass)       (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_NOTEBOOK))
</MACRO>
<MACRO>
<NAME>GTK_NOTEBOOK_PAGE</NAME>
#define GTK_NOTEBOOK_PAGE(_glist_)         ((GtkNotebookPage *)((GList *)(_glist_))->data)
</MACRO>
<STRUCT>
<NAME>GtkNotebook</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkNotebookClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkNotebookPage</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkNotebook</NAME>
struct GtkNotebook
{
  GtkContainer container;
  
  GtkNotebookPage *cur_page;
  GList *children;
  GList *first_tab;
  GList *focus_tab;
  
  GtkWidget *menu;
  GdkWindow *panel;
  
  guint32 timer;
  
  guint16 tab_hborder;
  guint16 tab_vborder;
  
  guint show_tabs          : 1;
  guint homogeneous        : 1;
  guint show_border        : 1;
  guint tab_pos            : 2;
  guint scrollable         : 1;
  guint in_child           : 2;
  guint click_child        : 2;
  guint button             : 2;
  guint need_timer         : 1;
  guint child_has_focus    : 1;
  guint have_visible_child : 1;
};
</STRUCT>
<STRUCT>
<NAME>GtkNotebookPage</NAME>
struct GtkNotebookPage
{
  GtkWidget *child;
  GtkWidget *tab_label;
  GtkWidget *menu_label;

  guint default_menu : 1;
  guint default_tab  : 1;
  guint expand       : 1;
  guint fill         : 1;
  guint pack         : 1;

  GtkRequisition requisition;
  GtkAllocation allocation;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_notebook_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_notebook_new</NAME>
<RETURNS>GtkWidget  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_notebook_append_page</NAME>
<RETURNS>void  </RETURNS>
GtkNotebook *notebook,GtkWidget   *child,GtkWidget   *tab_label
</FUNCTION>
<FUNCTION>
<NAME>gtk_notebook_append_page_menu</NAME>
<RETURNS>void  </RETURNS>
GtkNotebook *notebook,GtkWidget   *child,GtkWidget   *tab_label,GtkWidget   *menu_label
</FUNCTION>
<FUNCTION>
<NAME>gtk_notebook_prepend_page</NAME>
<RETURNS>void  </RETURNS>
GtkNotebook *notebook,GtkWidget   *child,GtkWidget   *tab_label
</FUNCTION>
<FUNCTION>
<NAME>gtk_notebook_prepend_page_menu</NAME>
<RETURNS>void  </RETURNS>
GtkNotebook *notebook,GtkWidget   *child,GtkWidget   *tab_label,GtkWidget   *menu_label
</FUNCTION>
<FUNCTION>
<NAME>gtk_notebook_insert_page</NAME>
<RETURNS>void  </RETURNS>
GtkNotebook *notebook,GtkWidget   *child,GtkWidget   *tab_label,gint         position
</FUNCTION>
<FUNCTION>
<NAME>gtk_notebook_insert_page_menu</NAME>
<RETURNS>void  </RETURNS>
GtkNotebook *notebook,GtkWidget   *child,GtkWidget   *tab_label,GtkWidget   *menu_label,gint         position
</FUNCTION>
<FUNCTION>
<NAME>gtk_notebook_remove_page</NAME>
<RETURNS>void  </RETURNS>
GtkNotebook *notebook,gint         page_num
</FUNCTION>
<FUNCTION>
<NAME>gtk_notebook_get_current_page</NAME>
<RETURNS>gint  </RETURNS>
GtkNotebook *notebook
</FUNCTION>
<FUNCTION>
<NAME>gtk_notebook_get_nth_page</NAME>
<RETURNS>GtkWidget *</RETURNS>
GtkNotebook *notebook,gint         page_num
</FUNCTION>
<FUNCTION>
<NAME>gtk_notebook_page_num</NAME>
<RETURNS>gint  </RETURNS>
GtkNotebook *notebook,GtkWidget   *child
</FUNCTION>
<FUNCTION>
<NAME>gtk_notebook_set_page</NAME>
<RETURNS>void  </RETURNS>
GtkNotebook *notebook,gint         page_num
</FUNCTION>
<FUNCTION>
<NAME>gtk_notebook_next_page</NAME>
<RETURNS>void  </RETURNS>
GtkNotebook *notebook
</FUNCTION>
<FUNCTION>
<NAME>gtk_notebook_prev_page</NAME>
<RETURNS>void  </RETURNS>
GtkNotebook *notebook
</FUNCTION>
<FUNCTION>
<NAME>gtk_notebook_set_show_border</NAME>
<RETURNS>void  </RETURNS>
GtkNotebook     *notebook,gboolean         show_border
</FUNCTION>
<FUNCTION>
<NAME>gtk_notebook_set_show_tabs</NAME>
<RETURNS>void  </RETURNS>
GtkNotebook     *notebook,gboolean         show_tabs
</FUNCTION>
<FUNCTION>
<NAME>gtk_notebook_set_tab_pos</NAME>
<RETURNS>void  </RETURNS>
GtkNotebook     *notebook,GtkPositionType  pos
</FUNCTION>
<FUNCTION>
<NAME>gtk_notebook_set_homogeneous_tabs</NAME>
<RETURNS>void  </RETURNS>
GtkNotebook     *notebook,gboolean         homogeneous
</FUNCTION>
<FUNCTION>
<NAME>gtk_notebook_set_tab_border</NAME>
<RETURNS>void  </RETURNS>
GtkNotebook     *notebook,guint            border_width
</FUNCTION>
<FUNCTION>
<NAME>gtk_notebook_set_tab_hborder</NAME>
<RETURNS>void  </RETURNS>
GtkNotebook     *notebook,guint            tab_hborder
</FUNCTION>
<FUNCTION>
<NAME>gtk_notebook_set_tab_vborder</NAME>
<RETURNS>void  </RETURNS>
GtkNotebook     *notebook,guint            tab_vborder
</FUNCTION>
<FUNCTION>
<NAME>gtk_notebook_set_scrollable</NAME>
<RETURNS>void  </RETURNS>
GtkNotebook     *notebook,gboolean         scrollable
</FUNCTION>
<FUNCTION>
<NAME>gtk_notebook_popup_enable</NAME>
<RETURNS>void  </RETURNS>
GtkNotebook *notebook
</FUNCTION>
<FUNCTION>
<NAME>gtk_notebook_popup_disable</NAME>
<RETURNS>void  </RETURNS>
GtkNotebook *notebook
</FUNCTION>
<FUNCTION>
<NAME>gtk_notebook_get_tab_label</NAME>
<RETURNS>GtkWidget  *</RETURNS>
GtkNotebook *notebook,GtkWidget   *child
</FUNCTION>
<FUNCTION>
<NAME>gtk_notebook_set_tab_label</NAME>
<RETURNS>void  </RETURNS>
GtkNotebook *notebook,GtkWidget   *child,GtkWidget   *tab_label
</FUNCTION>
<FUNCTION>
<NAME>gtk_notebook_set_tab_label_text</NAME>
<RETURNS>void  </RETURNS>
GtkNotebook *notebook,GtkWidget   *child,const gchar *tab_text
</FUNCTION>
<FUNCTION>
<NAME>gtk_notebook_get_menu_label</NAME>
<RETURNS>GtkWidget  *</RETURNS>
GtkNotebook *notebook,GtkWidget   *child
</FUNCTION>
<FUNCTION>
<NAME>gtk_notebook_set_menu_label</NAME>
<RETURNS>void  </RETURNS>
GtkNotebook *notebook,GtkWidget   *child,GtkWidget   *menu_label
</FUNCTION>
<FUNCTION>
<NAME>gtk_notebook_set_menu_label_text</NAME>
<RETURNS>void  </RETURNS>
GtkNotebook *notebook,GtkWidget   *child,const gchar *menu_text
</FUNCTION>
<FUNCTION>
<NAME>gtk_notebook_query_tab_label_packing</NAME>
<RETURNS>void  </RETURNS>
GtkNotebook *notebook,GtkWidget   *child,gboolean    *expand,gboolean    *fill,GtkPackType *pack_type
</FUNCTION>
<FUNCTION>
<NAME>gtk_notebook_set_tab_label_packing</NAME>
<RETURNS>void  </RETURNS>
GtkNotebook *notebook,GtkWidget   *child,gboolean     expand,gboolean     fill,GtkPackType  pack_type
</FUNCTION>
<FUNCTION>
<NAME>gtk_notebook_reorder_child</NAME>
<RETURNS>void  </RETURNS>
GtkNotebook *notebook,GtkWidget   *child,gint         position
</FUNCTION>
<MACRO>
<NAME>GTK_OBJECT</NAME>
#define GTK_OBJECT(object)		( \
  GTK_IS_OBJECT (object) ? \
    (GtkObject*) (object) : \
    (GtkObject*) gtk_type_check_object_cast ((GtkTypeObject*) (object), GTK_TYPE_OBJECT) \
)
</MACRO>
<MACRO>
<NAME>GTK_OBJECT_CLASS</NAME>
#define GTK_OBJECT_CLASS(klass)		( \
  GTK_IS_OBJECT_CLASS (klass) ? \
    (GtkObjectClass*) (klass) : \
    (GtkObjectClass*) gtk_type_check_class_cast ((GtkTypeClass*) (klass), GTK_TYPE_OBJECT) \
)
</MACRO>
<MACRO>
<NAME>GTK_IS_OBJECT</NAME>
#define GTK_IS_OBJECT(object)		( \
  (object) != NULL && \
  GTK_IS_OBJECT_CLASS (((GtkObject*) (object))->klass) \
)
</MACRO>
<MACRO>
<NAME>GTK_IS_OBJECT_CLASS</NAME>
#define GTK_IS_OBJECT_CLASS(klass)	( \
  (klass) != NULL && \
  GTK_FUNDAMENTAL_TYPE (((GtkObjectClass*) (klass))->type) == GTK_TYPE_OBJECT \
)
</MACRO>
<MACRO>
<NAME>GTK_OBJECT_TYPE</NAME>
#define GTK_OBJECT_TYPE(obj)		  (GTK_OBJECT (obj)->klass->type)
</MACRO>
<MACRO>
<NAME>GTK_OBJECT_SIGNALS</NAME>
#define GTK_OBJECT_SIGNALS(obj)		  (GTK_OBJECT (obj)->klass->signals)
</MACRO>
<MACRO>
<NAME>GTK_OBJECT_NSIGNALS</NAME>
#define GTK_OBJECT_NSIGNALS(obj)	  (GTK_OBJECT (obj)->klass->nsignals)
</MACRO>
<ENUM>
<NAME>GtkObjectFlags</NAME>
typedef enum
{
  GTK_DESTROYED		= 1 << 0,
  GTK_FLOATING		= 1 << 1,
  GTK_CONNECTED		= 1 << 2,
  GTK_CONSTRUCTED	= 1 << 3
} GtkObjectFlags;
</ENUM>
<MACRO>
<NAME>GTK_OBJECT_FLAGS</NAME>
#define GTK_OBJECT_FLAGS(obj)		  (GTK_OBJECT (obj)->flags)
</MACRO>
<MACRO>
<NAME>GTK_OBJECT_DESTROYED</NAME>
#define GTK_OBJECT_DESTROYED(obj)	  ((GTK_OBJECT_FLAGS (obj) & GTK_DESTROYED) != 0)
</MACRO>
<MACRO>
<NAME>GTK_OBJECT_FLOATING</NAME>
#define GTK_OBJECT_FLOATING(obj)	  ((GTK_OBJECT_FLAGS (obj) & GTK_FLOATING) != 0)
</MACRO>
<MACRO>
<NAME>GTK_OBJECT_CONNECTED</NAME>
#define GTK_OBJECT_CONNECTED(obj)	  ((GTK_OBJECT_FLAGS (obj) & GTK_CONNECTED) != 0)
</MACRO>
<MACRO>
<NAME>GTK_OBJECT_CONSTRUCTED</NAME>
#define GTK_OBJECT_CONSTRUCTED(obj)	  ((GTK_OBJECT_FLAGS (obj) & GTK_CONSTRUCTED) != 0)
</MACRO>
<MACRO>
<NAME>GTK_OBJECT_SET_FLAGS</NAME>
#define GTK_OBJECT_SET_FLAGS(obj,flag)	  G_STMT_START{ (GTK_OBJECT_FLAGS (obj) |= (flag)); }G_STMT_END
</MACRO>
<MACRO>
<NAME>GTK_OBJECT_UNSET_FLAGS</NAME>
#define GTK_OBJECT_UNSET_FLAGS(obj,flag)  G_STMT_START{ (GTK_OBJECT_FLAGS (obj) &= ~(flag)); }G_STMT_END
</MACRO>
<ENUM>
<NAME>GtkArgFlags</NAME>
typedef enum
{
  GTK_ARG_READABLE	 = 1 << 0,
  GTK_ARG_WRITABLE	 = 1 << 1,
  GTK_ARG_CONSTRUCT	 = 1 << 2,
  GTK_ARG_CONSTRUCT_ONLY = 1 << 3,
  GTK_ARG_CHILD_ARG	 = 1 << 4,
  GTK_ARG_MASK		 = 0x1f,
  
  /* aliases
   */
  GTK_ARG_READWRITE	 = GTK_ARG_READABLE | GTK_ARG_WRITABLE
} GtkArgFlags;
</ENUM>
<STRUCT>
<NAME>GtkObjectClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkObject</NAME>
struct GtkObject
{
  /* GtkTypeObject related fields: */
  GtkObjectClass *klass;
  
  
  /* 32 bits of flags. GtkObject only uses 4 of these bits and
   *  GtkWidget uses the rest. This is done because structs are
   *  aligned on 4 or 8 byte boundaries. If a new bitfield were
   *  used in GtkWidget much space would be wasted.
   */
  guint32 flags;
  
  /* reference count.
   * refer to the file docs/refcounting.txt on this issue.
   */
  guint ref_count;
  
  /* A list of keyed data pointers, used for e.g. the list of signal
   * handlers or an object's user_data.
   */
  GData *object_data;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_object_get_type</NAME>
<RETURNS>GtkType 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_object_class_user_signal_new</NAME>
<RETURNS>guint 	</RETURNS>
GtkObjectClass     *klass,const gchar	      *name,GtkSignalRunType    signal_flags,GtkSignalMarshaller marshaller,GtkType	       return_val,guint	       nparams,...
</FUNCTION>
<FUNCTION>
<NAME>gtk_object_class_user_signal_newv</NAME>
<RETURNS>guint 	</RETURNS>
GtkObjectClass     *klass,const gchar	      *name,GtkSignalRunType    signal_flags,GtkSignalMarshaller marshaller,GtkType	       return_val,guint	       nparams,GtkType	      *params
</FUNCTION>
<FUNCTION>
<NAME>gtk_object_new</NAME>
<RETURNS>GtkObject *</RETURNS>
GtkType	       type,const gchar	      *first_arg_name,...
</FUNCTION>
<FUNCTION>
<NAME>gtk_object_newv</NAME>
<RETURNS>GtkObject *</RETURNS>
GtkType	       object_type,guint	       n_args,GtkArg	      *args
</FUNCTION>
<FUNCTION>
<NAME>gtk_object_default_construct</NAME>
<RETURNS>void  </RETURNS>
GtkObject	      *object
</FUNCTION>
<FUNCTION>
<NAME>gtk_object_constructed</NAME>
<RETURNS>void  </RETURNS>
GtkObject	      *object
</FUNCTION>
<FUNCTION>
<NAME>gtk_object_sink</NAME>
<RETURNS>void  </RETURNS>
GtkObject	    *object
</FUNCTION>
<FUNCTION>
<NAME>gtk_object_ref</NAME>
<RETURNS>void  </RETURNS>
GtkObject	    *object
</FUNCTION>
<FUNCTION>
<NAME>gtk_object_unref</NAME>
<RETURNS>void  </RETURNS>
GtkObject	    *object
</FUNCTION>
<FUNCTION>
<NAME>gtk_object_weakref</NAME>
<RETURNS>void  </RETURNS>
GtkObject	    *object,GtkDestroyNotify  notify,gpointer	     data
</FUNCTION>
<FUNCTION>
<NAME>gtk_object_weakunref</NAME>
<RETURNS>void  </RETURNS>
GtkObject	    *object,GtkDestroyNotify  notify,gpointer	     data
</FUNCTION>
<FUNCTION>
<NAME>gtk_object_destroy</NAME>
<RETURNS>void  </RETURNS>
GtkObject *object
</FUNCTION>
<FUNCTION>
<NAME>gtk_object_getv</NAME>
<RETURNS>void 	</RETURNS>
GtkObject	*object,guint		n_args,GtkArg		*args
</FUNCTION>
<FUNCTION>
<NAME>gtk_object_get</NAME>
<RETURNS>void 	</RETURNS>
GtkObject	*object,const gchar	*first_arg_name,...
</FUNCTION>
<FUNCTION>
<NAME>gtk_object_set</NAME>
<RETURNS>void 	</RETURNS>
GtkObject	*object,const gchar	*first_arg_name,...
</FUNCTION>
<FUNCTION>
<NAME>gtk_object_setv</NAME>
<RETURNS>void 	</RETURNS>
GtkObject	*object,guint		n_args,GtkArg		*args
</FUNCTION>
<FUNCTION>
<NAME>gtk_object_query_args</NAME>
<RETURNS>GtkArg *</RETURNS>
GtkType	  class_type,guint32	**arg_flags,guint		 *n_args
</FUNCTION>
<FUNCTION>
<NAME>gtk_object_set_data</NAME>
<RETURNS>void 	</RETURNS>
GtkObject	     *object,const gchar    *key,gpointer	      data
</FUNCTION>
<FUNCTION>
<NAME>gtk_object_set_data_full</NAME>
<RETURNS>void 	</RETURNS>
GtkObject	     *object,const gchar    *key,gpointer	      data,GtkDestroyNotify destroy
</FUNCTION>
<FUNCTION>
<NAME>gtk_object_remove_data</NAME>
<RETURNS>void 	</RETURNS>
GtkObject	     *object,const gchar    *key
</FUNCTION>
<FUNCTION>
<NAME>gtk_object_get_data</NAME>
<RETURNS>gpointer  </RETURNS>
GtkObject	     *object,const gchar    *key
</FUNCTION>
<FUNCTION>
<NAME>gtk_object_remove_no_notify</NAME>
<RETURNS>void 	</RETURNS>
GtkObject	     *object,const gchar    *key
</FUNCTION>
<FUNCTION>
<NAME>gtk_object_set_user_data</NAME>
<RETURNS>void 	</RETURNS>
GtkObject	*object,gpointer	 data
</FUNCTION>
<FUNCTION>
<NAME>gtk_object_get_user_data</NAME>
<RETURNS>gpointer  </RETURNS>
GtkObject	*object
</FUNCTION>
<FUNCTION>
<NAME>gtk_object_class_add_signals</NAME>
<RETURNS>void 	</RETURNS>
GtkObjectClass	*klass,guint		*signals,guint		 nsignals
</FUNCTION>
<FUNCTION>
<NAME>gtk_object_add_arg_type</NAME>
<RETURNS>void 	</RETURNS>
const gchar	*arg_name,GtkType	 arg_type,guint		 arg_flags,guint		 arg_id
</FUNCTION>
<FUNCTION>
<NAME>gtk_object_set_data_by_id</NAME>
<RETURNS>void  </RETURNS>
GtkObject	 *object,GQuark		  data_id,gpointer	  data
</FUNCTION>
<FUNCTION>
<NAME>gtk_object_set_data_by_id_full</NAME>
<RETURNS>void  </RETURNS>
GtkObject	 *object,GQuark		  data_id,gpointer	  data,GtkDestroyNotify destroy
</FUNCTION>
<FUNCTION>
<NAME>gtk_object_get_data_by_id</NAME>
<RETURNS>gpointer  </RETURNS>
GtkObject	 *object,GQuark		  data_id
</FUNCTION>
<FUNCTION>
<NAME>gtk_object_remove_data_by_id</NAME>
<RETURNS>void  </RETURNS>
GtkObject	 *object,GQuark		  data_id
</FUNCTION>
<FUNCTION>
<NAME>gtk_object_remove_no_notify_by_id</NAME>
<RETURNS>void  </RETURNS>
GtkObject	 *object,GQuark		  key_id
</FUNCTION>
<MACRO>
<NAME>gtk_object_data_try_key</NAME>
#define	gtk_object_data_try_key	    g_quark_try_string
</MACRO>
<MACRO>
<NAME>gtk_object_data_force_id</NAME>
#define	gtk_object_data_force_id    g_quark_from_string
</MACRO>
<FUNCTION>
<NAME>gtk_object_arg_set</NAME>
<RETURNS>void 	</RETURNS>
GtkObject   *object,GtkArg	     *arg,GtkArgInfo  *info
</FUNCTION>
<FUNCTION>
<NAME>gtk_object_arg_get</NAME>
<RETURNS>void 	</RETURNS>
GtkObject   *object,GtkArg	     *arg,GtkArgInfo  *info
</FUNCTION>
<FUNCTION>
<NAME>gtk_object_args_collect</NAME>
<RETURNS>gchar *</RETURNS>
GtkType      object_type,GSList	    **arg_list_p,GSList	    **info_list_p,const gchar *first_arg_name,va_list      var_args
</FUNCTION>
<FUNCTION>
<NAME>gtk_object_arg_get_info</NAME>
<RETURNS>gchar *</RETURNS>
GtkType      object_type,const gchar *arg_name,GtkArgInfo **info_p
</FUNCTION>
<FUNCTION>
<NAME>gtk_trace_referencing</NAME>
<RETURNS>void 	</RETURNS>
GtkObject   *object,const gchar *func,guint	      dummy,guint	      line,gboolean     do_ref
</FUNCTION>
<MACRO>
<NAME>gtk_object_ref</NAME>
#  define gtk_object_ref(o)   G_STMT_START{gtk_trace_referencing((o),G_GNUC_PRETTY_FUNCTION,0,__LINE__,1);}G_STMT_END
</MACRO>
<MACRO>
<NAME>gtk_object_unref</NAME>
#  define gtk_object_unref(o) G_STMT_START{gtk_trace_referencing((o),G_GNUC_PRETTY_FUNCTION,0,__LINE__,0);}G_STMT_END
</MACRO>
<MACRO>
<NAME>GTK_TYPE_OPTION_MENU</NAME>
#define GTK_TYPE_OPTION_MENU              (gtk_option_menu_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_OPTION_MENU</NAME>
#define GTK_OPTION_MENU(obj)              (GTK_CHECK_CAST ((obj), GTK_TYPE_OPTION_MENU, GtkOptionMenu))
</MACRO>
<MACRO>
<NAME>GTK_OPTION_MENU_CLASS</NAME>
#define GTK_OPTION_MENU_CLASS(klass)      (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_OPTION_MENU, GtkOptionMenuClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_OPTION_MENU</NAME>
#define GTK_IS_OPTION_MENU(obj)           (GTK_CHECK_TYPE ((obj), GTK_TYPE_OPTION_MENU))
</MACRO>
<MACRO>
<NAME>GTK_IS_OPTION_MENU_CLASS</NAME>
#define GTK_IS_OPTION_MENU_CLASS(klass)   (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_OPTION_MENU))
</MACRO>
<STRUCT>
<NAME>GtkOptionMenu</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkOptionMenuClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkOptionMenu</NAME>
struct GtkOptionMenu
{
  GtkButton button;
  
  GtkWidget *menu;
  GtkWidget *menu_item;
  
  guint16 width;
  guint16 height;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_option_menu_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_option_menu_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_option_menu_get_menu</NAME>
<RETURNS>GtkWidget *</RETURNS>
GtkOptionMenu *option_menu
</FUNCTION>
<FUNCTION>
<NAME>gtk_option_menu_set_menu</NAME>
<RETURNS>void  </RETURNS>
GtkOptionMenu *option_menu,GtkWidget     *menu
</FUNCTION>
<FUNCTION>
<NAME>gtk_option_menu_remove_menu</NAME>
<RETURNS>void  </RETURNS>
GtkOptionMenu *option_menu
</FUNCTION>
<FUNCTION>
<NAME>gtk_option_menu_set_history</NAME>
<RETURNS>void  </RETURNS>
GtkOptionMenu *option_menu,guint          index
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_PACKER</NAME>
#define GTK_TYPE_PACKER            (gtk_packer_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_PACKER</NAME>
#define GTK_PACKER(obj)            (GTK_CHECK_CAST ((obj), GTK_TYPE_PACKER, GtkPacker))
</MACRO>
<MACRO>
<NAME>GTK_PACKER_CLASS</NAME>
#define GTK_PACKER_CLASS(klass)    (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_PACKER, GtkPackerClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_PACKER</NAME>
#define GTK_IS_PACKER(obj)         (GTK_CHECK_TYPE ((obj), GTK_TYPE_PACKER))
</MACRO>
<MACRO>
<NAME>GTK_IS_PACKER_CLASS</NAME>
#define GTK_IS_PACKER_CLASS(klass) (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_PACKER))
</MACRO>
<STRUCT>
<NAME>GtkPacker</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkPackerClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkPackerChild</NAME>
</STRUCT>
<ENUM>
<NAME>GtkPackerOptions</NAME>
typedef enum
{
    GTK_PACK_EXPAND   = 1 << 0,	/*< nick=expand >*/
    GTK_FILL_X        = 1 << 1,
    GTK_FILL_Y        = 1 << 2
} GtkPackerOptions;
</ENUM>
<ENUM>
<NAME>GtkSideType</NAME>
typedef enum
{
    GTK_SIDE_TOP,
    GTK_SIDE_BOTTOM,
    GTK_SIDE_LEFT,
    GTK_SIDE_RIGHT
} GtkSideType;
</ENUM>
<ENUM>
<NAME>GtkAnchorType</NAME>
typedef enum
{
  GTK_ANCHOR_CENTER,
  GTK_ANCHOR_NORTH,
  GTK_ANCHOR_NORTH_WEST,
  GTK_ANCHOR_NORTH_EAST,
  GTK_ANCHOR_SOUTH,
  GTK_ANCHOR_SOUTH_WEST,
  GTK_ANCHOR_SOUTH_EAST,
  GTK_ANCHOR_WEST,
  GTK_ANCHOR_EAST,
  GTK_ANCHOR_N	=	GTK_ANCHOR_NORTH,
  GTK_ANCHOR_NW	=	GTK_ANCHOR_NORTH_WEST,
  GTK_ANCHOR_NE	=	GTK_ANCHOR_NORTH_EAST,
  GTK_ANCHOR_S	=	GTK_ANCHOR_SOUTH,
  GTK_ANCHOR_SW	=	GTK_ANCHOR_SOUTH_WEST,
  GTK_ANCHOR_SE	=	GTK_ANCHOR_SOUTH_EAST,
  GTK_ANCHOR_W	=	GTK_ANCHOR_WEST,
  GTK_ANCHOR_E	=	GTK_ANCHOR_EAST
} GtkAnchorType;
</ENUM>
<STRUCT>
<NAME>GtkPackerChild</NAME>
struct GtkPackerChild
{
  GtkWidget *widget;
  
  GtkAnchorType anchor;
  GtkSideType side;
  GtkPackerOptions options;
  
  guint use_default : 1;
  
  guint border_width : 16;
  guint pad_x : 16;
  guint pad_y : 16;
  guint i_pad_x : 16;
  guint i_pad_y : 16;
};
</STRUCT>
<STRUCT>
<NAME>GtkPacker</NAME>
struct GtkPacker
{
  GtkContainer parent;
  
  GList *children;
  
  guint spacing;
  
  guint default_border_width : 16;
  guint default_pad_x : 16;
  guint default_pad_y : 16;
  guint default_i_pad_x : 16;
  guint default_i_pad_y : 16;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_packer_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_packer_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_packer_add_defaults</NAME>
<RETURNS>void  </RETURNS>
GtkPacker       *packer,GtkWidget       *child,GtkSideType      side,GtkAnchorType    anchor,GtkPackerOptions options
</FUNCTION>
<FUNCTION>
<NAME>gtk_packer_add</NAME>
<RETURNS>void  </RETURNS>
GtkPacker       *packer,GtkWidget       *child,GtkSideType      side,GtkAnchorType    anchor,GtkPackerOptions options,guint		 border_width,guint		 pad_x,guint		 pad_y,guint		 i_pad_x,guint		 i_pad_y
</FUNCTION>
<FUNCTION>
<NAME>gtk_packer_set_child_packing</NAME>
<RETURNS>void  </RETURNS>
GtkPacker	*packer,GtkWidget       *child,GtkSideType      side,GtkAnchorType    anchor,GtkPackerOptions options,guint		 border_width,guint		 pad_x,guint		 pad_y,guint		 i_pad_x,guint		 i_pad_y
</FUNCTION>
<FUNCTION>
<NAME>gtk_packer_reorder_child</NAME>
<RETURNS>void 	</RETURNS>
GtkPacker	*packer,GtkWidget	*child,gint             position
</FUNCTION>
<FUNCTION>
<NAME>gtk_packer_set_spacing</NAME>
<RETURNS>void  </RETURNS>
GtkPacker	*packer,guint		 spacing
</FUNCTION>
<FUNCTION>
<NAME>gtk_packer_set_default_border_width</NAME>
<RETURNS>void  </RETURNS>
GtkPacker	*packer,guint		 border
</FUNCTION>
<FUNCTION>
<NAME>gtk_packer_set_default_pad</NAME>
<RETURNS>void  </RETURNS>
GtkPacker	*packer,guint             pad_x,guint             pad_y
</FUNCTION>
<FUNCTION>
<NAME>gtk_packer_set_default_ipad</NAME>
<RETURNS>void  </RETURNS>
GtkPacker	*packer,guint            i_pad_x,guint            i_pad_y
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_PANED</NAME>
#define GTK_TYPE_PANED                  (gtk_paned_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_PANED</NAME>
#define GTK_PANED(obj)                  (GTK_CHECK_CAST ((obj), GTK_TYPE_PANED, GtkPaned))
</MACRO>
<MACRO>
<NAME>GTK_PANED_CLASS</NAME>
#define GTK_PANED_CLASS(klass)          (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_PANED, GtkPanedClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_PANED</NAME>
#define GTK_IS_PANED(obj)               (GTK_CHECK_TYPE ((obj), GTK_TYPE_PANED))
</MACRO>
<MACRO>
<NAME>GTK_IS_PANED_CLASS</NAME>
#define GTK_IS_PANED_CLASS(klass)       (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_PANED))
</MACRO>
<STRUCT>
<NAME>GtkPaned</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkPanedClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkPaned</NAME>
struct GtkPaned
{
  GtkContainer container;
  
  GtkWidget *child1;
  GtkWidget *child2;
  
  GdkWindow *handle;
  GdkRectangle groove_rectangle;
  GdkGC *xor_gc;

  /*< public >*/
  guint16 handle_size;
  guint16 gutter_size;

  /*< private >*/
  gint child1_size;
  gint last_allocation;
  gint min_position;
  gint max_position;
  
  guint position_set : 1;
  guint in_drag : 1;
  guint child1_shrink : 1;
  guint child1_resize : 1;
  guint child2_shrink : 1;
  guint child2_resize : 1;
  
  gint16 handle_xpos;
  gint16 handle_ypos;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_paned_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_paned_add1</NAME>
<RETURNS>void  </RETURNS>
GtkPaned  *paned,GtkWidget *child
</FUNCTION>
<FUNCTION>
<NAME>gtk_paned_add2</NAME>
<RETURNS>void  </RETURNS>
GtkPaned  *paned,GtkWidget *child
</FUNCTION>
<FUNCTION>
<NAME>gtk_paned_pack1</NAME>
<RETURNS>void  </RETURNS>
GtkPaned  *paned,GtkWidget *child,gboolean   resize,gboolean   shrink
</FUNCTION>
<FUNCTION>
<NAME>gtk_paned_pack2</NAME>
<RETURNS>void  </RETURNS>
GtkPaned  *paned,GtkWidget *child,gboolean   resize,gboolean   shrink
</FUNCTION>
<FUNCTION>
<NAME>gtk_paned_set_position</NAME>
<RETURNS>void  </RETURNS>
GtkPaned  *paned,gint       position
</FUNCTION>
<FUNCTION>
<NAME>gtk_paned_set_handle_size</NAME>
<RETURNS>void  </RETURNS>
GtkPaned *paned,guint16   size
</FUNCTION>
<FUNCTION>
<NAME>gtk_paned_set_gutter_size</NAME>
<RETURNS>void  </RETURNS>
GtkPaned *paned,guint16   size
</FUNCTION>
<FUNCTION>
<NAME>gtk_paned_compute_position</NAME>
<RETURNS>void  </RETURNS>
GtkPaned *paned,gint      allocation,gint      child1_req,gint      child2_req
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_PIXMAP</NAME>
#define GTK_TYPE_PIXMAP			 (gtk_pixmap_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_PIXMAP</NAME>
#define GTK_PIXMAP(obj)			 (GTK_CHECK_CAST ((obj), GTK_TYPE_PIXMAP, GtkPixmap))
</MACRO>
<MACRO>
<NAME>GTK_PIXMAP_CLASS</NAME>
#define GTK_PIXMAP_CLASS(klass)		 (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_PIXMAP, GtkPixmapClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_PIXMAP</NAME>
#define GTK_IS_PIXMAP(obj)		 (GTK_CHECK_TYPE ((obj), GTK_TYPE_PIXMAP))
</MACRO>
<MACRO>
<NAME>GTK_IS_PIXMAP_CLASS</NAME>
#define GTK_IS_PIXMAP_CLASS(klass)	 (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_PIXMAP))
</MACRO>
<STRUCT>
<NAME>GtkPixmap</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkPixmapClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkPixmap</NAME>
struct GtkPixmap
{
  GtkMisc misc;
  
  GdkPixmap *pixmap;
  GdkBitmap *mask;

  GdkPixmap *pixmap_insensitive;
  guint build_insensitive : 1;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_pixmap_get_type</NAME>
<RETURNS>GtkType 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_pixmap_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GdkPixmap  *pixmap,GdkBitmap  *mask
</FUNCTION>
<FUNCTION>
<NAME>gtk_pixmap_set</NAME>
<RETURNS>void 	</RETURNS>
GtkPixmap  *pixmap,GdkPixmap  *val,GdkBitmap  *mask
</FUNCTION>
<FUNCTION>
<NAME>gtk_pixmap_get</NAME>
<RETURNS>void 	</RETURNS>
GtkPixmap  *pixmap,GdkPixmap **val,GdkBitmap **mask
</FUNCTION>
<FUNCTION>
<NAME>gtk_pixmap_set_build_insensitive</NAME>
<RETURNS>void  </RETURNS>
GtkPixmap *pixmap,guint build
</FUNCTION>
<MACRO>
<NAME>GTK_PLUG</NAME>
#define GTK_PLUG(obj)          GTK_CHECK_CAST (obj, gtk_plug_get_type (), GtkPlug)
</MACRO>
<MACRO>
<NAME>GTK_PLUG_CLASS</NAME>
#define GTK_PLUG_CLASS(klass)  GTK_CHECK_CLASS_CAST (klass, gtk_plug_get_type (), GtkPlugClass)
</MACRO>
<MACRO>
<NAME>GTK_IS_PLUG</NAME>
#define GTK_IS_PLUG(obj)       GTK_CHECK_TYPE (obj, gtk_plug_get_type ())
</MACRO>
<STRUCT>
<NAME>GtkPlug</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkPlugClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkPlug</NAME>
struct GtkPlug
{
  GtkWindow window;

  GdkWindow *socket_window;
  gint same_app;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_plug_get_type</NAME>
<RETURNS>guint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_plug_construct</NAME>
<RETURNS>void  </RETURNS>
GtkPlug *plug, guint32 socket_id
</FUNCTION>
<FUNCTION>
<NAME>gtk_plug_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
guint32 socket_id
</FUNCTION>
<MACRO>
<NAME>GTK_PREVIEW</NAME>
#define GTK_PREVIEW(obj)          GTK_CHECK_CAST (obj, gtk_preview_get_type (), GtkPreview)
</MACRO>
<MACRO>
<NAME>GTK_PREVIEW_CLASS</NAME>
#define GTK_PREVIEW_CLASS(klass)  GTK_CHECK_CLASS_CAST (klass, gtk_preview_get_type (), GtkPreviewClass)
</MACRO>
<MACRO>
<NAME>GTK_IS_PREVIEW</NAME>
#define GTK_IS_PREVIEW(obj)       GTK_CHECK_TYPE (obj, gtk_preview_get_type ())
</MACRO>
<STRUCT>
<NAME>GtkPreview</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkPreviewInfo</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkPreviewClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkPreview</NAME>
struct GtkPreview
{
  GtkWidget widget;

  guchar *buffer;
  guint16 buffer_width;
  guint16 buffer_height;

  guint16 bpp;
  guint16 rowstride;

  GdkRgbDither dither;

  guint type : 1;
  guint expand : 1;
};
</STRUCT>
<STRUCT>
<NAME>GtkPreviewInfo</NAME>
struct GtkPreviewInfo
{
  GdkVisual *visual;
  GdkColormap *cmap;

  guchar *lookup;

  gdouble gamma;
};
</STRUCT>
<UNION>
<NAME>GtkDitherInfo</NAME>
union GtkDitherInfo
{
  gushort s[2];
  guchar c[4];
};
</UNION>
<FUNCTION>
<NAME>gtk_preview_get_type</NAME>
<RETURNS>guint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_preview_uninit</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_preview_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GtkPreviewType   type
</FUNCTION>
<FUNCTION>
<NAME>gtk_preview_size</NAME>
<RETURNS>void  </RETURNS>
GtkPreview      *preview,gint             width,gint             height
</FUNCTION>
<FUNCTION>
<NAME>gtk_preview_put</NAME>
<RETURNS>void  </RETURNS>
GtkPreview      *preview,GdkWindow       *window,GdkGC           *gc,gint             srcx,gint             srcy,gint             destx,gint             desty,gint             width,gint             height
</FUNCTION>
<FUNCTION>
<NAME>gtk_preview_draw_row</NAME>
<RETURNS>void  </RETURNS>
GtkPreview      *preview,guchar          *data,gint             x,gint             y,gint             w
</FUNCTION>
<FUNCTION>
<NAME>gtk_preview_set_expand</NAME>
<RETURNS>void  </RETURNS>
GtkPreview      *preview,gint             expand
</FUNCTION>
<FUNCTION>
<NAME>gtk_preview_set_gamma</NAME>
<RETURNS>void  </RETURNS>
double           gamma
</FUNCTION>
<FUNCTION>
<NAME>gtk_preview_set_color_cube</NAME>
<RETURNS>void  </RETURNS>
guint            nred_shades,guint            ngreen_shades,guint            nblue_shades,guint            ngray_shades
</FUNCTION>
<FUNCTION>
<NAME>gtk_preview_set_install_cmap</NAME>
<RETURNS>void  </RETURNS>
gint             install_cmap
</FUNCTION>
<FUNCTION>
<NAME>gtk_preview_set_reserved</NAME>
<RETURNS>void  </RETURNS>
gint             nreserved
</FUNCTION>
<FUNCTION>
<NAME>gtk_preview_set_dither</NAME>
<RETURNS>void  </RETURNS>
GtkPreview      *preview,GdkRgbDither     dither
</FUNCTION>
<FUNCTION>
<NAME>gtk_preview_get_visual</NAME>
<RETURNS>GdkVisual *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_preview_get_cmap</NAME>
<RETURNS>GdkColormap *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_preview_get_info</NAME>
<RETURNS>GtkPreviewInfo *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_preview_reset</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GtkPrivateFlags</NAME>
typedef enum
{
  PRIVATE_GTK_USER_STYLE	= 1 <<  0,
  PRIVATE_GTK_REDRAW_PENDING	= 1 <<  1,
  PRIVATE_GTK_RESIZE_PENDING	= 1 <<  2,
  PRIVATE_GTK_RESIZE_NEEDED	= 1 <<  3,
  PRIVATE_GTK_LEAVE_PENDING	= 1 <<  4,
  PRIVATE_GTK_HAS_SHAPE_MASK	= 1 <<  5,
  PRIVATE_GTK_IN_REPARENT       = 1 <<  6,
  PRIVATE_GTK_IS_OFFSCREEN      = 1 <<  7
} GtkPrivateFlags;
</ENUM>
<MACRO>
<NAME>GTK_PRIVATE_FLAGS</NAME>
#define GTK_PRIVATE_FLAGS(wid)            (GTK_WIDGET (wid)->private_flags)
</MACRO>
<MACRO>
<NAME>GTK_WIDGET_USER_STYLE</NAME>
#define GTK_WIDGET_USER_STYLE(obj)	  ((GTK_PRIVATE_FLAGS (obj) & PRIVATE_GTK_USER_STYLE) != 0)
</MACRO>
<MACRO>
<NAME>GTK_WIDGET_REDRAW_PENDING</NAME>
#define GTK_WIDGET_REDRAW_PENDING(obj)	  ((GTK_PRIVATE_FLAGS (obj) & PRIVATE_GTK_REDRAW_PENDING) != 0)
</MACRO>
<MACRO>
<NAME>GTK_CONTAINER_RESIZE_PENDING</NAME>
#define GTK_CONTAINER_RESIZE_PENDING(obj) ((GTK_PRIVATE_FLAGS (obj) & PRIVATE_GTK_RESIZE_PENDING) != 0)
</MACRO>
<MACRO>
<NAME>GTK_WIDGET_RESIZE_NEEDED</NAME>
#define GTK_WIDGET_RESIZE_NEEDED(obj)	  ((GTK_PRIVATE_FLAGS (obj) & PRIVATE_GTK_RESIZE_NEEDED) != 0)
</MACRO>
<MACRO>
<NAME>GTK_WIDGET_LEAVE_PENDING</NAME>
#define GTK_WIDGET_LEAVE_PENDING(obj)	  ((GTK_PRIVATE_FLAGS (obj) & PRIVATE_GTK_LEAVE_PENDING) != 0)
</MACRO>
<MACRO>
<NAME>GTK_WIDGET_HAS_SHAPE_MASK</NAME>
#define GTK_WIDGET_HAS_SHAPE_MASK(obj)	  ((GTK_PRIVATE_FLAGS (obj) & PRIVATE_GTK_HAS_SHAPE_MASK) != 0)
</MACRO>
<MACRO>
<NAME>GTK_WIDGET_IN_REPARENT</NAME>
#define GTK_WIDGET_IN_REPARENT(obj)	  ((GTK_PRIVATE_FLAGS (obj) & PRIVATE_GTK_IN_REPARENT) != 0)
</MACRO>
<MACRO>
<NAME>GTK_WIDGET_IS_OFFSCREEN</NAME>
#define GTK_WIDGET_IS_OFFSCREEN(obj)	  ((GTK_PRIVATE_FLAGS (obj) & PRIVATE_GTK_IS_OFFSCREEN) != 0)
</MACRO>
<MACRO>
<NAME>GTK_PRIVATE_SET_FLAG</NAME>
#define GTK_PRIVATE_SET_FLAG(wid,flag)    G_STMT_START{ (GTK_PRIVATE_FLAGS (wid) |= (PRIVATE_ ## flag)); }G_STMT_END
</MACRO>
<MACRO>
<NAME>GTK_PRIVATE_UNSET_FLAG</NAME>
#define GTK_PRIVATE_UNSET_FLAG(wid,flag)  G_STMT_START{ (GTK_PRIVATE_FLAGS (wid) &= ~(PRIVATE_ ## flag)); }G_STMT_END
</MACRO>
<MACRO>
<NAME>GTK_TYPE_PROGRESS</NAME>
#define GTK_TYPE_PROGRESS            (gtk_progress_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_PROGRESS</NAME>
#define GTK_PROGRESS(obj)            (GTK_CHECK_CAST ((obj), GTK_TYPE_PROGRESS, GtkProgress))
</MACRO>
<MACRO>
<NAME>GTK_PROGRESS_CLASS</NAME>
#define GTK_PROGRESS_CLASS(klass)    (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_PROGRESS, GtkProgressClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_PROGRESS</NAME>
#define GTK_IS_PROGRESS(obj)         (GTK_CHECK_TYPE ((obj), GTK_TYPE_PROGRESS))
</MACRO>
<MACRO>
<NAME>GTK_IS_PROGRESS_CLASS</NAME>
#define GTK_IS_PROGRESS_CLASS(klass) (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_PROGRESS))
</MACRO>
<STRUCT>
<NAME>GtkProgress</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkProgressClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkProgress</NAME>
struct GtkProgress
{
  GtkWidget widget;

  GtkAdjustment *adjustment;
  GdkPixmap     *offscreen_pixmap;
  gchar         *format;
  gfloat         x_align;
  gfloat         y_align;

  guint          show_text : 1;
  guint          activity_mode : 1;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_progress_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_progress_set_show_text</NAME>
<RETURNS>void  </RETURNS>
GtkProgress   *progress,gint           show_text
</FUNCTION>
<FUNCTION>
<NAME>gtk_progress_set_text_alignment</NAME>
<RETURNS>void  </RETURNS>
GtkProgress   *progress,gfloat         x_align,gfloat         y_align
</FUNCTION>
<FUNCTION>
<NAME>gtk_progress_set_format_string</NAME>
<RETURNS>void  </RETURNS>
GtkProgress   *progress,gchar         *format
</FUNCTION>
<FUNCTION>
<NAME>gtk_progress_set_adjustment</NAME>
<RETURNS>void  </RETURNS>
GtkProgress   *progress,GtkAdjustment *adjustment
</FUNCTION>
<FUNCTION>
<NAME>gtk_progress_configure</NAME>
<RETURNS>void  </RETURNS>
GtkProgress   *progress,gfloat         value,gfloat         min,gfloat         max
</FUNCTION>
<FUNCTION>
<NAME>gtk_progress_set_percentage</NAME>
<RETURNS>void  </RETURNS>
GtkProgress   *progress,gfloat         percentage
</FUNCTION>
<FUNCTION>
<NAME>gtk_progress_set_value</NAME>
<RETURNS>void  </RETURNS>
GtkProgress   *progress,gfloat         value
</FUNCTION>
<FUNCTION>
<NAME>gtk_progress_get_value</NAME>
<RETURNS>gfloat  </RETURNS>
GtkProgress   *progress
</FUNCTION>
<FUNCTION>
<NAME>gtk_progress_set_activity_mode</NAME>
<RETURNS>void  </RETURNS>
GtkProgress   *progress,guint          activity_mode
</FUNCTION>
<FUNCTION>
<NAME>gtk_progress_get_current_text</NAME>
<RETURNS>gchar *</RETURNS>
GtkProgress   *progress
</FUNCTION>
<FUNCTION>
<NAME>gtk_progress_get_text_from_value</NAME>
<RETURNS>gchar *</RETURNS>
GtkProgress   *progress,gfloat         value
</FUNCTION>
<FUNCTION>
<NAME>gtk_progress_get_current_percentage</NAME>
<RETURNS>gfloat  </RETURNS>
GtkProgress *progress
</FUNCTION>
<FUNCTION>
<NAME>gtk_progress_get_percentage_from_value</NAME>
<RETURNS>gfloat  </RETURNS>
GtkProgress *progress,gfloat       value
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_PROGRESS_BAR</NAME>
#define GTK_TYPE_PROGRESS_BAR            (gtk_progress_bar_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_PROGRESS_BAR</NAME>
#define GTK_PROGRESS_BAR(obj)            (GTK_CHECK_CAST ((obj), GTK_TYPE_PROGRESS_BAR, GtkProgressBar))
</MACRO>
<MACRO>
<NAME>GTK_PROGRESS_BAR_CLASS</NAME>
#define GTK_PROGRESS_BAR_CLASS(klass)    (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_PROGRESS_BAR, GtkProgressBarClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_PROGRESS_BAR</NAME>
#define GTK_IS_PROGRESS_BAR(obj)         (GTK_CHECK_TYPE ((obj), GTK_TYPE_PROGRESS_BAR))
</MACRO>
<MACRO>
<NAME>GTK_IS_PROGRESS_BAR_CLASS</NAME>
#define GTK_IS_PROGRESS_BAR_CLASS(klass) (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_PROGRESS_BAR))
</MACRO>
<STRUCT>
<NAME>GtkProgressBar</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkProgressBarClass</NAME>
</STRUCT>
<ENUM>
<NAME>GtkProgressBarStyle</NAME>
typedef enum
{
  GTK_PROGRESS_CONTINUOUS,
  GTK_PROGRESS_DISCRETE
} GtkProgressBarStyle;
</ENUM>
<ENUM>
<NAME>GtkProgressBarOrientation</NAME>
typedef enum
{
  GTK_PROGRESS_LEFT_TO_RIGHT,
  GTK_PROGRESS_RIGHT_TO_LEFT,
  GTK_PROGRESS_BOTTOM_TO_TOP,
  GTK_PROGRESS_TOP_TO_BOTTOM
} GtkProgressBarOrientation;
</ENUM>
<STRUCT>
<NAME>GtkProgressBar</NAME>
struct GtkProgressBar
{
  GtkProgress progress;

  GtkProgressBarStyle bar_style;
  GtkProgressBarOrientation orientation;

  guint blocks;
  gint  in_block;

  gint  activity_pos;
  guint activity_step;
  guint activity_blocks;
  guint activity_dir : 1;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_progress_bar_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_progress_bar_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_progress_bar_new_with_adjustment</NAME>
<RETURNS>GtkWidget *</RETURNS>
GtkAdjustment  *adjustment
</FUNCTION>
<FUNCTION>
<NAME>gtk_progress_bar_set_bar_style</NAME>
<RETURNS>void  </RETURNS>
GtkProgressBar *pbar,GtkProgressBarStyle style
</FUNCTION>
<FUNCTION>
<NAME>gtk_progress_bar_set_discrete_blocks</NAME>
<RETURNS>void  </RETURNS>
GtkProgressBar *pbar,guint           blocks
</FUNCTION>
<FUNCTION>
<NAME>gtk_progress_bar_set_activity_step</NAME>
<RETURNS>void  </RETURNS>
GtkProgressBar *pbar,guint           step
</FUNCTION>
<FUNCTION>
<NAME>gtk_progress_bar_set_activity_blocks</NAME>
<RETURNS>void  </RETURNS>
GtkProgressBar *pbar,guint           blocks
</FUNCTION>
<FUNCTION>
<NAME>gtk_progress_bar_set_orientation</NAME>
<RETURNS>void  </RETURNS>
GtkProgressBar *pbar,GtkProgressBarOrientation orientation
</FUNCTION>
<FUNCTION>
<NAME>gtk_progress_bar_update</NAME>
<RETURNS>void  </RETURNS>
GtkProgressBar *pbar,gfloat          percentage
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_RADIO_BUTTON</NAME>
#define GTK_TYPE_RADIO_BUTTON		       (gtk_radio_button_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_RADIO_BUTTON</NAME>
#define GTK_RADIO_BUTTON(obj)		       (GTK_CHECK_CAST ((obj), GTK_TYPE_RADIO_BUTTON, GtkRadioButton))
</MACRO>
<MACRO>
<NAME>GTK_RADIO_BUTTON_CLASS</NAME>
#define GTK_RADIO_BUTTON_CLASS(klass)	       (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_RADIO_BUTTON, GtkRadioButtonClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_RADIO_BUTTON</NAME>
#define GTK_IS_RADIO_BUTTON(obj)	       (GTK_CHECK_TYPE ((obj), GTK_TYPE_RADIO_BUTTON))
</MACRO>
<MACRO>
<NAME>GTK_IS_RADIO_BUTTON_CLASS</NAME>
#define GTK_IS_RADIO_BUTTON_CLASS(klass)       (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_RADIO_BUTTON))
</MACRO>
<STRUCT>
<NAME>GtkRadioButton</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkRadioButtonClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkRadioButton</NAME>
struct GtkRadioButton
{
  GtkCheckButton check_button;
  
  GSList *group;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_radio_button_get_type</NAME>
<RETURNS>GtkType 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_radio_button_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GSList	     *group
</FUNCTION>
<FUNCTION>
<NAME>gtk_radio_button_new_from_widget</NAME>
<RETURNS>GtkWidget *</RETURNS>
GtkRadioButton *group
</FUNCTION>
<FUNCTION>
<NAME>gtk_radio_button_new_with_label</NAME>
<RETURNS>GtkWidget *</RETURNS>
GSList	     *group,const gchar    *label
</FUNCTION>
<FUNCTION>
<NAME>gtk_radio_button_new_with_label_from_widget</NAME>
<RETURNS>GtkWidget *</RETURNS>
GtkRadioButton *group,const gchar	*label
</FUNCTION>
<FUNCTION>
<NAME>gtk_radio_button_group</NAME>
<RETURNS>GSList *</RETURNS>
GtkRadioButton *radio_button
</FUNCTION>
<FUNCTION>
<NAME>gtk_radio_button_set_group</NAME>
<RETURNS>void 	</RETURNS>
GtkRadioButton *radio_button,GSList	     *group
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_RADIO_MENU_ITEM</NAME>
#define GTK_TYPE_RADIO_MENU_ITEM	      (gtk_radio_menu_item_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_RADIO_MENU_ITEM</NAME>
#define GTK_RADIO_MENU_ITEM(obj)	      (GTK_CHECK_CAST ((obj), GTK_TYPE_RADIO_MENU_ITEM, GtkRadioMenuItem))
</MACRO>
<MACRO>
<NAME>GTK_RADIO_MENU_ITEM_CLASS</NAME>
#define GTK_RADIO_MENU_ITEM_CLASS(klass)      (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_RADIO_MENU_ITEM, GtkRadioMenuItemClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_RADIO_MENU_ITEM</NAME>
#define GTK_IS_RADIO_MENU_ITEM(obj)	      (GTK_CHECK_TYPE ((obj), GTK_TYPE_RADIO_MENU_ITEM))
</MACRO>
<MACRO>
<NAME>GTK_IS_RADIO_MENU_ITEM_CLASS</NAME>
#define GTK_IS_RADIO_MENU_ITEM_CLASS(klass)   (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_RADIO_MENU_ITEM))
</MACRO>
<STRUCT>
<NAME>GtkRadioMenuItem</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkRadioMenuItemClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkRadioMenuItem</NAME>
struct GtkRadioMenuItem
{
  GtkCheckMenuItem check_menu_item;
  
  GSList *group;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_radio_menu_item_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_radio_menu_item_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GSList		*group
</FUNCTION>
<FUNCTION>
<NAME>gtk_radio_menu_item_new_with_label</NAME>
<RETURNS>GtkWidget *</RETURNS>
GSList		*group,const gchar	*label
</FUNCTION>
<FUNCTION>
<NAME>gtk_radio_menu_item_group</NAME>
<RETURNS>GSList *</RETURNS>
GtkRadioMenuItem *radio_menu_item
</FUNCTION>
<FUNCTION>
<NAME>gtk_radio_menu_item_set_group</NAME>
<RETURNS>void 	</RETURNS>
GtkRadioMenuItem *radio_menu_item,GSList		*group
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_RANGE</NAME>
#define GTK_TYPE_RANGE            (gtk_range_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_RANGE</NAME>
#define GTK_RANGE(obj)            (GTK_CHECK_CAST ((obj), GTK_TYPE_RANGE, GtkRange))
</MACRO>
<MACRO>
<NAME>GTK_RANGE_CLASS</NAME>
#define GTK_RANGE_CLASS(klass)    (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_RANGE, GtkRangeClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_RANGE</NAME>
#define GTK_IS_RANGE(obj)         (GTK_CHECK_TYPE ((obj), GTK_TYPE_RANGE))
</MACRO>
<MACRO>
<NAME>GTK_IS_RANGE_CLASS</NAME>
#define GTK_IS_RANGE_CLASS(klass) (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_RANGE))
</MACRO>
<STRUCT>
<NAME>GtkRange</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkRangeClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkRange</NAME>
struct GtkRange
{
  GtkWidget widget;

  GdkWindow *trough;
  GdkWindow *slider;
  GdkWindow *step_forw;
  GdkWindow *step_back;

  gint16 x_click_point;
  gint16 y_click_point;

  guint8 button;
  gint8 digits;
  guint policy : 2;
  guint scroll_type : 3;
  guint in_child : 3;
  guint click_child : 3;
  guint need_timer : 1;

  guint32 timer;

  gfloat old_value;
  gfloat old_lower;
  gfloat old_upper;
  gfloat old_page_size;

  GtkAdjustment *adjustment;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_range_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_range_get_adjustment</NAME>
<RETURNS>GtkAdjustment *</RETURNS>
GtkRange      *range
</FUNCTION>
<FUNCTION>
<NAME>gtk_range_set_update_policy</NAME>
<RETURNS>void  </RETURNS>
GtkRange      *range,GtkUpdateType  policy
</FUNCTION>
<FUNCTION>
<NAME>gtk_range_set_adjustment</NAME>
<RETURNS>void  </RETURNS>
GtkRange      *range,GtkAdjustment *adjustment
</FUNCTION>
<FUNCTION>
<NAME>gtk_range_draw_background</NAME>
<RETURNS>void  </RETURNS>
GtkRange      *range
</FUNCTION>
<FUNCTION>
<NAME>gtk_range_clear_background</NAME>
<RETURNS>void  </RETURNS>
GtkRange      *range
</FUNCTION>
<FUNCTION>
<NAME>gtk_range_draw_trough</NAME>
<RETURNS>void  </RETURNS>
GtkRange      *range
</FUNCTION>
<FUNCTION>
<NAME>gtk_range_draw_slider</NAME>
<RETURNS>void  </RETURNS>
GtkRange      *range
</FUNCTION>
<FUNCTION>
<NAME>gtk_range_draw_step_forw</NAME>
<RETURNS>void  </RETURNS>
GtkRange      *range
</FUNCTION>
<FUNCTION>
<NAME>gtk_range_draw_step_back</NAME>
<RETURNS>void  </RETURNS>
GtkRange      *range
</FUNCTION>
<FUNCTION>
<NAME>gtk_range_slider_update</NAME>
<RETURNS>void  </RETURNS>
GtkRange      *range
</FUNCTION>
<FUNCTION>
<NAME>gtk_range_trough_click</NAME>
<RETURNS>gint  </RETURNS>
GtkRange      *range,gint           x,gint           y,gfloat	       *jump_perc
</FUNCTION>
<FUNCTION>
<NAME>gtk_range_default_hslider_update</NAME>
<RETURNS>void  </RETURNS>
GtkRange      *range
</FUNCTION>
<FUNCTION>
<NAME>gtk_range_default_vslider_update</NAME>
<RETURNS>void  </RETURNS>
GtkRange      *range
</FUNCTION>
<FUNCTION>
<NAME>gtk_range_default_htrough_click</NAME>
<RETURNS>gint  </RETURNS>
GtkRange      *range,gint           x,gint           y,gfloat	       *jump_perc
</FUNCTION>
<FUNCTION>
<NAME>gtk_range_default_vtrough_click</NAME>
<RETURNS>gint  </RETURNS>
GtkRange      *range,gint           x,gint           y,gfloat	       *jump_perc
</FUNCTION>
<FUNCTION>
<NAME>gtk_range_default_hmotion</NAME>
<RETURNS>void  </RETURNS>
GtkRange      *range,gint           xdelta,gint           ydelta
</FUNCTION>
<FUNCTION>
<NAME>gtk_range_default_vmotion</NAME>
<RETURNS>void  </RETURNS>
GtkRange      *range,gint           xdelta,gint           ydelta
</FUNCTION>
<ENUM>
<NAME>GtkRcFlags</NAME>
typedef enum {
  GTK_RC_FG   = 1 << 0,
  GTK_RC_BG   = 1 << 1,
  GTK_RC_TEXT = 1 << 2,
  GTK_RC_BASE = 1 << 3
} GtkRcFlags;
</ENUM>
<STRUCT>
<NAME>GtkRcStyle</NAME>
struct GtkRcStyle
{
  gchar *name;
  gchar *font_name;
  gchar *fontset_name;
  gchar *bg_pixmap_name[5];

  GtkRcFlags color_flags[5];
  GdkColor   fg[5];
  GdkColor   bg[5];
  GdkColor   text[5];
  GdkColor   base[5];

  GtkThemeEngine *engine;
  gpointer        engine_data;

  /* Private */
  guint ref_count;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_rc_init</NAME>
<RETURNS>void 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_rc_add_default_file</NAME>
<RETURNS>void  </RETURNS>
const gchar *filename
</FUNCTION>
<FUNCTION>
<NAME>gtk_rc_set_default_files</NAME>
<RETURNS>void  </RETURNS>
gchar **filenames
</FUNCTION>
<FUNCTION>
<NAME>gtk_rc_get_default_files</NAME>
<RETURNS>gchar **</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_rc_parse</NAME>
<RETURNS>void 	</RETURNS>
const gchar *filename
</FUNCTION>
<FUNCTION>
<NAME>gtk_rc_parse_string</NAME>
<RETURNS>void 	</RETURNS>
const gchar *rc_string
</FUNCTION>
<FUNCTION>
<NAME>gtk_rc_reparse_all</NAME>
<RETURNS>gboolean  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_rc_get_style</NAME>
<RETURNS>GtkStyle *</RETURNS>
GtkWidget   *widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_rc_add_widget_name_style</NAME>
<RETURNS>void 	</RETURNS>
GtkRcStyle  *rc_style,const gchar *pattern
</FUNCTION>
<FUNCTION>
<NAME>gtk_rc_add_widget_class_style</NAME>
<RETURNS>void 	</RETURNS>
GtkRcStyle  *rc_style,const gchar *pattern
</FUNCTION>
<FUNCTION>
<NAME>gtk_rc_add_class_style</NAME>
<RETURNS>void 	</RETURNS>
GtkRcStyle  *rc_style,const gchar *pattern
</FUNCTION>
<FUNCTION>
<NAME>gtk_rc_style_new</NAME>
<RETURNS>GtkRcStyle *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_rc_style_ref</NAME>
<RETURNS>void  </RETURNS>
GtkRcStyle  *rc_style
</FUNCTION>
<FUNCTION>
<NAME>gtk_rc_style_unref</NAME>
<RETURNS>void  </RETURNS>
GtkRcStyle  *rc_style
</FUNCTION>
<USER_FUNCTION>
<NAME>GtkImageLoader</NAME>
<RETURNS>GdkPixmap *</RETURNS>
GdkWindow   	*window,
						 GdkColormap 	*colormap,
						 GdkBitmap     **mask,
						 GdkColor    	*transparent_color,
						 const gchar 	*filename
</USER_FUNCTION>
<FUNCTION>
<NAME>gtk_rc_set_image_loader</NAME>
<RETURNS>void 	</RETURNS>
GtkImageLoader	 loader
</FUNCTION>
<FUNCTION>
<NAME>gtk_rc_load_image</NAME>
<RETURNS>GdkPixmap *</RETURNS>
GdkColormap 	*colormap,GdkColor    	*transparent_color,const gchar 	*filename
</FUNCTION>
<FUNCTION>
<NAME>gtk_rc_find_pixmap_in_path</NAME>
<RETURNS>gchar *</RETURNS>
GScanner    	*scanner,const gchar	*pixmap_file
</FUNCTION>
<FUNCTION>
<NAME>gtk_rc_find_module_in_path</NAME>
<RETURNS>gchar *</RETURNS>
const gchar 	*module_file
</FUNCTION>
<FUNCTION>
<NAME>gtk_rc_get_theme_dir</NAME>
<RETURNS>gchar *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_rc_get_module_dir</NAME>
<RETURNS>gchar *</RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GtkRcTokenType</NAME>
typedef enum {
  GTK_RC_TOKEN_INVALID = G_TOKEN_LAST,
  GTK_RC_TOKEN_INCLUDE,
  GTK_RC_TOKEN_NORMAL,
  GTK_RC_TOKEN_ACTIVE,
  GTK_RC_TOKEN_PRELIGHT,
  GTK_RC_TOKEN_SELECTED,
  GTK_RC_TOKEN_INSENSITIVE,
  GTK_RC_TOKEN_FG,
  GTK_RC_TOKEN_BG,
  GTK_RC_TOKEN_BASE,
  GTK_RC_TOKEN_TEXT,
  GTK_RC_TOKEN_FONT,
  GTK_RC_TOKEN_FONTSET,
  GTK_RC_TOKEN_BG_PIXMAP,
  GTK_RC_TOKEN_PIXMAP_PATH,
  GTK_RC_TOKEN_STYLE,
  GTK_RC_TOKEN_BINDING,
  GTK_RC_TOKEN_BIND,
  GTK_RC_TOKEN_WIDGET,
  GTK_RC_TOKEN_WIDGET_CLASS,
  GTK_RC_TOKEN_CLASS,
  GTK_RC_TOKEN_LOWEST,
  GTK_RC_TOKEN_GTK,
  GTK_RC_TOKEN_APPLICATION,
  GTK_RC_TOKEN_RC,
  GTK_RC_TOKEN_HIGHEST,
  GTK_RC_TOKEN_ENGINE,
  GTK_RC_TOKEN_MODULE_PATH,
  GTK_RC_TOKEN_LAST
} GtkRcTokenType;
</ENUM>
<FUNCTION>
<NAME>gtk_rc_parse_color</NAME>
<RETURNS>guint 	</RETURNS>
GScanner	     *scanner,GdkColor	     *color
</FUNCTION>
<FUNCTION>
<NAME>gtk_rc_parse_state</NAME>
<RETURNS>guint 	</RETURNS>
GScanner	     *scanner,GtkStateType	     *state
</FUNCTION>
<FUNCTION>
<NAME>gtk_rc_parse_priority</NAME>
<RETURNS>guint 	</RETURNS>
GScanner	     *scanner,GtkPathPriorityType *priority
</FUNCTION>
<MACRO>
<NAME>GTK_RULER</NAME>
#define GTK_RULER(obj)          GTK_CHECK_CAST (obj, gtk_ruler_get_type (), GtkRuler)
</MACRO>
<MACRO>
<NAME>GTK_RULER_CLASS</NAME>
#define GTK_RULER_CLASS(klass)  GTK_CHECK_CLASS_CAST (klass, gtk_ruler_get_type (), GtkRulerClass)
</MACRO>
<MACRO>
<NAME>GTK_IS_RULER</NAME>
#define GTK_IS_RULER(obj)       GTK_CHECK_TYPE (obj, gtk_ruler_get_type ())
</MACRO>
<STRUCT>
<NAME>GtkRuler</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkRulerClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkRulerMetric</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkRuler</NAME>
struct GtkRuler
{
  GtkWidget widget;

  GdkPixmap *backing_store;
  GdkGC *non_gr_exp_gc;
  GtkRulerMetric *metric;
  gint xsrc, ysrc;
  gint slider_size;

  /* The upper limit of the ruler (in points) */
  gfloat lower;
  /* The lower limit of the ruler */
  gfloat upper;
  /* The position of the mark on the ruler */
  gfloat position;
  /* The maximum size of the ruler */
  gfloat max_size;
};
</STRUCT>
<STRUCT>
<NAME>GtkRulerMetric</NAME>
struct GtkRulerMetric
{
  gchar *metric_name;
  gchar *abbrev;
  /* This should be points_per_unit. This is the size of the unit
   * in 1/72nd's of an inch and has nothing to do with screen pixels */
  gfloat pixels_per_unit;
  gfloat ruler_scale[10];
  gint subdivide[5];        /* five possible modes of subdivision */
};
</STRUCT>
<FUNCTION>
<NAME>gtk_ruler_get_type</NAME>
<RETURNS>guint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_ruler_set_metric</NAME>
<RETURNS>void  </RETURNS>
GtkRuler       *ruler,GtkMetricType   metric
</FUNCTION>
<FUNCTION>
<NAME>gtk_ruler_set_range</NAME>
<RETURNS>void  </RETURNS>
GtkRuler       *ruler,gfloat          lower,gfloat          upper,gfloat          position,gfloat          max_size
</FUNCTION>
<FUNCTION>
<NAME>gtk_ruler_draw_ticks</NAME>
<RETURNS>void  </RETURNS>
GtkRuler       *ruler
</FUNCTION>
<FUNCTION>
<NAME>gtk_ruler_draw_pos</NAME>
<RETURNS>void  </RETURNS>
GtkRuler       *ruler
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_SCALE</NAME>
#define GTK_TYPE_SCALE            (gtk_scale_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_SCALE</NAME>
#define GTK_SCALE(obj)            (GTK_CHECK_CAST ((obj), GTK_TYPE_SCALE, GtkScale))
</MACRO>
<MACRO>
<NAME>GTK_SCALE_CLASS</NAME>
#define GTK_SCALE_CLASS(klass)    (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_SCALE, GtkScaleClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_SCALE</NAME>
#define GTK_IS_SCALE(obj)         (GTK_CHECK_TYPE ((obj), GTK_TYPE_SCALE))
</MACRO>
<MACRO>
<NAME>GTK_IS_SCALE_CLASS</NAME>
#define GTK_IS_SCALE_CLASS(klass) (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_SCALE))
</MACRO>
<STRUCT>
<NAME>GtkScale</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkScaleClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkScale</NAME>
struct GtkScale
{
  GtkRange range;

  guint draw_value : 1;
  guint value_pos : 2;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_scale_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_scale_set_digits</NAME>
<RETURNS>void  </RETURNS>
GtkScale        *scale,gint             digits
</FUNCTION>
<FUNCTION>
<NAME>gtk_scale_set_draw_value</NAME>
<RETURNS>void  </RETURNS>
GtkScale        *scale,gboolean         draw_value
</FUNCTION>
<FUNCTION>
<NAME>gtk_scale_set_value_pos</NAME>
<RETURNS>void  </RETURNS>
GtkScale        *scale,GtkPositionType  pos
</FUNCTION>
<FUNCTION>
<NAME>gtk_scale_get_value_width</NAME>
<RETURNS>gint  </RETURNS>
GtkScale        *scale
</FUNCTION>
<FUNCTION>
<NAME>gtk_scale_draw_value</NAME>
<RETURNS>void  </RETURNS>
GtkScale        *scale
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_SCROLLBAR</NAME>
#define GTK_TYPE_SCROLLBAR            (gtk_scrollbar_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_SCROLLBAR</NAME>
#define GTK_SCROLLBAR(obj)            (GTK_CHECK_CAST ((obj), GTK_TYPE_SCROLLBAR, GtkScrollbar))
</MACRO>
<MACRO>
<NAME>GTK_SCROLLBAR_CLASS</NAME>
#define GTK_SCROLLBAR_CLASS(klass)    (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_SCROLLBAR, GtkScrollbarClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_SCROLLBAR</NAME>
#define GTK_IS_SCROLLBAR(obj)         (GTK_CHECK_TYPE ((obj), GTK_TYPE_SCROLLBAR))
</MACRO>
<MACRO>
<NAME>GTK_IS_SCROLLBAR_CLASS</NAME>
#define GTK_IS_SCROLLBAR_CLASS(klass) (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_SCROLLBAR))
</MACRO>
<STRUCT>
<NAME>GtkScrollbar</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkScrollbarClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkScrollbar</NAME>
struct GtkScrollbar
{
  GtkRange range;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_scrollbar_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_SCROLLED_WINDOW</NAME>
#define GTK_TYPE_SCROLLED_WINDOW            (gtk_scrolled_window_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_SCROLLED_WINDOW</NAME>
#define GTK_SCROLLED_WINDOW(obj)            (GTK_CHECK_CAST ((obj), GTK_TYPE_SCROLLED_WINDOW, GtkScrolledWindow))
</MACRO>
<MACRO>
<NAME>GTK_SCROLLED_WINDOW_CLASS</NAME>
#define GTK_SCROLLED_WINDOW_CLASS(klass)    (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_SCROLLED_WINDOW, GtkScrolledWindowClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_SCROLLED_WINDOW</NAME>
#define GTK_IS_SCROLLED_WINDOW(obj)         (GTK_CHECK_TYPE ((obj), GTK_TYPE_SCROLLED_WINDOW))
</MACRO>
<MACRO>
<NAME>GTK_IS_SCROLLED_WINDOW_CLASS</NAME>
#define GTK_IS_SCROLLED_WINDOW_CLASS(klass) (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_SCROLLED_WINDOW))
</MACRO>
<STRUCT>
<NAME>GtkScrolledWindow</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkScrolledWindowClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkScrolledWindow</NAME>
struct GtkScrolledWindow
{
  GtkBin container;

  GtkWidget *hscrollbar;
  GtkWidget *vscrollbar;

  guint hscrollbar_policy      : 2;
  guint vscrollbar_policy      : 2;
  guint hscrollbar_visible     : 1;
  guint vscrollbar_visible     : 1;
  guint window_placement       : 2;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_scrolled_window_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_scrolled_window_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GtkAdjustment     *hadjustment,GtkAdjustment     *vadjustment
</FUNCTION>
<FUNCTION>
<NAME>gtk_scrolled_window_set_hadjustment</NAME>
<RETURNS>void  </RETURNS>
GtkScrolledWindow *scrolled_window,GtkAdjustment     *hadjustment
</FUNCTION>
<FUNCTION>
<NAME>gtk_scrolled_window_set_vadjustment</NAME>
<RETURNS>void  </RETURNS>
GtkScrolledWindow *scrolled_window,GtkAdjustment     *hadjustment
</FUNCTION>
<FUNCTION>
<NAME>gtk_scrolled_window_get_hadjustment</NAME>
<RETURNS>GtkAdjustment *</RETURNS>
GtkScrolledWindow *scrolled_window
</FUNCTION>
<FUNCTION>
<NAME>gtk_scrolled_window_get_vadjustment</NAME>
<RETURNS>GtkAdjustment *</RETURNS>
GtkScrolledWindow *scrolled_window
</FUNCTION>
<FUNCTION>
<NAME>gtk_scrolled_window_set_policy</NAME>
<RETURNS>void  </RETURNS>
GtkScrolledWindow *scrolled_window,GtkPolicyType      hscrollbar_policy,GtkPolicyType      vscrollbar_policy
</FUNCTION>
<FUNCTION>
<NAME>gtk_scrolled_window_set_placement</NAME>
<RETURNS>void  </RETURNS>
GtkScrolledWindow *scrolled_window,GtkCornerType      window_placement
</FUNCTION>
<FUNCTION>
<NAME>gtk_scrolled_window_add_with_viewport</NAME>
<RETURNS>void 	</RETURNS>
GtkScrolledWindow *scrolled_window,GtkWidget		*child
</FUNCTION>
<STRUCT>
<NAME>GtkTargetList</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkTargetEntry</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkTargetEntry</NAME>
struct GtkTargetEntry {
  gchar *target;
  guint  flags;
  guint  info;
};
</STRUCT>
<STRUCT>
<NAME>GtkTargetPair</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkTargetList</NAME>
struct GtkTargetList {
  GList *list;
  guint ref_count;
};
</STRUCT>
<STRUCT>
<NAME>GtkTargetPair</NAME>
struct GtkTargetPair {
  GdkAtom   target;
  guint     flags;
  guint     info;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_target_list_new</NAME>
<RETURNS>GtkTargetList  *</RETURNS>
const GtkTargetEntry *targets,guint                 ntargets
</FUNCTION>
<FUNCTION>
<NAME>gtk_target_list_ref</NAME>
<RETURNS>void  </RETURNS>
GtkTargetList  *list
</FUNCTION>
<FUNCTION>
<NAME>gtk_target_list_unref</NAME>
<RETURNS>void  </RETURNS>
GtkTargetList  *list
</FUNCTION>
<FUNCTION>
<NAME>gtk_target_list_add</NAME>
<RETURNS>void  </RETURNS>
GtkTargetList  *list,GdkAtom         target,guint           flags,guint           info
</FUNCTION>
<FUNCTION>
<NAME>gtk_target_list_add_table</NAME>
<RETURNS>void  </RETURNS>
GtkTargetList        *list,const GtkTargetEntry *targets,guint                 ntargets
</FUNCTION>
<FUNCTION>
<NAME>gtk_target_list_remove</NAME>
<RETURNS>void  </RETURNS>
GtkTargetList  *list,GdkAtom         target
</FUNCTION>
<FUNCTION>
<NAME>gtk_target_list_find</NAME>
<RETURNS>gboolean  </RETURNS>
GtkTargetList  *list,GdkAtom         target,guint          *info
</FUNCTION>
<FUNCTION>
<NAME>gtk_selection_owner_set</NAME>
<RETURNS>gint  </RETURNS>
GtkWidget 	  *widget,GdkAtom    	   selection,guint32    	   time
</FUNCTION>
<FUNCTION>
<NAME>gtk_selection_add_target</NAME>
<RETURNS>void  </RETURNS>
GtkWidget           *widget,GdkAtom              selection,GdkAtom              target,guint                info
</FUNCTION>
<FUNCTION>
<NAME>gtk_selection_add_targets</NAME>
<RETURNS>void  </RETURNS>
GtkWidget            *widget,GdkAtom               selection,const GtkTargetEntry *targets,guint                 ntargets
</FUNCTION>
<FUNCTION>
<NAME>gtk_selection_convert</NAME>
<RETURNS>gint  </RETURNS>
GtkWidget 	  *widget,GdkAtom    	   selection,GdkAtom    	   target,guint32    	   time
</FUNCTION>
<FUNCTION>
<NAME>gtk_selection_data_set</NAME>
<RETURNS>void  </RETURNS>
GtkSelectionData *selection_data,GdkAtom           type,gint              format,guchar           *data,gint              length
</FUNCTION>
<FUNCTION>
<NAME>gtk_selection_remove_all</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_selection_clear</NAME>
<RETURNS>gint  </RETURNS>
GtkWidget 	      *widget,GdkEventSelection *event
</FUNCTION>
<FUNCTION>
<NAME>gtk_selection_request</NAME>
<RETURNS>gint  </RETURNS>
GtkWidget  	      *widget,GdkEventSelection *event
</FUNCTION>
<FUNCTION>
<NAME>gtk_selection_incr_event</NAME>
<RETURNS>gint  </RETURNS>
GdkWindow         *window,GdkEventProperty  *event
</FUNCTION>
<FUNCTION>
<NAME>gtk_selection_notify</NAME>
<RETURNS>gint  </RETURNS>
GtkWidget         *widget,GdkEventSelection *event
</FUNCTION>
<FUNCTION>
<NAME>gtk_selection_property_notify</NAME>
<RETURNS>gint  </RETURNS>
GtkWidget         *widget,GdkEventProperty  *event
</FUNCTION>
<FUNCTION>
<NAME>gtk_selection_data_copy</NAME>
<RETURNS>GtkSelectioData  *</RETURNS>
GtkSelectionData *data
</FUNCTION>
<FUNCTION>
<NAME>gtk_selection_data_free</NAME>
<RETURNS>void 	</RETURNS>
GtkSelectionData *data
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_SEPARATOR</NAME>
#define GTK_TYPE_SEPARATOR                  (gtk_separator_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_SEPARATOR</NAME>
#define GTK_SEPARATOR(obj)                  (GTK_CHECK_CAST ((obj), GTK_TYPE_SEPARATOR, GtkSeparator))
</MACRO>
<MACRO>
<NAME>GTK_SEPARATOR_CLASS</NAME>
#define GTK_SEPARATOR_CLASS(klass)          (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_SEPARATOR, GtkSeparatorClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_SEPARATOR</NAME>
#define GTK_IS_SEPARATOR(obj)               (GTK_CHECK_TYPE ((obj), GTK_TYPE_SEPARATOR))
</MACRO>
<MACRO>
<NAME>GTK_IS_SEPARATOR_CLASS</NAME>
#define GTK_IS_SEPARATOR_CLASS(klass)       (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_SEPARATOR))
</MACRO>
<STRUCT>
<NAME>GtkSeparator</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkSeparatorClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkSeparator</NAME>
struct GtkSeparator
{
  GtkWidget widget;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_separator_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GTK_SIGNAL_OFFSET</NAME>
#define GTK_SIGNAL_OFFSET(struct, field)	(GTK_STRUCT_OFFSET (struct, field))
</MACRO>
<USER_FUNCTION>
<NAME>GtkSignalMarshal</NAME>
<RETURNS>void </RETURNS>
GtkObject	    *object,
				     gpointer	     data,
				     guint	     nparams,
				     GtkArg	    *args,
				     GtkType	    *arg_types,
				     GtkType	     return_type
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GtkSignalDestroy</NAME>
<RETURNS>void </RETURNS>
gpointer	     data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GtkEmissionHook</NAME>
<RETURNS>gboolean </RETURNS>
GtkObject	    *object,
				     guint           signal_id,
				     guint	     n_params,
				     GtkArg	    *params,
				     gpointer        data
</USER_FUNCTION>
<STRUCT>
<NAME>GtkSignalQuery</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkSignalQuery</NAME>
struct GtkSignalQuery
{
  GtkType	   object_type;
  guint		   signal_id;
  const gchar	  *signal_name;
  guint		   is_user_signal : 1;
  GtkSignalRunType signal_flags;
  GtkType	   return_val;
  guint		   nparams;
  const GtkType	  *params;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_signal_lookup</NAME>
<RETURNS>guint  </RETURNS>
const gchar	       *name,GtkType		object_type
</FUNCTION>
<FUNCTION>
<NAME>gtk_signal_name</NAME>
<RETURNS>gchar *</RETURNS>
guint		signal_id
</FUNCTION>
<FUNCTION>
<NAME>gtk_signal_n_emissions</NAME>
<RETURNS>guint  </RETURNS>
GtkObject   	       *object,guint                signal_id
</FUNCTION>
<FUNCTION>
<NAME>gtk_signal_n_emissions_by_name</NAME>
<RETURNS>guint  </RETURNS>
GtkObject   	       *object,const gchar         *name
</FUNCTION>
<FUNCTION>
<NAME>gtk_signal_emit_stop</NAME>
<RETURNS>void  </RETURNS>
GtkObject	       *object,guint		signal_id
</FUNCTION>
<FUNCTION>
<NAME>gtk_signal_emit_stop_by_name</NAME>
<RETURNS>void  </RETURNS>
GtkObject	       *object,const gchar	       *name
</FUNCTION>
<FUNCTION>
<NAME>gtk_signal_connect</NAME>
<RETURNS>guint  </RETURNS>
GtkObject	       *object,const gchar	       *name,GtkSignalFunc	func,gpointer		func_data
</FUNCTION>
<FUNCTION>
<NAME>gtk_signal_connect_after</NAME>
<RETURNS>guint  </RETURNS>
GtkObject	       *object,const gchar	       *name,GtkSignalFunc	func,gpointer		func_data
</FUNCTION>
<FUNCTION>
<NAME>gtk_signal_connect_object</NAME>
<RETURNS>guint  </RETURNS>
GtkObject	       *object,const gchar	       *name,GtkSignalFunc	func,GtkObject	       *slot_object
</FUNCTION>
<FUNCTION>
<NAME>gtk_signal_connect_object_after</NAME>
<RETURNS>guint  </RETURNS>
GtkObject	       *object,const gchar	       *name,GtkSignalFunc	func,GtkObject	       *slot_object
</FUNCTION>
<FUNCTION>
<NAME>gtk_signal_connect_full</NAME>
<RETURNS>guint  </RETURNS>
GtkObject	       *object,const gchar	       *name,GtkSignalFunc	func,GtkCallbackMarshal	marshal,gpointer		data,GtkDestroyNotify	destroy_func,gint			object_signal,gint			after
</FUNCTION>
<FUNCTION>
<NAME>gtk_signal_connect_object_while_alive</NAME>
<RETURNS>void  </RETURNS>
GtkObject	       *object,const gchar      *signal,GtkSignalFunc	func,GtkObject	       *alive_object
</FUNCTION>
<FUNCTION>
<NAME>gtk_signal_connect_while_alive</NAME>
<RETURNS>void  </RETURNS>
GtkObject	       *object,const gchar      *signal,GtkSignalFunc	func,gpointer		func_data,GtkObject	       *alive_object
</FUNCTION>
<FUNCTION>
<NAME>gtk_signal_disconnect</NAME>
<RETURNS>void  </RETURNS>
GtkObject	       *object,guint		handler_id
</FUNCTION>
<FUNCTION>
<NAME>gtk_signal_disconnect_by_func</NAME>
<RETURNS>void  </RETURNS>
GtkObject	       *object,GtkSignalFunc	func,gpointer		data
</FUNCTION>
<FUNCTION>
<NAME>gtk_signal_disconnect_by_data</NAME>
<RETURNS>void  </RETURNS>
GtkObject	       *object,gpointer		data
</FUNCTION>
<FUNCTION>
<NAME>gtk_signal_handler_block</NAME>
<RETURNS>void  </RETURNS>
GtkObject	       *object,guint		handler_id
</FUNCTION>
<FUNCTION>
<NAME>gtk_signal_handler_block_by_func</NAME>
<RETURNS>void  </RETURNS>
GtkObject	       *object,GtkSignalFunc	func,gpointer		data
</FUNCTION>
<FUNCTION>
<NAME>gtk_signal_handler_block_by_data</NAME>
<RETURNS>void  </RETURNS>
GtkObject	       *object,gpointer		data
</FUNCTION>
<FUNCTION>
<NAME>gtk_signal_handler_unblock</NAME>
<RETURNS>void  </RETURNS>
GtkObject	       *object,guint		handler_id
</FUNCTION>
<FUNCTION>
<NAME>gtk_signal_handler_unblock_by_func</NAME>
<RETURNS>void  </RETURNS>
GtkObject	       *object,GtkSignalFunc	func,gpointer		data
</FUNCTION>
<FUNCTION>
<NAME>gtk_signal_handler_unblock_by_data</NAME>
<RETURNS>void  </RETURNS>
GtkObject	       *object,gpointer		data
</FUNCTION>
<FUNCTION>
<NAME>gtk_signal_handler_pending</NAME>
<RETURNS>guint  </RETURNS>
GtkObject	       *object,guint		signal_id,gboolean		may_be_blocked
</FUNCTION>
<FUNCTION>
<NAME>gtk_signal_handler_pending_by_func</NAME>
<RETURNS>guint  </RETURNS>
GtkObject	       *object,guint		signal_id,gboolean		may_be_blocked,GtkSignalFunc	func,gpointer		data
</FUNCTION>
<FUNCTION>
<NAME>gtk_signal_handler_pending_by_id</NAME>
<RETURNS>gint  </RETURNS>
GtkObject	       *object,guint		handler_id,gboolean		may_be_blocked
</FUNCTION>
<FUNCTION>
<NAME>gtk_signal_add_emission_hook</NAME>
<RETURNS>guint  </RETURNS>
guint		signal_id,GtkEmissionHook	hook_func,gpointer       	data
</FUNCTION>
<FUNCTION>
<NAME>gtk_signal_add_emission_hook_full</NAME>
<RETURNS>guint  </RETURNS>
guint		signal_id,GtkEmissionHook	hook_func,gpointer       	data,GDestroyNotify	destroy
</FUNCTION>
<FUNCTION>
<NAME>gtk_signal_remove_emission_hook</NAME>
<RETURNS>void  </RETURNS>
guint		signal_id,guint		hook_id
</FUNCTION>
<FUNCTION>
<NAME>gtk_signal_query</NAME>
<RETURNS>GtkSignalQuery *</RETURNS>
guint		signal_id
</FUNCTION>
<FUNCTION>
<NAME>gtk_signal_init</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_signal_new</NAME>
<RETURNS>guint  </RETURNS>
const gchar	       *name,GtkSignalRunType	signal_flags,GtkType		object_type,guint		function_offset,GtkSignalMarshaller	marshaller,GtkType		return_val,guint		nparams,...
</FUNCTION>
<FUNCTION>
<NAME>gtk_signal_newv</NAME>
<RETURNS>guint  </RETURNS>
const gchar	       *name,GtkSignalRunType	signal_flags,GtkType		object_type,guint		function_offset,GtkSignalMarshaller	marshaller,GtkType		return_val,guint		nparams,GtkType	       *params
</FUNCTION>
<FUNCTION>
<NAME>gtk_signal_emit</NAME>
<RETURNS>void  </RETURNS>
GtkObject	       *object,guint		signal_id,...
</FUNCTION>
<FUNCTION>
<NAME>gtk_signal_emit_by_name</NAME>
<RETURNS>void  </RETURNS>
GtkObject	       *object,const gchar	       *name,...
</FUNCTION>
<FUNCTION>
<NAME>gtk_signal_emitv</NAME>
<RETURNS>void  </RETURNS>
GtkObject           *object,guint                signal_id,GtkArg              *params
</FUNCTION>
<FUNCTION>
<NAME>gtk_signal_emitv_by_name</NAME>
<RETURNS>void  </RETURNS>
GtkObject           *object,const gchar	       *name,GtkArg              *params
</FUNCTION>
<FUNCTION>
<NAME>gtk_signal_handlers_destroy</NAME>
<RETURNS>void  </RETURNS>
GtkObject	       *object
</FUNCTION>
<FUNCTION>
<NAME>gtk_signal_set_funcs</NAME>
<RETURNS>void  </RETURNS>
GtkSignalMarshal	marshal_func,GtkSignalDestroy	destroy_func
</FUNCTION>
<MACRO>
<NAME>GTK_SOCKET</NAME>
#define GTK_SOCKET(obj)          GTK_CHECK_CAST (obj, gtk_socket_get_type (), GtkSocket)
</MACRO>
<MACRO>
<NAME>GTK_SOCKET_CLASS</NAME>
#define GTK_SOCKET_CLASS(klass)  GTK_CHECK_CLASS_CAST (klass, gtk_socket_get_type (), GtkSocketClass)
</MACRO>
<MACRO>
<NAME>GTK_IS_SOCKET</NAME>
#define GTK_IS_SOCKET(obj)       GTK_CHECK_TYPE (obj, gtk_socket_get_type ())
</MACRO>
<STRUCT>
<NAME>GtkSocket</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkSocketClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkSocket</NAME>
struct GtkSocket
{
  GtkContainer container;

  guint16 request_width;
  guint16 request_height;
  guint16 current_width;
  guint16 current_height;
  
  GdkWindow *plug_window;
  guint same_app : 1;
  guint focus_in : 1;
  guint have_size : 1;
  guint need_map : 1;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_socket_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_socket_get_type</NAME>
<RETURNS>guint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_socket_steal</NAME>
<RETURNS>void  </RETURNS>
GtkSocket *socket,guint32 wid
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_SPIN_BUTTON</NAME>
#define GTK_TYPE_SPIN_BUTTON                  (gtk_spin_button_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_SPIN_BUTTON</NAME>
#define GTK_SPIN_BUTTON(obj)                  (GTK_CHECK_CAST ((obj), GTK_TYPE_SPIN_BUTTON, GtkSpinButton))
</MACRO>
<MACRO>
<NAME>GTK_SPIN_BUTTON_CLASS</NAME>
#define GTK_SPIN_BUTTON_CLASS(klass)          (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_SPIN_BUTTON, GtkSpinButtonClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_SPIN_BUTTON</NAME>
#define GTK_IS_SPIN_BUTTON(obj)               (GTK_CHECK_TYPE ((obj), GTK_TYPE_SPIN_BUTTON))
</MACRO>
<MACRO>
<NAME>GTK_IS_SPIN_BUTTON_CLASS</NAME>
#define GTK_IS_SPIN_BUTTON_CLASS(klass)       (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_SPIN_BUTTON))
</MACRO>
<ENUM>
<NAME>GtkSpinButtonUpdatePolicy</NAME>
typedef enum
{
  GTK_UPDATE_ALWAYS,
  GTK_UPDATE_IF_VALID
} GtkSpinButtonUpdatePolicy;
</ENUM>
<ENUM>
<NAME>GtkSpinType</NAME>
typedef enum
{
  GTK_SPIN_STEP_FORWARD,
  GTK_SPIN_STEP_BACKWARD,
  GTK_SPIN_PAGE_FORWARD,
  GTK_SPIN_PAGE_BACKWARD,
  GTK_SPIN_HOME,
  GTK_SPIN_END,
  GTK_SPIN_USER_DEFINED
} GtkSpinType;
</ENUM>
<STRUCT>
<NAME>GtkSpinButton</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkSpinButtonClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkSpinButton</NAME>
struct GtkSpinButton
{
  GtkEntry entry;
  
  GtkAdjustment *adjustment;
  
  GdkWindow *panel;
  GtkShadowType shadow_type;
  
  guint32 timer;
  guint32 ev_time;
  
  gfloat climb_rate;
  gfloat timer_step;
  
  GtkSpinButtonUpdatePolicy update_policy;
  
  guint in_child : 2;
  guint click_child : 2;
  guint button : 2;
  guint need_timer : 1;
  guint timer_calls : 3;
  guint digits : 3;
  guint numeric : 1;
  guint wrap : 1;
  guint snap_to_ticks : 1;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_spin_button_get_type</NAME>
<RETURNS>GtkType 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_spin_button_configure</NAME>
<RETURNS>void 	</RETURNS>
GtkSpinButton  *spin_button,GtkAdjustment  *adjustment,gfloat	    climb_rate,guint	    digits
</FUNCTION>
<FUNCTION>
<NAME>gtk_spin_button_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GtkAdjustment  *adjustment,gfloat	    climb_rate,guint	    digits
</FUNCTION>
<FUNCTION>
<NAME>gtk_spin_button_set_adjustment</NAME>
<RETURNS>void 	</RETURNS>
GtkSpinButton  *spin_button,GtkAdjustment  *adjustment
</FUNCTION>
<FUNCTION>
<NAME>gtk_spin_button_get_adjustment</NAME>
<RETURNS>GtkAdjustment *</RETURNS>
GtkSpinButton  *spin_button
</FUNCTION>
<FUNCTION>
<NAME>gtk_spin_button_set_digits</NAME>
<RETURNS>void 	</RETURNS>
GtkSpinButton  *spin_button,guint	    digits
</FUNCTION>
<FUNCTION>
<NAME>gtk_spin_button_get_value_as_float</NAME>
<RETURNS>gfloat 	</RETURNS>
GtkSpinButton  *spin_button
</FUNCTION>
<FUNCTION>
<NAME>gtk_spin_button_get_value_as_int</NAME>
<RETURNS>gint 	</RETURNS>
GtkSpinButton  *spin_button
</FUNCTION>
<FUNCTION>
<NAME>gtk_spin_button_set_value</NAME>
<RETURNS>void 	</RETURNS>
GtkSpinButton  *spin_button,gfloat	    value
</FUNCTION>
<FUNCTION>
<NAME>gtk_spin_button_set_update_policy</NAME>
<RETURNS>void 	</RETURNS>
GtkSpinButton  *spin_button,GtkSpinButtonUpdatePolicy  policy
</FUNCTION>
<FUNCTION>
<NAME>gtk_spin_button_set_numeric</NAME>
<RETURNS>void 	</RETURNS>
GtkSpinButton  *spin_button,gboolean	    numeric
</FUNCTION>
<FUNCTION>
<NAME>gtk_spin_button_spin</NAME>
<RETURNS>void 	</RETURNS>
GtkSpinButton  *spin_button,GtkSpinType     direction,gfloat	    increment
</FUNCTION>
<FUNCTION>
<NAME>gtk_spin_button_set_wrap</NAME>
<RETURNS>void 	</RETURNS>
GtkSpinButton  *spin_button,gboolean	    wrap
</FUNCTION>
<FUNCTION>
<NAME>gtk_spin_button_set_shadow_type</NAME>
<RETURNS>void 	</RETURNS>
GtkSpinButton  *spin_button,GtkShadowType   shadow_type
</FUNCTION>
<FUNCTION>
<NAME>gtk_spin_button_set_snap_to_ticks</NAME>
<RETURNS>void 	</RETURNS>
GtkSpinButton  *spin_button,gboolean	    snap_to_ticks
</FUNCTION>
<FUNCTION>
<NAME>gtk_spin_button_update</NAME>
<RETURNS>void  </RETURNS>
GtkSpinButton  *spin_button
</FUNCTION>
<MACRO>
<NAME>GTK_STATUSBAR</NAME>
#define GTK_STATUSBAR(obj)          GTK_CHECK_CAST (obj, gtk_statusbar_get_type (), GtkStatusbar)
</MACRO>
<MACRO>
<NAME>GTK_STATUSBAR_CLASS</NAME>
#define GTK_STATUSBAR_CLASS(klass)  GTK_CHECK_CLASS_CAST (klass, gtk_statusbar_get_type (), GtkStatusbarClass)
</MACRO>
<MACRO>
<NAME>GTK_IS_STATUSBAR</NAME>
#define GTK_IS_STATUSBAR(obj)       GTK_CHECK_TYPE (obj, gtk_statusbar_get_type ())
</MACRO>
<STRUCT>
<NAME>GtkStatusbar</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkStatusbarClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkStatusbarMsg</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkStatusbar</NAME>
struct GtkStatusbar
{
  GtkHBox parent_widget;

  GtkWidget *frame;
  GtkWidget *label;

  GSList *messages;
  GSList *keys;

  guint seq_context_id;
  guint seq_message_id;
};
</STRUCT>
<STRUCT>
<NAME>GtkStatusbarMsg</NAME>
struct GtkStatusbarMsg
{
  gchar *text;
  guint context_id;
  guint message_id;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_statusbar_get_type</NAME>
<RETURNS>guint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_statusbar_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_statusbar_get_context_id</NAME>
<RETURNS>guint 	</RETURNS>
GtkStatusbar *statusbar,const gchar  *context_description
</FUNCTION>
<FUNCTION>
<NAME>gtk_statusbar_push</NAME>
<RETURNS>guint  </RETURNS>
GtkStatusbar *statusbar,guint	       context_id,const gchar  *text
</FUNCTION>
<FUNCTION>
<NAME>gtk_statusbar_pop</NAME>
<RETURNS>void  </RETURNS>
GtkStatusbar *statusbar,guint	       context_id
</FUNCTION>
<FUNCTION>
<NAME>gtk_statusbar_remove</NAME>
<RETURNS>void  </RETURNS>
GtkStatusbar *statusbar,guint	       context_id,guint         message_id
</FUNCTION>
<STRUCT>
<NAME>GtkStyle</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkStyleClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkThemeEngine</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkRcStyle</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkWidget</NAME>
</STRUCT>
<MACRO>
<NAME>GTK_STYLE_NUM_STYLECOLORS</NAME>
#define GTK_STYLE_NUM_STYLECOLORS()	(7 * 5)
</MACRO>
<MACRO>
<NAME>GTK_STYLE_ATTACHED</NAME>
#define GTK_STYLE_ATTACHED(style)	(((GtkStyle*) (style))->attach_count > 0)
</MACRO>
<STRUCT>
<NAME>GtkStyle</NAME>
struct GtkStyle
{
  GtkStyleClass *klass;

  GdkColor fg[5];
  GdkColor bg[5];
  GdkColor light[5];
  GdkColor dark[5];
  GdkColor mid[5];
  GdkColor text[5];
  GdkColor base[5];
  
  GdkColor black;
  GdkColor white;
  GdkFont *font;
  
  GdkGC *fg_gc[5];
  GdkGC *bg_gc[5];
  GdkGC *light_gc[5];
  GdkGC *dark_gc[5];
  GdkGC *mid_gc[5];
  GdkGC *text_gc[5];
  GdkGC *base_gc[5];
  GdkGC *black_gc;
  GdkGC *white_gc;
  
  GdkPixmap *bg_pixmap[5];
  
  /* private */
  
  gint ref_count;
  gint attach_count;
  
  gint depth;
  GdkColormap *colormap;
  
  GtkThemeEngine *engine;
  
  gpointer	  engine_data;
  
  GtkRcStyle	 *rc_style;	/* the Rc style from which this style
				 * was created
				 */
  GSList	 *styles;
};
</STRUCT>
<STRUCT>
<NAME>GtkStyleClass</NAME>
struct GtkStyleClass
{
  gint xthickness;
  gint ythickness;
  
  void (*draw_hline)		(GtkStyle		*style,
				 GdkWindow		*window,
				 GtkStateType		 state_type,
				 GdkRectangle		*area,
				 GtkWidget		*widget,
				 gchar			*detail,
				 gint			 x1,
				 gint			 x2,
				 gint			 y);
  void (*draw_vline)		(GtkStyle		*style,
				 GdkWindow		*window,
				 GtkStateType		 state_type,
				 GdkRectangle		*area,
				 GtkWidget		*widget,
				 gchar			*detail,
				 gint			 y1,
				 gint			 y2,
				 gint			 x);
  void (*draw_shadow)		(GtkStyle		*style,
				 GdkWindow		*window,
				 GtkStateType		 state_type,
				 GtkShadowType		 shadow_type,
				 GdkRectangle		*area,
				 GtkWidget		*widget,
				 gchar			*detail,
				 gint			 x,
				 gint			 y,
				 gint			 width,
				 gint			 height);
  void (*draw_polygon)		(GtkStyle		*style,
				 GdkWindow		*window,
				 GtkStateType		 state_type,
				 GtkShadowType		 shadow_type,
				 GdkRectangle		*area,
				 GtkWidget		*widget,
				 gchar			*detail,
				 GdkPoint		*point,
				 gint			 npoints,
				 gboolean		 fill);
  void (*draw_arrow)		(GtkStyle		*style,
				 GdkWindow		*window,
				 GtkStateType		 state_type,
				 GtkShadowType		 shadow_type,
				 GdkRectangle		*area,
				 GtkWidget		*widget,
				 gchar			*detail,
				 GtkArrowType		 arrow_type,
				 gboolean		 fill,
				 gint			 x,
				 gint			 y,
				 gint			 width,
				 gint			 height);
  void (*draw_diamond)		(GtkStyle		*style,
				 GdkWindow		*window,
				 GtkStateType		 state_type,
				 GtkShadowType		 shadow_type,
				 GdkRectangle		*area,
				 GtkWidget		*widget,
				 gchar			*detail,
				 gint			 x,
				 gint			 y,
				 gint			 width,
				 gint			 height);
  void (*draw_oval)		(GtkStyle		*style,
				 GdkWindow		*window,
				 GtkStateType		 state_type,
				 GtkShadowType		 shadow_type,
				 GdkRectangle		*area,
				 GtkWidget		*widget,
				 gchar			*detail,
				 gint			 x,
				 gint			 y,
				 gint			 width,
				 gint			 height);
  void (*draw_string)		(GtkStyle		*style,
				 GdkWindow		*window,
				 GtkStateType		 state_type,
				 GdkRectangle		*area,
				 GtkWidget		*widget,
				 gchar			*detail,
				 gint			 x,
				 gint			 y,
				 const gchar		*string);
  void (*draw_box)		(GtkStyle		*style,
				 GdkWindow		*window,
				 GtkStateType		 state_type,
				 GtkShadowType		 shadow_type,
				 GdkRectangle		*area,
				 GtkWidget		*widget,
				 gchar			*detail,
				 gint			 x,
				 gint			 y,
				 gint			 width,
				 gint			 height);
  void (*draw_flat_box)		(GtkStyle		*style,
				 GdkWindow		*window,
				 GtkStateType		 state_type,
				 GtkShadowType		 shadow_type,
				 GdkRectangle		*area,
				 GtkWidget		*widget,
				 gchar			*detail,
				 gint			 x,
				 gint			 y,
				 gint			 width,
				 gint			 height);
  void (*draw_check)		(GtkStyle		*style,
				 GdkWindow		*window,
				 GtkStateType		 state_type,
				 GtkShadowType		 shadow_type,
				 GdkRectangle		*area,
				 GtkWidget		*widget,
				 gchar			*detail,
				 gint			 x,
				 gint			 y,
				 gint			 width,
				 gint			 height);
  void (*draw_option)		(GtkStyle		*style,
				 GdkWindow		*window,
				 GtkStateType		 state_type,
				 GtkShadowType		 shadow_type,
				 GdkRectangle		*area,
				 GtkWidget		*widget,
				 gchar			*detail,
				 gint			 x,
				 gint			 y,
				 gint			 width,
				 gint			 height);
  void (*draw_cross)		(GtkStyle		*style,
				 GdkWindow		*window,
				 GtkStateType		 state_type,
				 GtkShadowType		 shadow_type,
				 GdkRectangle		*area,
				 GtkWidget		*widget,
				 gchar			*detail,
				 gint			 x,
				 gint			 y,
				 gint			 width,
				 gint			 height);
  void (*draw_ramp)		(GtkStyle		*style,
				 GdkWindow		*window,
				 GtkStateType		 state_type,
				 GtkShadowType		 shadow_type,
				 GdkRectangle		*area,
				 GtkWidget		*widget,
				 gchar			*detail,
				 GtkArrowType		 arrow_type,
				 gint			 x,
				 gint			 y,
				 gint			 width,
				 gint			 height);
  void (*draw_tab)		(GtkStyle		*style,
				 GdkWindow		*window,
				 GtkStateType		 state_type,
				 GtkShadowType		 shadow_type,
				 GdkRectangle		*area,
				 GtkWidget		*widget,
				 gchar			*detail,
				 gint			 x,
				 gint			 y,
				 gint			 width,
				 gint			 height); 
  void (*draw_shadow_gap)	(GtkStyle		*style,
				 GdkWindow		*window,
				 GtkStateType		 state_type,
				 GtkShadowType		 shadow_type,
				 GdkRectangle		*area,
				 GtkWidget		*widget,
				 gchar			*detail,
				 gint			 x,
				 gint			 y,
				 gint			 width,
				 gint			 height,
				 GtkPositionType	 gap_side,
				 gint			 gap_x,
				 gint			 gap_width);
  void (*draw_box_gap)		(GtkStyle		*style,
				 GdkWindow		*window,
				 GtkStateType		 state_type,
				 GtkShadowType		 shadow_type,
				 GdkRectangle		*area,
				 GtkWidget		*widget,
				 gchar			*detail,
				 gint			 x,
				 gint			 y,
				 gint			 width,
				 gint			 height,
				 GtkPositionType	 gap_side,
				 gint			 gap_x,
				 gint			 gap_width);
  void (*draw_extension)	(GtkStyle		*style,
				 GdkWindow		*window,
				 GtkStateType		 state_type,
				 GtkShadowType		 shadow_type,
				 GdkRectangle		*area,
				 GtkWidget		*widget,
				 gchar			*detail,
				 gint			 x,
				 gint			 y,
				 gint			 width,
				 gint			 height,
				 GtkPositionType	 gap_side);
  void (*draw_focus)		(GtkStyle		*style,
				 GdkWindow		*window,
				 GdkRectangle		*area,
				 GtkWidget		*widget,
				 gchar			*detail,
				 gint			 x,
				 gint			 y,
				 gint			 width,
				 gint			 height);
  void (*draw_slider)		(GtkStyle		*style,
				 GdkWindow		*window,
				 GtkStateType		 state_type,
				 GtkShadowType		 shadow_type,
				 GdkRectangle		*area,
				 GtkWidget		*widget,
				 gchar			*detail,
				 gint			 x,
				 gint			 y,
				 gint			 width,
				 gint			 height,
				 GtkOrientation		 orientation);
  void (*draw_handle)		(GtkStyle		*style,
				 GdkWindow		*window,
				 GtkStateType		 state_type,
				 GtkShadowType		 shadow_type,
				 GdkRectangle		*area,
				 GtkWidget		*widget,
				 gchar			*detail,
				 gint			 x,
				 gint			 y,
				 gint			 width,
				 gint			 height,
				 GtkOrientation		 orientation);
};
</STRUCT>
<FUNCTION>
<NAME>gtk_style_new</NAME>
<RETURNS>GtkStyle *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_style_copy</NAME>
<RETURNS>GtkStyle *</RETURNS>
GtkStyle	    *style
</FUNCTION>
<FUNCTION>
<NAME>gtk_style_attach</NAME>
<RETURNS>GtkStyle *</RETURNS>
GtkStyle	    *style,GdkWindow	    *window
</FUNCTION>
<FUNCTION>
<NAME>gtk_style_detach</NAME>
<RETURNS>void 	</RETURNS>
GtkStyle	   *style
</FUNCTION>
<FUNCTION>
<NAME>gtk_style_ref</NAME>
<RETURNS>GtkStyle *</RETURNS>
GtkStyle	   *style
</FUNCTION>
<FUNCTION>
<NAME>gtk_style_unref</NAME>
<RETURNS>void 	</RETURNS>
GtkStyle	   *style
</FUNCTION>
<FUNCTION>
<NAME>gtk_style_set_background</NAME>
<RETURNS>void 	</RETURNS>
GtkStyle	   *style,GdkWindow	   *window,GtkStateType  state_type
</FUNCTION>
<FUNCTION>
<NAME>gtk_style_apply_default_background</NAME>
<RETURNS>void 	</RETURNS>
GtkStyle	   *style,GdkWindow	   *window,gboolean	    set_bg,GtkStateType  state_type,GdkRectangle *area,gint	    x,gint	    y,gint	    width,gint	    height
</FUNCTION>
<FUNCTION>
<NAME>gtk_draw_hline</NAME>
<RETURNS>void  </RETURNS>
GtkStyle	     *style,GdkWindow     *window,GtkStateType   state_type,gint	      x1,gint	      x2,gint	      y
</FUNCTION>
<FUNCTION>
<NAME>gtk_draw_vline</NAME>
<RETURNS>void  </RETURNS>
GtkStyle	     *style,GdkWindow     *window,GtkStateType   state_type,gint	      y1,gint	      y2,gint	      x
</FUNCTION>
<FUNCTION>
<NAME>gtk_draw_shadow</NAME>
<RETURNS>void  </RETURNS>
GtkStyle	     *style,GdkWindow     *window,GtkStateType   state_type,GtkShadowType  shadow_type,gint	      x,gint	      y,gint	      width,gint	      height
</FUNCTION>
<FUNCTION>
<NAME>gtk_draw_polygon</NAME>
<RETURNS>void  </RETURNS>
GtkStyle	     *style,GdkWindow     *window,GtkStateType   state_type,GtkShadowType  shadow_type,GdkPoint	     *points,gint	      npoints,gboolean	      fill
</FUNCTION>
<FUNCTION>
<NAME>gtk_draw_arrow</NAME>
<RETURNS>void  </RETURNS>
GtkStyle	     *style,GdkWindow     *window,GtkStateType   state_type,GtkShadowType  shadow_type,GtkArrowType   arrow_type,gboolean	      fill,gint	      x,gint	      y,gint	      width,gint	      height
</FUNCTION>
<FUNCTION>
<NAME>gtk_draw_diamond</NAME>
<RETURNS>void  </RETURNS>
GtkStyle	     *style,GdkWindow     *window,GtkStateType   state_type,GtkShadowType  shadow_type,gint	      x,gint	      y,gint	      width,gint	      height
</FUNCTION>
<FUNCTION>
<NAME>gtk_draw_oval</NAME>
<RETURNS>void  </RETURNS>
GtkStyle	     *style,GdkWindow     *window,GtkStateType   state_type,GtkShadowType  shadow_type,gint	      x,gint	      y,gint	      width,gint	      height
</FUNCTION>
<FUNCTION>
<NAME>gtk_draw_string</NAME>
<RETURNS>void  </RETURNS>
GtkStyle	     *style,GdkWindow     *window,GtkStateType   state_type,gint	      x,gint	      y,const gchar   *string
</FUNCTION>
<FUNCTION>
<NAME>gtk_draw_box</NAME>
<RETURNS>void  </RETURNS>
GtkStyle	     *style,GdkWindow     *window,GtkStateType   state_type,GtkShadowType  shadow_type,gint	      x,gint	      y,gint	      width,gint	      height
</FUNCTION>
<FUNCTION>
<NAME>gtk_draw_flat_box</NAME>
<RETURNS>void  </RETURNS>
GtkStyle      *style,GdkWindow     *window,GtkStateType   state_type,GtkShadowType  shadow_type,gint	       x,gint	       y,gint	       width,gint	       height
</FUNCTION>
<FUNCTION>
<NAME>gtk_draw_check</NAME>
<RETURNS>void  </RETURNS>
GtkStyle	     *style,GdkWindow     *window,GtkStateType   state_type,GtkShadowType  shadow_type,gint	      x,gint	      y,gint	      width,gint	      height
</FUNCTION>
<FUNCTION>
<NAME>gtk_draw_option</NAME>
<RETURNS>void  </RETURNS>
GtkStyle	     *style,GdkWindow     *window,GtkStateType   state_type,GtkShadowType  shadow_type,gint	      x,gint	      y,gint	      width,gint	      height
</FUNCTION>
<FUNCTION>
<NAME>gtk_draw_cross</NAME>
<RETURNS>void  </RETURNS>
GtkStyle	     *style,GdkWindow     *window,GtkStateType   state_type,GtkShadowType  shadow_type,gint	      x,gint	      y,gint	      width,gint	      height
</FUNCTION>
<FUNCTION>
<NAME>gtk_draw_ramp</NAME>
<RETURNS>void  </RETURNS>
GtkStyle	     *style,GdkWindow     *window,GtkStateType   state_type,GtkShadowType  shadow_type,GtkArrowType   arrow_type,gint	      x,gint	      y,gint	      width,gint	      height
</FUNCTION>
<FUNCTION>
<NAME>gtk_draw_tab</NAME>
<RETURNS>void  </RETURNS>
GtkStyle	     *style,GdkWindow     *window,GtkStateType   state_type,GtkShadowType  shadow_type,gint	      x,gint	      y,gint	      width,gint	      height
</FUNCTION>
<FUNCTION>
<NAME>gtk_draw_shadow_gap</NAME>
<RETURNS>void  </RETURNS>
GtkStyle	 *style,GdkWindow	 *window,GtkStateType	  state_type,GtkShadowType	  shadow_type,gint		  x,gint		  y,gint		  width,gint		  height,GtkPositionType gap_side,gint		  gap_x,gint		  gap_width
</FUNCTION>
<FUNCTION>
<NAME>gtk_draw_box_gap</NAME>
<RETURNS>void  </RETURNS>
GtkStyle	      *style,GdkWindow      *window,GtkStateType    state_type,GtkShadowType   shadow_type,gint	       x,gint	       y,gint	       width,gint	       height,GtkPositionType gap_side,gint	       gap_x,gint	       gap_width
</FUNCTION>
<FUNCTION>
<NAME>gtk_draw_extension</NAME>
<RETURNS>void  </RETURNS>
GtkStyle	*style,GdkWindow	*window,GtkStateType	 state_type,GtkShadowType	 shadow_type,gint		 x,gint		 y,gint		 width,gint		 height,GtkPositionType gap_side
</FUNCTION>
<FUNCTION>
<NAME>gtk_draw_focus</NAME>
<RETURNS>void  </RETURNS>
GtkStyle	     *style,GdkWindow     *window,gint	      x,gint	      y,gint	      width,gint	      height
</FUNCTION>
<FUNCTION>
<NAME>gtk_draw_slider</NAME>
<RETURNS>void  </RETURNS>
GtkStyle	     *style,GdkWindow     *window,GtkStateType   state_type,GtkShadowType  shadow_type,gint	      x,gint	      y,gint	      width,gint	      height,GtkOrientation orientation
</FUNCTION>
<FUNCTION>
<NAME>gtk_draw_handle</NAME>
<RETURNS>void  </RETURNS>
GtkStyle	     *style,GdkWindow     *window,GtkStateType   state_type,GtkShadowType  shadow_type,gint	      x,gint	      y,gint	      width,gint	      height,GtkOrientation orientation
</FUNCTION>
<FUNCTION>
<NAME>gtk_paint_hline</NAME>
<RETURNS>void  </RETURNS>
GtkStyle      *style,GdkWindow     *window,GtkStateType   state_type,GdkRectangle  *area,GtkWidget     *widget,gchar	      *detail,gint	       x1,gint	       x2,gint	       y
</FUNCTION>
<FUNCTION>
<NAME>gtk_paint_vline</NAME>
<RETURNS>void  </RETURNS>
GtkStyle      *style,GdkWindow     *window,GtkStateType   state_type,GdkRectangle  *area,GtkWidget     *widget,gchar	      *detail,gint	       y1,gint	       y2,gint	       x
</FUNCTION>
<FUNCTION>
<NAME>gtk_paint_shadow</NAME>
<RETURNS>void  </RETURNS>
GtkStyle     *style,GdkWindow    *window,GtkStateType  state_type,GtkShadowType shadow_type,GdkRectangle  *area,GtkWidget     *widget,gchar	      *detail,gint	       x,gint	       y,gint	       width,gint	       height
</FUNCTION>
<FUNCTION>
<NAME>gtk_paint_polygon</NAME>
<RETURNS>void  </RETURNS>
GtkStyle      *style,GdkWindow     *window,GtkStateType   state_type,GtkShadowType  shadow_type,GdkRectangle  *area,GtkWidget     *widget,gchar	      *detail,GdkPoint      *points,gint	       npoints,gboolean       fill
</FUNCTION>
<FUNCTION>
<NAME>gtk_paint_arrow</NAME>
<RETURNS>void  </RETURNS>
GtkStyle      *style,GdkWindow     *window,GtkStateType   state_type,GtkShadowType  shadow_type,GdkRectangle  *area,GtkWidget     *widget,gchar	      *detail,GtkArrowType   arrow_type,gboolean       fill,gint	       x,gint	       y,gint	       width,gint	       height
</FUNCTION>
<FUNCTION>
<NAME>gtk_paint_diamond</NAME>
<RETURNS>void  </RETURNS>
GtkStyle      *style,GdkWindow     *window,GtkStateType   state_type,GtkShadowType  shadow_type,GdkRectangle  *area,GtkWidget     *widget,gchar	      *detail,gint	       x,gint	       y,gint	       width,gint	       height
</FUNCTION>
<FUNCTION>
<NAME>gtk_paint_oval</NAME>
<RETURNS>void  </RETURNS>
GtkStyle      *style,GdkWindow     *window,GtkStateType   state_type,GtkShadowType  shadow_type,GdkRectangle  *area,GtkWidget     *widget,gchar	      *detail,gint	       x,gint	       y,gint	       width,gint	       height
</FUNCTION>
<FUNCTION>
<NAME>gtk_paint_string</NAME>
<RETURNS>void  </RETURNS>
GtkStyle      *style,GdkWindow     *window,GtkStateType   state_type,GdkRectangle  *area,GtkWidget     *widget,gchar	      *detail,gint	       x,gint	       y,const gchar   *string
</FUNCTION>
<FUNCTION>
<NAME>gtk_paint_box</NAME>
<RETURNS>void  </RETURNS>
GtkStyle      *style,GdkWindow     *window,GtkStateType   state_type,GtkShadowType  shadow_type,GdkRectangle  *area,GtkWidget     *widget,gchar	      *detail,gint	       x,gint	       y,gint	       width,gint	       height
</FUNCTION>
<FUNCTION>
<NAME>gtk_paint_flat_box</NAME>
<RETURNS>void  </RETURNS>
GtkStyle      *style,GdkWindow     *window,GtkStateType	state_type,GtkShadowType	shadow_type,GdkRectangle  *area,GtkWidget     *widget,gchar	       *detail,gint		x,gint		y,gint		width,gint		height
</FUNCTION>
<FUNCTION>
<NAME>gtk_paint_check</NAME>
<RETURNS>void  </RETURNS>
GtkStyle      *style,GdkWindow     *window,GtkStateType   state_type,GtkShadowType  shadow_type,GdkRectangle  *area,GtkWidget     *widget,gchar	      *detail,gint	       x,gint	       y,gint	       width,gint	       height
</FUNCTION>
<FUNCTION>
<NAME>gtk_paint_option</NAME>
<RETURNS>void  </RETURNS>
GtkStyle      *style,GdkWindow     *window,GtkStateType   state_type,GtkShadowType  shadow_type,GdkRectangle  *area,GtkWidget     *widget,gchar	      *detail,gint	       x,gint	       y,gint	       width,gint	       height
</FUNCTION>
<FUNCTION>
<NAME>gtk_paint_cross</NAME>
<RETURNS>void  </RETURNS>
GtkStyle      *style,GdkWindow     *window,GtkStateType   state_type,GtkShadowType  shadow_type,GdkRectangle  *area,GtkWidget     *widget,gchar	      *detail,gint	       x,gint	       y,gint	       width,gint	       height
</FUNCTION>
<FUNCTION>
<NAME>gtk_paint_ramp</NAME>
<RETURNS>void  </RETURNS>
GtkStyle      *style,GdkWindow     *window,GtkStateType   state_type,GtkShadowType  shadow_type,GdkRectangle  *area,GtkWidget     *widget,gchar	      *detail,GtkArrowType   arrow_type,gint	       x,gint	       y,gint	       width,gint	       height
</FUNCTION>
<FUNCTION>
<NAME>gtk_paint_tab</NAME>
<RETURNS>void  </RETURNS>
GtkStyle      *style,GdkWindow     *window,GtkStateType   state_type,GtkShadowType  shadow_type,GdkRectangle  *area,GtkWidget     *widget,gchar	      *detail,gint	       x,gint	       y,gint	       width,gint	       height
</FUNCTION>
<FUNCTION>
<NAME>gtk_paint_shadow_gap</NAME>
<RETURNS>void  </RETURNS>
GtkStyle	  *style,GdkWindow	  *window,GtkStateType	   state_type,GtkShadowType   shadow_type,GdkRectangle	  *area,GtkWidget	  *widget,gchar	  *detail,gint		   x,gint		   y,gint		   width,gint		   height,GtkPositionType gap_side,gint		   gap_x,gint		   gap_width
</FUNCTION>
<FUNCTION>
<NAME>gtk_paint_box_gap</NAME>
<RETURNS>void  </RETURNS>
GtkStyle       *style,GdkWindow      *window,GtkStateType	state_type,GtkShadowType	shadow_type,GdkRectangle   *area,GtkWidget      *widget,gchar	       *detail,gint		x,gint		y,gint		width,gint		height,GtkPositionType gap_side,gint		gap_x,gint		gap_width
</FUNCTION>
<FUNCTION>
<NAME>gtk_paint_extension</NAME>
<RETURNS>void  </RETURNS>
GtkStyle	 *style,GdkWindow	 *window,GtkStateType	  state_type,GtkShadowType	  shadow_type,GdkRectangle	 *area,GtkWidget	 *widget,gchar		 *detail,gint		  x,gint		  y,gint		  width,gint		  height,GtkPositionType gap_side
</FUNCTION>
<FUNCTION>
<NAME>gtk_paint_focus</NAME>
<RETURNS>void  </RETURNS>
GtkStyle      *style,GdkWindow     *window,GdkRectangle  *area,GtkWidget     *widget,gchar	      *detail,gint	       x,gint	       y,gint	       width,gint	       height
</FUNCTION>
<FUNCTION>
<NAME>gtk_paint_slider</NAME>
<RETURNS>void  </RETURNS>
GtkStyle      *style,GdkWindow     *window,GtkStateType   state_type,GtkShadowType  shadow_type,GdkRectangle  *area,GtkWidget     *widget,gchar	      *detail,gint	       x,gint	       y,gint	       width,gint	       height,GtkOrientation orientation
</FUNCTION>
<FUNCTION>
<NAME>gtk_paint_handle</NAME>
<RETURNS>void  </RETURNS>
GtkStyle      *style,GdkWindow     *window,GtkStateType   state_type,GtkShadowType  shadow_type,GdkRectangle  *area,GtkWidget     *widget,gchar	      *detail,gint	       x,gint	       y,gint	       width,gint	       height,GtkOrientation orientation
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_TABLE</NAME>
#define GTK_TYPE_TABLE			(gtk_table_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_TABLE</NAME>
#define GTK_TABLE(obj)			(GTK_CHECK_CAST ((obj), GTK_TYPE_TABLE, GtkTable))
</MACRO>
<MACRO>
<NAME>GTK_TABLE_CLASS</NAME>
#define GTK_TABLE_CLASS(klass)		(GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_TABLE, GtkTableClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_TABLE</NAME>
#define GTK_IS_TABLE(obj)		(GTK_CHECK_TYPE ((obj), GTK_TYPE_TABLE))
</MACRO>
<MACRO>
<NAME>GTK_IS_TABLE_CLASS</NAME>
#define GTK_IS_TABLE_CLASS(klass)	(GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_TABLE))
</MACRO>
<STRUCT>
<NAME>GtkTable</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkTableClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkTableChild</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkTableRowCol</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkTable</NAME>
struct GtkTable
{
  GtkContainer container;
  
  GList *children;
  GtkTableRowCol *rows;
  GtkTableRowCol *cols;
  guint16 nrows;
  guint16 ncols;
  guint16 column_spacing;
  guint16 row_spacing;
  guint homogeneous : 1;
};
</STRUCT>
<STRUCT>
<NAME>GtkTableChild</NAME>
struct GtkTableChild
{
  GtkWidget *widget;
  guint16 left_attach;
  guint16 right_attach;
  guint16 top_attach;
  guint16 bottom_attach;
  guint16 xpadding;
  guint16 ypadding;
  guint xexpand : 1;
  guint yexpand : 1;
  guint xshrink : 1;
  guint yshrink : 1;
  guint xfill : 1;
  guint yfill : 1;
};
</STRUCT>
<STRUCT>
<NAME>GtkTableRowCol</NAME>
struct GtkTableRowCol
{
  guint16 requisition;
  guint16 allocation;
  guint16 spacing;
  guint need_expand : 1;
  guint need_shrink : 1;
  guint expand : 1;
  guint shrink : 1;
  guint empty : 1;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_table_get_type</NAME>
<RETURNS>GtkType 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_table_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
guint		rows,guint		columns,gboolean		homogeneous
</FUNCTION>
<FUNCTION>
<NAME>gtk_table_resize</NAME>
<RETURNS>void 	</RETURNS>
GtkTable	       *table,guint            rows,guint            columns
</FUNCTION>
<FUNCTION>
<NAME>gtk_table_attach</NAME>
<RETURNS>void 	</RETURNS>
GtkTable	       *table,GtkWidget       *child,guint		left_attach,guint		right_attach,guint		top_attach,guint		bottom_attach,GtkAttachOptions xoptions,GtkAttachOptions yoptions,guint		xpadding,guint		ypadding
</FUNCTION>
<FUNCTION>
<NAME>gtk_table_attach_defaults</NAME>
<RETURNS>void 	</RETURNS>
GtkTable	       *table,GtkWidget       *widget,guint		left_attach,guint		right_attach,guint		top_attach,guint		bottom_attach
</FUNCTION>
<FUNCTION>
<NAME>gtk_table_set_row_spacing</NAME>
<RETURNS>void 	</RETURNS>
GtkTable	       *table,guint		row,guint		spacing
</FUNCTION>
<FUNCTION>
<NAME>gtk_table_set_col_spacing</NAME>
<RETURNS>void 	</RETURNS>
GtkTable	       *table,guint		column,guint		spacing
</FUNCTION>
<FUNCTION>
<NAME>gtk_table_set_row_spacings</NAME>
<RETURNS>void 	</RETURNS>
GtkTable	       *table,guint		spacing
</FUNCTION>
<FUNCTION>
<NAME>gtk_table_set_col_spacings</NAME>
<RETURNS>void 	</RETURNS>
GtkTable	       *table,guint		spacing
</FUNCTION>
<FUNCTION>
<NAME>gtk_table_set_homogeneous</NAME>
<RETURNS>void 	</RETURNS>
GtkTable	       *table,gboolean		homogeneous
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_TEAROFF_MENU_ITEM</NAME>
#define GTK_TYPE_TEAROFF_MENU_ITEM	      (gtk_tearoff_menu_item_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_TEAROFF_MENU_ITEM</NAME>
#define GTK_TEAROFF_MENU_ITEM(obj)	      (GTK_CHECK_CAST ((obj), GTK_TYPE_TEAROFF_MENU_ITEM, GtkTearoffMenuItem))
</MACRO>
<MACRO>
<NAME>GTK_TEAROFF_MENU_ITEM_CLASS</NAME>
#define GTK_TEAROFF_MENU_ITEM_CLASS(klass)    (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_TEAROFF_MENU_ITEM, GtkTearoffMenuItemClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_TEAROFF_MENU_ITEM</NAME>
#define GTK_IS_TEAROFF_MENU_ITEM(obj)	      (GTK_CHECK_TYPE ((obj), GTK_TYPE_TEAROFF_MENU_ITEM))
</MACRO>
<MACRO>
<NAME>GTK_IS_TEAROFF_MENU_ITEM_CLASS</NAME>
#define GTK_IS_TEAROFF_MENU_ITEM_CLASS(klass) (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_TEAROFF_MENU_ITEM))
</MACRO>
<STRUCT>
<NAME>GtkTearoffMenuItem</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkTearoffMenuItemClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkTearoffMenuItem</NAME>
struct GtkTearoffMenuItem
{
  GtkMenuItem menu_item;

  guint torn_off : 1;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_tearoff_menu_item_get_type</NAME>
<RETURNS>GtkType 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_tearoff_menu_item_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_TEXT</NAME>
#define GTK_TYPE_TEXT                  (gtk_text_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_TEXT</NAME>
#define GTK_TEXT(obj)                  (GTK_CHECK_CAST ((obj), GTK_TYPE_TEXT, GtkText))
</MACRO>
<MACRO>
<NAME>GTK_TEXT_CLASS</NAME>
#define GTK_TEXT_CLASS(klass)          (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_TEXT, GtkTextClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_TEXT</NAME>
#define GTK_IS_TEXT(obj)               (GTK_CHECK_TYPE ((obj), GTK_TYPE_TEXT))
</MACRO>
<MACRO>
<NAME>GTK_IS_TEXT_CLASS</NAME>
#define GTK_IS_TEXT_CLASS(klass)       (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_TEXT))
</MACRO>
<STRUCT>
<NAME>GtkTextFont</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkPropertyMark</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkText</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkTextClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkPropertyMark</NAME>
struct GtkPropertyMark
{
  /* Position in list. */
  GList* property;

  /* Offset into that property. */
  guint offset;

  /* Current index. */
  guint index;
};
</STRUCT>
<STRUCT>
<NAME>GtkText</NAME>
struct GtkText
{
  GtkEditable editable;

  GdkWindow *text_area;

  GtkAdjustment *hadj;
  GtkAdjustment *vadj;

  GdkGC *gc;

  GdkPixmap* line_wrap_bitmap;
  GdkPixmap* line_arrow_bitmap;

		      /* GAPPED TEXT SEGMENT */

  /* The text, a single segment of text a'la emacs, with a gap
   * where insertion occurs. */
  union { GdkWChar *wc; guchar  *ch; } text;
</STRUCT>
<FUNCTION>
<NAME>gtk_text_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_text_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GtkAdjustment *hadj,GtkAdjustment *vadj
</FUNCTION>
<FUNCTION>
<NAME>gtk_text_set_editable</NAME>
<RETURNS>void  </RETURNS>
GtkText       *text,gboolean       editable
</FUNCTION>
<FUNCTION>
<NAME>gtk_text_set_word_wrap</NAME>
<RETURNS>void  </RETURNS>
GtkText       *text,gint           word_wrap
</FUNCTION>
<FUNCTION>
<NAME>gtk_text_set_line_wrap</NAME>
<RETURNS>void  </RETURNS>
GtkText       *text,gint           line_wrap
</FUNCTION>
<FUNCTION>
<NAME>gtk_text_set_adjustments</NAME>
<RETURNS>void  </RETURNS>
GtkText       *text,GtkAdjustment *hadj,GtkAdjustment *vadj
</FUNCTION>
<FUNCTION>
<NAME>gtk_text_set_point</NAME>
<RETURNS>void  </RETURNS>
GtkText       *text,guint          index
</FUNCTION>
<FUNCTION>
<NAME>gtk_text_get_point</NAME>
<RETURNS>guint  </RETURNS>
GtkText       *text
</FUNCTION>
<FUNCTION>
<NAME>gtk_text_get_length</NAME>
<RETURNS>guint  </RETURNS>
GtkText       *text
</FUNCTION>
<FUNCTION>
<NAME>gtk_text_freeze</NAME>
<RETURNS>void  </RETURNS>
GtkText       *text
</FUNCTION>
<FUNCTION>
<NAME>gtk_text_thaw</NAME>
<RETURNS>void  </RETURNS>
GtkText       *text
</FUNCTION>
<FUNCTION>
<NAME>gtk_text_insert</NAME>
<RETURNS>void  </RETURNS>
GtkText       *text,GdkFont       *font,GdkColor      *fore,GdkColor      *back,const char    *chars,gint           length
</FUNCTION>
<FUNCTION>
<NAME>gtk_text_backward_delete</NAME>
<RETURNS>gint  </RETURNS>
GtkText       *text,guint          nchars
</FUNCTION>
<FUNCTION>
<NAME>gtk_text_forward_delete</NAME>
<RETURNS>gint  </RETURNS>
GtkText       *text,guint          nchars
</FUNCTION>
<MACRO>
<NAME>GTK_TEXT_INDEX</NAME>
#define GTK_TEXT_INDEX(t, index)	(((t)->use_wchar) \
	? ((index) < (t)->gap_position ? (t)->text.wc[index] : \
					(t)->text.wc[(index)+(t)->gap_size]) \
	: ((index) < (t)->gap_position ? (t)->text.ch[index] : \
					(t)->text.ch[(index)+(t)->gap_size]))
</MACRO>
<STRUCT>
<NAME>GtkThemeEngine</NAME>
struct GtkThemeEngine {
  /* Fill in engine_data pointer in a GtkRcStyle by parsing contents
   * of brackets. Returns G_TOKEN_NONE if succesfull, otherwise returns
   * the token it expected but didn't get.
   */
  guint (*parse_rc_style)    (GScanner *scanner, GtkRcStyle *rc_style);
  
  /* Combine RC style data from src into dest. If 
   * dest->engine_data is NULL, it should be initialized to default
   * values.
   */
  void (*merge_rc_style)    (GtkRcStyle *dest,     GtkRcStyle *src);

  /* Fill in style->engine_data from rc_style->engine_data */
  void (*rc_style_to_style) (GtkStyle   *style, GtkRcStyle *rc_style);

  /* Duplicate engine_data from src to dest. The engine_data will
   * not subsequently be modified except by a call to realize_style()
   * so if realize_style() does nothing, refcounting is appropriate.
   */
  void (*duplicate_style)   (GtkStyle *dest,       GtkStyle *src);

  /* If style needs to initialize for a particular colormap/depth
   * combination, do it here. style->colormap/style->depth will have
   * been set at this point, and style itself initialized for 
   * the colormap
   */
  void (*realize_style) (GtkStyle   *new_style);

  /* If style needs to clean up for a particular colormap/depth
   * combination, do it here. 
   */
  void (*unrealize_style) (GtkStyle   *new_style);

  /* Clean up rc_style->engine_data before rc_style is destroyed */
  void (*destroy_rc_style)  (GtkRcStyle *rc_style);

  /* Clean up style->engine_data before style is destroyed */
  void (*destroy_style)     (GtkStyle   *style);

  void (*set_background) (GtkStyle     *style,
			  GdkWindow    *window,
			  GtkStateType  state_type);
};
</STRUCT>
<FUNCTION>
<NAME>gtk_theme_engine_get</NAME>
<RETURNS>GtkThemeEngine  *</RETURNS>
gchar          *name
</FUNCTION>
<FUNCTION>
<NAME>gtk_theme_engine_ref</NAME>
<RETURNS>void  </RETURNS>
GtkThemeEngine *engine
</FUNCTION>
<FUNCTION>
<NAME>gtk_theme_engine_unref</NAME>
<RETURNS>void  </RETURNS>
GtkThemeEngine *engine
</FUNCTION>
<FUNCTION>
<NAME>gtk_themes_init</NAME>
<RETURNS>void 	</RETURNS>
int	       *argc,char	     ***argv
</FUNCTION>
<FUNCTION>
<NAME>gtk_themes_exit</NAME>
<RETURNS>void 	</RETURNS>
gint		error_code
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_TIPS_QUERY</NAME>
#define	GTK_TYPE_TIPS_QUERY		(gtk_tips_query_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_TIPS_QUERY</NAME>
#define GTK_TIPS_QUERY(obj)		(GTK_CHECK_CAST ((obj), GTK_TYPE_TIPS_QUERY, GtkTipsQuery))
</MACRO>
<MACRO>
<NAME>GTK_TIPS_QUERY_CLASS</NAME>
#define GTK_TIPS_QUERY_CLASS(klass)	(GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_TIPS_QUERY, GtkTipsQueryClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_TIPS_QUERY</NAME>
#define GTK_IS_TIPS_QUERY(obj)		(GTK_CHECK_TYPE ((obj), GTK_TYPE_TIPS_QUERY))
</MACRO>
<MACRO>
<NAME>GTK_IS_TIPS_QUERY_CLASS</NAME>
#define GTK_IS_TIPS_QUERY_CLASS(klass)	(GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_TIPS_QUERY))
</MACRO>
<STRUCT>
<NAME>GtkTipsQuery</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkTipsQueryClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkTipsQuery</NAME>
struct GtkTipsQuery
{
  GtkLabel	label;

  guint		emit_always : 1;
  guint		in_query : 1;
  gchar		*label_inactive;
  gchar		*label_no_tip;

  GtkWidget	*caller;
  GtkWidget	*last_crossed;

  GdkCursor	*query_cursor;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_tips_query_get_type</NAME>
<RETURNS>GtkType 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_tips_query_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_tips_query_start_query</NAME>
<RETURNS>void 	</RETURNS>
GtkTipsQuery	*tips_query
</FUNCTION>
<FUNCTION>
<NAME>gtk_tips_query_stop_query</NAME>
<RETURNS>void 	</RETURNS>
GtkTipsQuery	*tips_query
</FUNCTION>
<FUNCTION>
<NAME>gtk_tips_query_set_caller</NAME>
<RETURNS>void 	</RETURNS>
GtkTipsQuery	*tips_query,GtkWidget	*caller
</FUNCTION>
<FUNCTION>
<NAME>gtk_tips_query_set_labels</NAME>
<RETURNS>void 	</RETURNS>
GtkTipsQuery   *tips_query,const gchar    *label_inactive,const gchar    *label_no_tip
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_TOGGLE_BUTTON</NAME>
#define GTK_TYPE_TOGGLE_BUTTON                  (gtk_toggle_button_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_TOGGLE_BUTTON</NAME>
#define GTK_TOGGLE_BUTTON(obj)                  (GTK_CHECK_CAST ((obj), GTK_TYPE_TOGGLE_BUTTON, GtkToggleButton))
</MACRO>
<MACRO>
<NAME>GTK_TOGGLE_BUTTON_CLASS</NAME>
#define GTK_TOGGLE_BUTTON_CLASS(klass)          (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_TOGGLE_BUTTON, GtkToggleButtonClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_TOGGLE_BUTTON</NAME>
#define GTK_IS_TOGGLE_BUTTON(obj)               (GTK_CHECK_TYPE ((obj), GTK_TYPE_TOGGLE_BUTTON))
</MACRO>
<MACRO>
<NAME>GTK_IS_TOGGLE_BUTTON_CLASS</NAME>
#define GTK_IS_TOGGLE_BUTTON_CLASS(klass)       (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_TOGGLE_BUTTON))
</MACRO>
<STRUCT>
<NAME>GtkToggleButton</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkToggleButtonClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkToggleButton</NAME>
struct GtkToggleButton
{
  GtkButton button;

  guint active : 1;
  guint draw_indicator : 1;
  
  GdkWindow *event_window;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_toggle_button_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_toggle_button_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_toggle_button_new_with_label</NAME>
<RETURNS>GtkWidget *</RETURNS>
const gchar     *label
</FUNCTION>
<FUNCTION>
<NAME>gtk_toggle_button_set_mode</NAME>
<RETURNS>void  </RETURNS>
GtkToggleButton *toggle_button,gboolean         draw_indicator
</FUNCTION>
<FUNCTION>
<NAME>gtk_toggle_button_set_active</NAME>
<RETURNS>void  </RETURNS>
GtkToggleButton *toggle_button,gboolean         is_active
</FUNCTION>
<FUNCTION>
<NAME>gtk_toggle_button_get_active</NAME>
<RETURNS>gboolean  </RETURNS>
GtkToggleButton *toggle_button
</FUNCTION>
<FUNCTION>
<NAME>gtk_toggle_button_toggled</NAME>
<RETURNS>void  </RETURNS>
GtkToggleButton *toggle_button
</FUNCTION>
<MACRO>
<NAME>GTK_TOOLBAR</NAME>
#define GTK_TOOLBAR(obj)	 GTK_CHECK_CAST (obj, gtk_toolbar_get_type (), GtkToolbar)
</MACRO>
<MACRO>
<NAME>GTK_TOOLBAR_CLASS</NAME>
#define GTK_TOOLBAR_CLASS(klass) GTK_CHECK_CLASS_CAST (klass, gtk_toolbar_get_type (), GtkToolbarClass)
</MACRO>
<MACRO>
<NAME>GTK_IS_TOOLBAR</NAME>
#define GTK_IS_TOOLBAR(obj)      GTK_CHECK_TYPE (obj, gtk_toolbar_get_type ())
</MACRO>
<ENUM>
<NAME>GtkToolbarChildType</NAME>
typedef enum
{
  GTK_TOOLBAR_CHILD_SPACE,
  GTK_TOOLBAR_CHILD_BUTTON,
  GTK_TOOLBAR_CHILD_TOGGLEBUTTON,
  GTK_TOOLBAR_CHILD_RADIOBUTTON,
  GTK_TOOLBAR_CHILD_WIDGET
} GtkToolbarChildType;
</ENUM>
<ENUM>
<NAME>GtkToolbarSpaceStyle</NAME>
typedef enum
{
  GTK_TOOLBAR_SPACE_EMPTY,
  GTK_TOOLBAR_SPACE_LINE
} GtkToolbarSpaceStyle;
</ENUM>
<STRUCT>
<NAME>GtkToolbarChild</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkToolbar</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkToolbarClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkToolbarChild</NAME>
struct GtkToolbarChild
{
  GtkToolbarChildType type;
  GtkWidget *widget;
  GtkWidget *icon;
  GtkWidget *label;
};
</STRUCT>
<STRUCT>
<NAME>GtkToolbar</NAME>
struct GtkToolbar
{
  GtkContainer container;

  gint             num_children;
  GList           *children;
  GtkOrientation   orientation;
  GtkToolbarStyle  style;
  gint             space_size; /* big optional space between buttons */
  GtkToolbarSpaceStyle space_style;

  GtkTooltips     *tooltips;

  gint             button_maxw;
  gint             button_maxh;
  GtkReliefStyle   relief;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_toolbar_get_type</NAME>
<RETURNS>guint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_toolbar_new</NAME>
<RETURNS>GtkWidget  *</RETURNS>
GtkOrientation   orientation,GtkToolbarStyle  style
</FUNCTION>
<FUNCTION>
<NAME>gtk_toolbar_append_item</NAME>
<RETURNS>GtkWidget  *</RETURNS>
GtkToolbar      *toolbar,const char      *text,const char      *tooltip_text,const char      *tooltip_private_text,GtkWidget       *icon,GtkSignalFunc    callback,gpointer         user_data
</FUNCTION>
<FUNCTION>
<NAME>gtk_toolbar_prepend_item</NAME>
<RETURNS>GtkWidget  *</RETURNS>
GtkToolbar      *toolbar,const char      *text,const char      *tooltip_text,const char      *tooltip_private_text,GtkWidget       *icon,GtkSignalFunc    callback,gpointer         user_data
</FUNCTION>
<FUNCTION>
<NAME>gtk_toolbar_insert_item</NAME>
<RETURNS>GtkWidget  *</RETURNS>
GtkToolbar      *toolbar,const char      *text,const char      *tooltip_text,const char      *tooltip_private_text,GtkWidget       *icon,GtkSignalFunc    callback,gpointer         user_data,gint             position
</FUNCTION>
<FUNCTION>
<NAME>gtk_toolbar_append_space</NAME>
<RETURNS>void  </RETURNS>
GtkToolbar      *toolbar
</FUNCTION>
<FUNCTION>
<NAME>gtk_toolbar_prepend_space</NAME>
<RETURNS>void  </RETURNS>
GtkToolbar      *toolbar
</FUNCTION>
<FUNCTION>
<NAME>gtk_toolbar_insert_space</NAME>
<RETURNS>void  </RETURNS>
GtkToolbar      *toolbar,gint             position
</FUNCTION>
<FUNCTION>
<NAME>gtk_toolbar_append_element</NAME>
<RETURNS>GtkWidget  *</RETURNS>
GtkToolbar      *toolbar,GtkToolbarChildType type,GtkWidget       *widget,const char      *text,const char      *tooltip_text,const char      *tooltip_private_text,GtkWidget       *icon,GtkSignalFunc    callback,gpointer         user_data
</FUNCTION>
<FUNCTION>
<NAME>gtk_toolbar_prepend_element</NAME>
<RETURNS>GtkWidget  *</RETURNS>
GtkToolbar      *toolbar,GtkToolbarChildType type,GtkWidget       *widget,const char      *text,const char      *tooltip_text,const char      *tooltip_private_text,GtkWidget       *icon,GtkSignalFunc    callback,gpointer         user_data
</FUNCTION>
<FUNCTION>
<NAME>gtk_toolbar_insert_element</NAME>
<RETURNS>GtkWidget  *</RETURNS>
GtkToolbar      *toolbar,GtkToolbarChildType type,GtkWidget       *widget,const char      *text,const char      *tooltip_text,const char      *tooltip_private_text,GtkWidget       *icon,GtkSignalFunc    callback,gpointer         user_data,gint             position
</FUNCTION>
<FUNCTION>
<NAME>gtk_toolbar_append_widget</NAME>
<RETURNS>void  </RETURNS>
GtkToolbar      *toolbar,GtkWidget       *widget,const char      *tooltip_text,const char      *tooltip_private_text
</FUNCTION>
<FUNCTION>
<NAME>gtk_toolbar_prepend_widget</NAME>
<RETURNS>void  </RETURNS>
GtkToolbar      *toolbar,GtkWidget       *widget,const char      *tooltip_text,const char	*tooltip_private_text
</FUNCTION>
<FUNCTION>
<NAME>gtk_toolbar_insert_widget</NAME>
<RETURNS>void  </RETURNS>
GtkToolbar      *toolbar,GtkWidget       *widget,const char      *tooltip_text,const char      *tooltip_private_text,gint             position
</FUNCTION>
<FUNCTION>
<NAME>gtk_toolbar_set_orientation</NAME>
<RETURNS>void  </RETURNS>
GtkToolbar           *toolbar,GtkOrientation        orientation
</FUNCTION>
<FUNCTION>
<NAME>gtk_toolbar_set_style</NAME>
<RETURNS>void  </RETURNS>
GtkToolbar           *toolbar,GtkToolbarStyle       style
</FUNCTION>
<FUNCTION>
<NAME>gtk_toolbar_set_space_size</NAME>
<RETURNS>void  </RETURNS>
GtkToolbar           *toolbar,gint                  space_size
</FUNCTION>
<FUNCTION>
<NAME>gtk_toolbar_set_space_style</NAME>
<RETURNS>void  </RETURNS>
GtkToolbar           *toolbar,GtkToolbarSpaceStyle  space_style
</FUNCTION>
<FUNCTION>
<NAME>gtk_toolbar_set_tooltips</NAME>
<RETURNS>void  </RETURNS>
GtkToolbar           *toolbar,gint                  enable
</FUNCTION>
<FUNCTION>
<NAME>gtk_toolbar_set_button_relief</NAME>
<RETURNS>void  </RETURNS>
GtkToolbar           *toolbar,GtkReliefStyle        relief
</FUNCTION>
<FUNCTION>
<NAME>gtk_toolbar_get_button_relief</NAME>
<RETURNS>GtkReliefStyle  </RETURNS>
GtkToolbar           *toolbar
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_TOOLTIPS</NAME>
#define GTK_TYPE_TOOLTIPS                  (gtk_tooltips_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_TOOLTIPS</NAME>
#define GTK_TOOLTIPS(obj)                  (GTK_CHECK_CAST ((obj), GTK_TYPE_TOOLTIPS, GtkTooltips))
</MACRO>
<MACRO>
<NAME>GTK_TOOLTIPS_CLASS</NAME>
#define GTK_TOOLTIPS_CLASS(klass)          (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_TOOLTIPS, GtkTooltipsClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_TOOLTIPS</NAME>
#define GTK_IS_TOOLTIPS(obj)               (GTK_CHECK_TYPE ((obj), GTK_TYPE_TOOLTIPS))
</MACRO>
<MACRO>
<NAME>GTK_IS_TOOLTIPS_CLASS</NAME>
#define GTK_IS_TOOLTIPS_CLASS(klass)       (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_TOOLTIPS))
</MACRO>
<STRUCT>
<NAME>GtkTooltips</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkTooltipsClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkTooltipsData</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkTooltipsData</NAME>
struct GtkTooltipsData
{
  GtkTooltips *tooltips;
  GtkWidget *widget;
  gchar *tip_text;
  gchar *tip_private;
  GdkFont *font;
  gint width;
  GList *row;
};
</STRUCT>
<STRUCT>
<NAME>GtkTooltips</NAME>
struct GtkTooltips
{
  GtkData data;

  GtkWidget *tip_window;
  GtkTooltipsData *active_tips_data;
  GList *tips_data_list;

  GdkGC *gc;
  GdkColor *foreground;
  GdkColor *background;

  guint   delay : 30;
  guint	  enabled : 1;
  gint	  timer_tag;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_tooltips_get_type</NAME>
<RETURNS>GtkType 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_tooltips_new</NAME>
<RETURNS>GtkTooltips *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_tooltips_enable</NAME>
<RETURNS>void 	</RETURNS>
GtkTooltips   *tooltips
</FUNCTION>
<FUNCTION>
<NAME>gtk_tooltips_disable</NAME>
<RETURNS>void 	</RETURNS>
GtkTooltips   *tooltips
</FUNCTION>
<FUNCTION>
<NAME>gtk_tooltips_set_delay</NAME>
<RETURNS>void 	</RETURNS>
GtkTooltips   *tooltips,guint	   delay
</FUNCTION>
<FUNCTION>
<NAME>gtk_tooltips_set_tip</NAME>
<RETURNS>void 	</RETURNS>
GtkTooltips   *tooltips,GtkWidget	  *widget,const gchar   *tip_text,const gchar   *tip_private
</FUNCTION>
<FUNCTION>
<NAME>gtk_tooltips_set_colors</NAME>
<RETURNS>void 	</RETURNS>
GtkTooltips   *tooltips,GdkColor	  *background,GdkColor	  *foreground
</FUNCTION>
<FUNCTION>
<NAME>gtk_tooltips_data_get</NAME>
<RETURNS>GtkTooltipsData *</RETURNS>
GtkWidget	  *widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_tooltips_force_window</NAME>
<RETURNS>void  </RETURNS>
GtkTooltips   *tooltips
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_TREE</NAME>
#define GTK_TYPE_TREE                  (gtk_tree_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_TREE</NAME>
#define GTK_TREE(obj)                  (GTK_CHECK_CAST ((obj), GTK_TYPE_TREE, GtkTree))
</MACRO>
<MACRO>
<NAME>GTK_TREE_CLASS</NAME>
#define GTK_TREE_CLASS(klass)          (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_TREE, GtkTreeClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_TREE</NAME>
#define GTK_IS_TREE(obj)               (GTK_CHECK_TYPE ((obj), GTK_TYPE_TREE))
</MACRO>
<MACRO>
<NAME>GTK_IS_TREE_CLASS</NAME>
#define GTK_IS_TREE_CLASS(klass)       (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_TREE))
</MACRO>
<MACRO>
<NAME>GTK_IS_ROOT_TREE</NAME>
#define GTK_IS_ROOT_TREE(obj)   ((GtkObject*) GTK_TREE(obj)->root_tree == (GtkObject*)obj)
</MACRO>
<MACRO>
<NAME>GTK_TREE_ROOT_TREE</NAME>
#define GTK_TREE_ROOT_TREE(obj) (GTK_TREE(obj)->root_tree ? GTK_TREE(obj)->root_tree : GTK_TREE(obj))
</MACRO>
<MACRO>
<NAME>GTK_TREE_SELECTION</NAME>
#define GTK_TREE_SELECTION(obj) (GTK_TREE_ROOT_TREE(obj)->selection)
</MACRO>
<ENUM>
<NAME>GtkTreeViewMode</NAME>
typedef enum 
{
  GTK_TREE_VIEW_LINE,  /* default view mode */
  GTK_TREE_VIEW_ITEM
} GtkTreeViewMode;
</ENUM>
<STRUCT>
<NAME>GtkTree</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkTreeClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkTree</NAME>
struct GtkTree
{
  GtkContainer container;
  
  GList *children;
  
  GtkTree* root_tree; /* owner of selection list */
  GtkWidget* tree_owner;
  GList *selection;
  guint level;
  guint indent_value;
  guint current_indent;
  guint selection_mode : 2;
  guint view_mode : 1;
  guint view_line : 1;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_tree_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_tree_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_tree_append</NAME>
<RETURNS>void  </RETURNS>
GtkTree          *tree,GtkWidget        *tree_item
</FUNCTION>
<FUNCTION>
<NAME>gtk_tree_prepend</NAME>
<RETURNS>void  </RETURNS>
GtkTree          *tree,GtkWidget        *tree_item
</FUNCTION>
<FUNCTION>
<NAME>gtk_tree_insert</NAME>
<RETURNS>void  </RETURNS>
GtkTree          *tree,GtkWidget        *tree_item,gint              position
</FUNCTION>
<FUNCTION>
<NAME>gtk_tree_remove_items</NAME>
<RETURNS>void  </RETURNS>
GtkTree          *tree,GList            *items
</FUNCTION>
<FUNCTION>
<NAME>gtk_tree_clear_items</NAME>
<RETURNS>void  </RETURNS>
GtkTree          *tree,gint              start,gint              end
</FUNCTION>
<FUNCTION>
<NAME>gtk_tree_select_item</NAME>
<RETURNS>void  </RETURNS>
GtkTree          *tree,gint              item
</FUNCTION>
<FUNCTION>
<NAME>gtk_tree_unselect_item</NAME>
<RETURNS>void  </RETURNS>
GtkTree          *tree,gint              item
</FUNCTION>
<FUNCTION>
<NAME>gtk_tree_select_child</NAME>
<RETURNS>void  </RETURNS>
GtkTree          *tree,GtkWidget        *tree_item
</FUNCTION>
<FUNCTION>
<NAME>gtk_tree_unselect_child</NAME>
<RETURNS>void  </RETURNS>
GtkTree          *tree,GtkWidget        *tree_item
</FUNCTION>
<FUNCTION>
<NAME>gtk_tree_child_position</NAME>
<RETURNS>gint  </RETURNS>
GtkTree          *tree,GtkWidget        *child
</FUNCTION>
<FUNCTION>
<NAME>gtk_tree_set_selection_mode</NAME>
<RETURNS>void  </RETURNS>
GtkTree          *tree,GtkSelectionMode  mode
</FUNCTION>
<FUNCTION>
<NAME>gtk_tree_set_view_mode</NAME>
<RETURNS>void  </RETURNS>
GtkTree          *tree,GtkTreeViewMode   mode
</FUNCTION>
<FUNCTION>
<NAME>gtk_tree_set_view_lines</NAME>
<RETURNS>void  </RETURNS>
GtkTree          *tree,guint            flag
</FUNCTION>
<FUNCTION>
<NAME>gtk_tree_remove_item</NAME>
<RETURNS>void  </RETURNS>
GtkTree          *tree,GtkWidget        *child
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_TREE_ITEM</NAME>
#define GTK_TYPE_TREE_ITEM              (gtk_tree_item_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_TREE_ITEM</NAME>
#define GTK_TREE_ITEM(obj)              (GTK_CHECK_CAST ((obj), GTK_TYPE_TREE_ITEM, GtkTreeItem))
</MACRO>
<MACRO>
<NAME>GTK_TREE_ITEM_CLASS</NAME>
#define GTK_TREE_ITEM_CLASS(klass)      (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_TREE_ITEM, GtkTreeItemClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_TREE_ITEM</NAME>
#define GTK_IS_TREE_ITEM(obj)           (GTK_CHECK_TYPE ((obj), GTK_TYPE_TREE_ITEM))
</MACRO>
<MACRO>
<NAME>GTK_IS_TREE_ITEM_CLASS</NAME>
#define GTK_IS_TREE_ITEM_CLASS(klass)   (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_TREE_ITEM))
</MACRO>
<MACRO>
<NAME>GTK_TREE_ITEM_SUBTREE</NAME>
#define GTK_TREE_ITEM_SUBTREE(obj)      (GTK_TREE_ITEM(obj)->subtree)
</MACRO>
<STRUCT>
<NAME>GtkTreeItem</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkTreeItemClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkTreeItem</NAME>
struct GtkTreeItem
{
  GtkItem item;

  GtkWidget *subtree;
  GtkWidget *pixmaps_box;
  GtkWidget *plus_pix_widget, *minus_pix_widget;

  GList *pixmaps;		/* pixmap node for this items color depth */

  guint expanded : 1;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_tree_item_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_tree_item_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_tree_item_new_with_label</NAME>
<RETURNS>GtkWidget *</RETURNS>
gchar       *label
</FUNCTION>
<FUNCTION>
<NAME>gtk_tree_item_set_subtree</NAME>
<RETURNS>void  </RETURNS>
GtkTreeItem *tree_item,GtkWidget   *subtree
</FUNCTION>
<FUNCTION>
<NAME>gtk_tree_item_remove_subtree</NAME>
<RETURNS>void  </RETURNS>
GtkTreeItem *tree_item
</FUNCTION>
<FUNCTION>
<NAME>gtk_tree_item_select</NAME>
<RETURNS>void  </RETURNS>
GtkTreeItem *tree_item
</FUNCTION>
<FUNCTION>
<NAME>gtk_tree_item_deselect</NAME>
<RETURNS>void  </RETURNS>
GtkTreeItem *tree_item
</FUNCTION>
<FUNCTION>
<NAME>gtk_tree_item_expand</NAME>
<RETURNS>void  </RETURNS>
GtkTreeItem *tree_item
</FUNCTION>
<FUNCTION>
<NAME>gtk_tree_item_collapse</NAME>
<RETURNS>void  </RETURNS>
GtkTreeItem *tree_item
</FUNCTION>
<VARIABLE>
<NAME>GTK_TYPE_ACCEL_FLAGS</NAME>
extern GtkType GTK_TYPE_ACCEL_FLAGS;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_CALENDAR_DISPLAY_OPTIONS</NAME>
extern GtkType GTK_TYPE_CALENDAR_DISPLAY_OPTIONS;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_CELL_TYPE</NAME>
extern GtkType GTK_TYPE_CELL_TYPE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_CLIST_DRAG_POS</NAME>
extern GtkType GTK_TYPE_CLIST_DRAG_POS;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_BUTTON_ACTION</NAME>
extern GtkType GTK_TYPE_BUTTON_ACTION;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_CTREE_POS</NAME>
extern GtkType GTK_TYPE_CTREE_POS;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_CTREE_LINE_STYLE</NAME>
extern GtkType GTK_TYPE_CTREE_LINE_STYLE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_CTREE_EXPANDER_STYLE</NAME>
extern GtkType GTK_TYPE_CTREE_EXPANDER_STYLE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_CTREE_EXPANSION_TYPE</NAME>
extern GtkType GTK_TYPE_CTREE_EXPANSION_TYPE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_DEBUG_FLAG</NAME>
extern GtkType GTK_TYPE_DEBUG_FLAG;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_DEST_DEFAULTS</NAME>
extern GtkType GTK_TYPE_DEST_DEFAULTS;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_TARGET_FLAGS</NAME>
extern GtkType GTK_TYPE_TARGET_FLAGS;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_ARROW_TYPE</NAME>
extern GtkType GTK_TYPE_ARROW_TYPE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_ATTACH_OPTIONS</NAME>
extern GtkType GTK_TYPE_ATTACH_OPTIONS;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_BUTTON_BOX_STYLE</NAME>
extern GtkType GTK_TYPE_BUTTON_BOX_STYLE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_CURVE_TYPE</NAME>
extern GtkType GTK_TYPE_CURVE_TYPE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_DIRECTION_TYPE</NAME>
extern GtkType GTK_TYPE_DIRECTION_TYPE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_JUSTIFICATION</NAME>
extern GtkType GTK_TYPE_JUSTIFICATION;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_MATCH_TYPE</NAME>
extern GtkType GTK_TYPE_MATCH_TYPE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_MENU_DIRECTION_TYPE</NAME>
extern GtkType GTK_TYPE_MENU_DIRECTION_TYPE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_MENU_FACTORY_TYPE</NAME>
extern GtkType GTK_TYPE_MENU_FACTORY_TYPE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_METRIC_TYPE</NAME>
extern GtkType GTK_TYPE_METRIC_TYPE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_ORIENTATION</NAME>
extern GtkType GTK_TYPE_ORIENTATION;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_CORNER_TYPE</NAME>
extern GtkType GTK_TYPE_CORNER_TYPE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_PACK_TYPE</NAME>
extern GtkType GTK_TYPE_PACK_TYPE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_PATH_PRIORITY_TYPE</NAME>
extern GtkType GTK_TYPE_PATH_PRIORITY_TYPE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_PATH_TYPE</NAME>
extern GtkType GTK_TYPE_PATH_TYPE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_POLICY_TYPE</NAME>
extern GtkType GTK_TYPE_POLICY_TYPE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_POSITION_TYPE</NAME>
extern GtkType GTK_TYPE_POSITION_TYPE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_PREVIEW_TYPE</NAME>
extern GtkType GTK_TYPE_PREVIEW_TYPE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_RELIEF_STYLE</NAME>
extern GtkType GTK_TYPE_RELIEF_STYLE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_RESIZE_MODE</NAME>
extern GtkType GTK_TYPE_RESIZE_MODE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_SIGNAL_RUN_TYPE</NAME>
extern GtkType GTK_TYPE_SIGNAL_RUN_TYPE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_SCROLL_TYPE</NAME>
extern GtkType GTK_TYPE_SCROLL_TYPE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_SELECTION_MODE</NAME>
extern GtkType GTK_TYPE_SELECTION_MODE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_SHADOW_TYPE</NAME>
extern GtkType GTK_TYPE_SHADOW_TYPE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_STATE_TYPE</NAME>
extern GtkType GTK_TYPE_STATE_TYPE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_SUBMENU_DIRECTION</NAME>
extern GtkType GTK_TYPE_SUBMENU_DIRECTION;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_SUBMENU_PLACEMENT</NAME>
extern GtkType GTK_TYPE_SUBMENU_PLACEMENT;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_TOOLBAR_STYLE</NAME>
extern GtkType GTK_TYPE_TOOLBAR_STYLE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_TROUGH_TYPE</NAME>
extern GtkType GTK_TYPE_TROUGH_TYPE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_UPDATE_TYPE</NAME>
extern GtkType GTK_TYPE_UPDATE_TYPE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_VISIBILITY</NAME>
extern GtkType GTK_TYPE_VISIBILITY;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_WINDOW_POSITION</NAME>
extern GtkType GTK_TYPE_WINDOW_POSITION;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_WINDOW_TYPE</NAME>
extern GtkType GTK_TYPE_WINDOW_TYPE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_SORT_TYPE</NAME>
extern GtkType GTK_TYPE_SORT_TYPE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_FONT_METRIC_TYPE</NAME>
extern GtkType GTK_TYPE_FONT_METRIC_TYPE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_FONT_TYPE</NAME>
extern GtkType GTK_TYPE_FONT_TYPE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_FONT_FILTER_TYPE</NAME>
extern GtkType GTK_TYPE_FONT_FILTER_TYPE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_OBJECT_FLAGS</NAME>
extern GtkType GTK_TYPE_OBJECT_FLAGS;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_ARG_FLAGS</NAME>
extern GtkType GTK_TYPE_ARG_FLAGS;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_PACKER_OPTIONS</NAME>
extern GtkType GTK_TYPE_PACKER_OPTIONS;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_SIDE_TYPE</NAME>
extern GtkType GTK_TYPE_SIDE_TYPE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_ANCHOR_TYPE</NAME>
extern GtkType GTK_TYPE_ANCHOR_TYPE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_PRIVATE_FLAGS</NAME>
extern GtkType GTK_TYPE_PRIVATE_FLAGS;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_PROGRESS_BAR_STYLE</NAME>
extern GtkType GTK_TYPE_PROGRESS_BAR_STYLE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_PROGRESS_BAR_ORIENTATION</NAME>
extern GtkType GTK_TYPE_PROGRESS_BAR_ORIENTATION;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_RC_FLAGS</NAME>
extern GtkType GTK_TYPE_RC_FLAGS;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_RC_TOKEN_TYPE</NAME>
extern GtkType GTK_TYPE_RC_TOKEN_TYPE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_SPIN_BUTTON_UPDATE_POLICY</NAME>
extern GtkType GTK_TYPE_SPIN_BUTTON_UPDATE_POLICY;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_SPIN_TYPE</NAME>
extern GtkType GTK_TYPE_SPIN_TYPE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_TOOLBAR_CHILD_TYPE</NAME>
extern GtkType GTK_TYPE_TOOLBAR_CHILD_TYPE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_TOOLBAR_SPACE_STYLE</NAME>
extern GtkType GTK_TYPE_TOOLBAR_SPACE_STYLE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_TREE_VIEW_MODE</NAME>
extern GtkType GTK_TYPE_TREE_VIEW_MODE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_FUNDAMENTAL_TYPE</NAME>
extern GtkType GTK_TYPE_FUNDAMENTAL_TYPE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_WIDGET_FLAGS</NAME>
extern GtkType GTK_TYPE_WIDGET_FLAGS;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GDK_WINDOW_TYPE</NAME>
extern GtkType GTK_TYPE_GDK_WINDOW_TYPE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GDK_WINDOW_CLASS</NAME>
extern GtkType GTK_TYPE_GDK_WINDOW_CLASS;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GDK_IMAGE_TYPE</NAME>
extern GtkType GTK_TYPE_GDK_IMAGE_TYPE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GDK_VISUAL_TYPE</NAME>
extern GtkType GTK_TYPE_GDK_VISUAL_TYPE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GDK_FONT_TYPE</NAME>
extern GtkType GTK_TYPE_GDK_FONT_TYPE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GDK_WINDOW_ATTRIBUTES_TYPE</NAME>
extern GtkType GTK_TYPE_GDK_WINDOW_ATTRIBUTES_TYPE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GDK_WINDOW_HINTS</NAME>
extern GtkType GTK_TYPE_GDK_WINDOW_HINTS;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GDK_FUNCTION</NAME>
extern GtkType GTK_TYPE_GDK_FUNCTION;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GDK_FILL</NAME>
extern GtkType GTK_TYPE_GDK_FILL;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GDK_FILL_RULE</NAME>
extern GtkType GTK_TYPE_GDK_FILL_RULE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GDK_LINE_STYLE</NAME>
extern GtkType GTK_TYPE_GDK_LINE_STYLE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GDK_CAP_STYLE</NAME>
extern GtkType GTK_TYPE_GDK_CAP_STYLE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GDK_JOIN_STYLE</NAME>
extern GtkType GTK_TYPE_GDK_JOIN_STYLE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GDK_CURSOR_TYPE</NAME>
extern GtkType GTK_TYPE_GDK_CURSOR_TYPE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GDK_FILTER_RETURN</NAME>
extern GtkType GTK_TYPE_GDK_FILTER_RETURN;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GDK_VISIBILITY_STATE</NAME>
extern GtkType GTK_TYPE_GDK_VISIBILITY_STATE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GDK_EVENT_TYPE</NAME>
extern GtkType GTK_TYPE_GDK_EVENT_TYPE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GDK_EVENT_MASK</NAME>
extern GtkType GTK_TYPE_GDK_EVENT_MASK;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GDK_NOTIFY_TYPE</NAME>
extern GtkType GTK_TYPE_GDK_NOTIFY_TYPE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GDK_CROSSING_MODE</NAME>
extern GtkType GTK_TYPE_GDK_CROSSING_MODE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GDK_MODIFIER_TYPE</NAME>
extern GtkType GTK_TYPE_GDK_MODIFIER_TYPE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GDK_SUBWINDOW_MODE</NAME>
extern GtkType GTK_TYPE_GDK_SUBWINDOW_MODE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GDK_INPUT_CONDITION</NAME>
extern GtkType GTK_TYPE_GDK_INPUT_CONDITION;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GDK_STATUS</NAME>
extern GtkType GTK_TYPE_GDK_STATUS;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GDK_BYTE_ORDER</NAME>
extern GtkType GTK_TYPE_GDK_BYTE_ORDER;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GDK_GC_VALUES_MASK</NAME>
extern GtkType GTK_TYPE_GDK_GC_VALUES_MASK;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GDK_SELECTION</NAME>
extern GtkType GTK_TYPE_GDK_SELECTION;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GDK_PROPERTY_STATE</NAME>
extern GtkType GTK_TYPE_GDK_PROPERTY_STATE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GDK_PROP_MODE</NAME>
extern GtkType GTK_TYPE_GDK_PROP_MODE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GDK_INPUT_SOURCE</NAME>
extern GtkType GTK_TYPE_GDK_INPUT_SOURCE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GDK_INPUT_MODE</NAME>
extern GtkType GTK_TYPE_GDK_INPUT_MODE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GDK_AXIS_USE</NAME>
extern GtkType GTK_TYPE_GDK_AXIS_USE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GDK_TARGET</NAME>
extern GtkType GTK_TYPE_GDK_TARGET;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GDK_SELECTION_TYPE</NAME>
extern GtkType GTK_TYPE_GDK_SELECTION_TYPE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GDK_EXTENSION_MODE</NAME>
extern GtkType GTK_TYPE_GDK_EXTENSION_MODE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GDK_IM_STYLE</NAME>
extern GtkType GTK_TYPE_GDK_IM_STYLE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GDK_IC_ATTRIBUTES_TYPE</NAME>
extern GtkType GTK_TYPE_GDK_IC_ATTRIBUTES_TYPE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GDK_WM_DECORATION</NAME>
extern GtkType GTK_TYPE_GDK_WM_DECORATION;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GDK_WM_FUNCTION</NAME>
extern GtkType GTK_TYPE_GDK_WM_FUNCTION;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GDK_COLOR_CONTEXT_MODE</NAME>
extern GtkType GTK_TYPE_GDK_COLOR_CONTEXT_MODE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GDK_OVERLAP_TYPE</NAME>
extern GtkType GTK_TYPE_GDK_OVERLAP_TYPE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GDK_DRAG_ACTION</NAME>
extern GtkType GTK_TYPE_GDK_DRAG_ACTION;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GDK_DRAG_PROTOCOL</NAME>
extern GtkType GTK_TYPE_GDK_DRAG_PROTOCOL;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GDK_RGB_DITHER</NAME>
extern GtkType GTK_TYPE_GDK_RGB_DITHER;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_ACCEL_GROUP</NAME>
extern GtkType GTK_TYPE_ACCEL_GROUP;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_SELECTION_DATA</NAME>
extern GtkType GTK_TYPE_SELECTION_DATA;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_STYLE</NAME>
extern GtkType GTK_TYPE_STYLE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_CTREE_NODE</NAME>
extern GtkType GTK_TYPE_CTREE_NODE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GDK_COLORMAP</NAME>
extern GtkType GTK_TYPE_GDK_COLORMAP;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GDK_VISUAL</NAME>
extern GtkType GTK_TYPE_GDK_VISUAL;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GDK_FONT</NAME>
extern GtkType GTK_TYPE_GDK_FONT;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GDK_WINDOW</NAME>
extern GtkType GTK_TYPE_GDK_WINDOW;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GDK_DRAG_CONTEXT</NAME>
extern GtkType GTK_TYPE_GDK_DRAG_CONTEXT;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GDK_EVENT</NAME>
extern GtkType GTK_TYPE_GDK_EVENT;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GDK_COLOR</NAME>
extern GtkType GTK_TYPE_GDK_COLOR;
</VARIABLE>
<MACRO>
<NAME>GTK_TYPE_NUM_BUILTINS</NAME>
#define	GTK_TYPE_NUM_BUILTINS	(121)
</MACRO>
<ENUM>
<NAME>GtkFundamentalType</NAME>
typedef enum
{
  GTK_TYPE_INVALID,
  GTK_TYPE_NONE,
  
  /* flat types */
  GTK_TYPE_CHAR,
  GTK_TYPE_UCHAR,
  GTK_TYPE_BOOL,
  GTK_TYPE_INT,
  GTK_TYPE_UINT,
  GTK_TYPE_LONG,
  GTK_TYPE_ULONG,
  GTK_TYPE_FLOAT,
  GTK_TYPE_DOUBLE,
  GTK_TYPE_STRING,
  GTK_TYPE_ENUM,
  GTK_TYPE_FLAGS,
  GTK_TYPE_BOXED,
  GTK_TYPE_POINTER,
  
  /* structured types */
  GTK_TYPE_SIGNAL,
  GTK_TYPE_ARGS,
  GTK_TYPE_CALLBACK,
  GTK_TYPE_C_CALLBACK,
  GTK_TYPE_FOREIGN,
  
  /* base type node of the object system */
  GTK_TYPE_OBJECT
} GtkFundamentalType;
</ENUM>
<MACRO>
<NAME>GTK_TYPE_FLAT_FIRST</NAME>
#define	GTK_TYPE_FLAT_FIRST		GTK_TYPE_CHAR
</MACRO>
<MACRO>
<NAME>GTK_TYPE_FLAT_LAST</NAME>
#define	GTK_TYPE_FLAT_LAST		GTK_TYPE_POINTER
</MACRO>
<MACRO>
<NAME>GTK_TYPE_STRUCTURED_FIRST</NAME>
#define	GTK_TYPE_STRUCTURED_FIRST	GTK_TYPE_SIGNAL
</MACRO>
<MACRO>
<NAME>GTK_TYPE_STRUCTURED_LAST</NAME>
#define	GTK_TYPE_STRUCTURED_LAST	GTK_TYPE_FOREIGN
</MACRO>
<MACRO>
<NAME>GTK_TYPE_FUNDAMENTAL_LAST</NAME>
#define	GTK_TYPE_FUNDAMENTAL_LAST	GTK_TYPE_OBJECT
</MACRO>
<MACRO>
<NAME>GTK_TYPE_FUNDAMENTAL_MAX</NAME>
#define	GTK_TYPE_FUNDAMENTAL_MAX	(32)
</MACRO>
<MACRO>
<NAME>GTK_STRUCT_OFFSET</NAME>
#define GTK_STRUCT_OFFSET(struct, field)        ((gint) offsetof (struct, field))
</MACRO>
<MACRO>
<NAME>GTK_STRUCT_OFFSET</NAME>
#define GTK_STRUCT_OFFSET(struct, field)        ((gint) ((gchar*) &((struct*) 0)->field))
</MACRO>
<MACRO>
<NAME>GTK_CHECK_CAST</NAME>
#  define GTK_CHECK_CAST(tobj, cast_type, cast)       ((cast*) (tobj))
</MACRO>
<MACRO>
<NAME>GTK_CHECK_CLASS_CAST</NAME>
#  define GTK_CHECK_CLASS_CAST(tclass,cast_type,cast) ((cast*) (tclass))
</MACRO>
<MACRO>
<NAME>GTK_CHECK_CAST</NAME>
#  define GTK_CHECK_CAST(tobj, cast_type, cast) \
      ((cast*) gtk_type_check_object_cast ((GtkTypeObject*) (tobj), (cast_type)))
</MACRO>
<MACRO>
<NAME>GTK_CHECK_CLASS_CAST</NAME>
#  define GTK_CHECK_CLASS_CAST(tclass,cast_type,cast) \
      ((cast*) gtk_type_check_class_cast ((GtkTypeClass*) (tclass), (cast_type)))
</MACRO>
<MACRO>
<NAME>GTK_CHECK_TYPE</NAME>
#define GTK_CHECK_TYPE(type_object, otype)       ( \
  ((GtkTypeObject*) (type_object)) != NULL && \
  GTK_CHECK_CLASS_TYPE (((GtkTypeObject*) (type_object))->klass, (otype)) \
)
</MACRO>
<MACRO>
<NAME>GTK_CHECK_CLASS_TYPE</NAME>
#define GTK_CHECK_CLASS_TYPE(type_class, otype)  ( \
  ((GtkTypeClass*) (type_class)) != NULL && \
  gtk_type_is_a (((GtkTypeClass*) (type_class))->type, (otype)) \
)
</MACRO>
<TYPEDEF>
<NAME>GtkType</NAME>
typedef guint GtkType;
</TYPEDEF>
<STRUCT>
<NAME>GtkTypeObject</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkTypeClass</NAME>
</STRUCT>
<MACRO>
<NAME>GTK_TYPE_IDENTIFIER</NAME>
#define		GTK_TYPE_IDENTIFIER		(gtk_identifier_get_type ())
</MACRO>
<FUNCTION>
<NAME>gtk_identifier_get_type</NAME>
<RETURNS>GtkType 	</RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_MAKE</NAME>
#define GTK_TYPE_MAKE(parent_t, seqno)	(((seqno) << 8) | GTK_FUNDAMENTAL_TYPE (parent_t))
</MACRO>
<MACRO>
<NAME>GTK_FUNDAMENTAL_TYPE</NAME>
#define GTK_FUNDAMENTAL_TYPE(type)	((GtkFundamentalType) ((type) & 0xFF))
</MACRO>
<MACRO>
<NAME>GTK_TYPE_SEQNO</NAME>
#define GTK_TYPE_SEQNO(type)		((type) > 0xFF ? (type) >> 8 : (type))
</MACRO>
<STRUCT>
<NAME>GtkArg</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkObject</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkTypeInfo</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkTypeQuery</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkEnumValue</NAME>
</STRUCT>
<MACRO>
<NAME>GTK_SIGNAL_FUNC</NAME>
#define GTK_SIGNAL_FUNC(f)  ((GtkSignalFunc) f)
</MACRO>
<USER_FUNCTION>
<NAME>GtkClassInitFunc</NAME>
<RETURNS>void </RETURNS>
gpointer   klass
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GtkObjectInitFunc</NAME>
<RETURNS>void </RETURNS>
gpointer   object,
				    gpointer   klass
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GtkSignalFunc</NAME>
<RETURNS>void </RETURNS>

</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GtkFunction</NAME>
<RETURNS>gint </RETURNS>
gpointer   data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GtkDestroyNotify</NAME>
<RETURNS>void </RETURNS>
gpointer   data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GtkCallbackMarshal</NAME>
<RETURNS>void </RETURNS>
GtkObject *object,
				    gpointer   data,
				    guint      n_args,
				    GtkArg    *args
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GtkSignalMarshaller</NAME>
<RETURNS>void </RETURNS>
GtkObject      *object,
				     GtkSignalFunc   func,
				     gpointer        func_data,
				     GtkArg         *args
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GtkArgGetFunc</NAME>
<RETURNS>void </RETURNS>
GtkObject*, GtkArg*, guint
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GtkArgSetFunc</NAME>
<RETURNS>void </RETURNS>
GtkObject*, GtkArg*, guint
</USER_FUNCTION>
<STRUCT>
<NAME>GtkTypeObject</NAME>
struct GtkTypeObject
{
  /* A pointer to the objects class. This will actually point to
   *  the derived objects class struct (which will be derived from
   *  GtkTypeClass).
   */
  GtkTypeClass	*klass;
};
</STRUCT>
<STRUCT>
<NAME>GtkArg</NAME>
struct GtkArg
{
  GtkType type;
  gchar *name;
  
  /* this union only defines the required storage types for
   * the possibile values, thus there is no gint enum_data field,
   * because that would just be a mere alias for gint int_data.
   * use the GTK_VALUE_*() and GTK_RETLOC_*() macros to access
   * the discrete memebers.
   */
  union {
    /* flat values */
    gchar char_data;
    guchar uchar_data;
    gboolean bool_data;
    gint int_data;
    guint uint_data;
    glong long_data;
    gulong ulong_data;
    gfloat float_data;
    gdouble double_data;
    gchar *string_data;
    gpointer pointer_data;
    GtkObject *object_data;
    
    /* structured values */
    struct {
      GtkSignalFunc f;
      gpointer d;
    } signal_data;
    struct {
      gint n_args;
      GtkArg *args;
    } args_data;
    struct {
      GtkCallbackMarshal marshal;
      gpointer data;
      GtkDestroyNotify notify;
    } callback_data;
    struct {
      GtkFunction func;
      gpointer func_data;
    } c_callback_data;
    struct {
      gpointer data;
      GtkDestroyNotify notify;
    } foreign_data;
  } d;
};
</STRUCT>
<MACRO>
<NAME>GTK_VALUE_CHAR</NAME>
#define GTK_VALUE_CHAR(a)	((a).d.char_data)
</MACRO>
<MACRO>
<NAME>GTK_VALUE_UCHAR</NAME>
#define GTK_VALUE_UCHAR(a)	((a).d.uchar_data)
</MACRO>
<MACRO>
<NAME>GTK_VALUE_BOOL</NAME>
#define GTK_VALUE_BOOL(a)	((a).d.bool_data)
</MACRO>
<MACRO>
<NAME>GTK_VALUE_INT</NAME>
#define GTK_VALUE_INT(a)	((a).d.int_data)
</MACRO>
<MACRO>
<NAME>GTK_VALUE_UINT</NAME>
#define GTK_VALUE_UINT(a)	((a).d.uint_data)
</MACRO>
<MACRO>
<NAME>GTK_VALUE_LONG</NAME>
#define GTK_VALUE_LONG(a)	((a).d.long_data)
</MACRO>
<MACRO>
<NAME>GTK_VALUE_ULONG</NAME>
#define GTK_VALUE_ULONG(a)	((a).d.ulong_data)
</MACRO>
<MACRO>
<NAME>GTK_VALUE_FLOAT</NAME>
#define GTK_VALUE_FLOAT(a)	((a).d.float_data)
</MACRO>
<MACRO>
<NAME>GTK_VALUE_DOUBLE</NAME>
#define GTK_VALUE_DOUBLE(a)	((a).d.double_data)
</MACRO>
<MACRO>
<NAME>GTK_VALUE_STRING</NAME>
#define GTK_VALUE_STRING(a)	((a).d.string_data)
</MACRO>
<MACRO>
<NAME>GTK_VALUE_ENUM</NAME>
#define GTK_VALUE_ENUM(a)	((a).d.int_data)
</MACRO>
<MACRO>
<NAME>GTK_VALUE_FLAGS</NAME>
#define GTK_VALUE_FLAGS(a)	((a).d.uint_data)
</MACRO>
<MACRO>
<NAME>GTK_VALUE_BOXED</NAME>
#define GTK_VALUE_BOXED(a)	((a).d.pointer_data)
</MACRO>
<MACRO>
<NAME>GTK_VALUE_POINTER</NAME>
#define GTK_VALUE_POINTER(a)	((a).d.pointer_data)
</MACRO>
<MACRO>
<NAME>GTK_VALUE_OBJECT</NAME>
#define GTK_VALUE_OBJECT(a)	((a).d.object_data)
</MACRO>
<MACRO>
<NAME>GTK_VALUE_SIGNAL</NAME>
#define GTK_VALUE_SIGNAL(a)	((a).d.signal_data)
</MACRO>
<MACRO>
<NAME>GTK_VALUE_ARGS</NAME>
#define GTK_VALUE_ARGS(a)	((a).d.args_data)
</MACRO>
<MACRO>
<NAME>GTK_VALUE_CALLBACK</NAME>
#define GTK_VALUE_CALLBACK(a)	((a).d.callback_data)
</MACRO>
<MACRO>
<NAME>GTK_VALUE_C_CALLBACK</NAME>
#define GTK_VALUE_C_CALLBACK(a) ((a).d.c_callback_data)
</MACRO>
<MACRO>
<NAME>GTK_VALUE_FOREIGN</NAME>
#define GTK_VALUE_FOREIGN(a)	((a).d.foreign_data)
</MACRO>
<MACRO>
<NAME>GTK_RETLOC_CHAR</NAME>
#define GTK_RETLOC_CHAR(a)	((gchar*)	(a).d.pointer_data)
</MACRO>
<MACRO>
<NAME>GTK_RETLOC_UCHAR</NAME>
#define GTK_RETLOC_UCHAR(a)	((guchar*)	(a).d.pointer_data)
</MACRO>
<MACRO>
<NAME>GTK_RETLOC_BOOL</NAME>
#define GTK_RETLOC_BOOL(a)	((gboolean*)	(a).d.pointer_data)
</MACRO>
<MACRO>
<NAME>GTK_RETLOC_INT</NAME>
#define GTK_RETLOC_INT(a)	((gint*)	(a).d.pointer_data)
</MACRO>
<MACRO>
<NAME>GTK_RETLOC_UINT</NAME>
#define GTK_RETLOC_UINT(a)	((guint*)	(a).d.pointer_data)
</MACRO>
<MACRO>
<NAME>GTK_RETLOC_LONG</NAME>
#define GTK_RETLOC_LONG(a)	((glong*)	(a).d.pointer_data)
</MACRO>
<MACRO>
<NAME>GTK_RETLOC_ULONG</NAME>
#define GTK_RETLOC_ULONG(a)	((gulong*)	(a).d.pointer_data)
</MACRO>
<MACRO>
<NAME>GTK_RETLOC_FLOAT</NAME>
#define GTK_RETLOC_FLOAT(a)	((gfloat*)	(a).d.pointer_data)
</MACRO>
<MACRO>
<NAME>GTK_RETLOC_DOUBLE</NAME>
#define GTK_RETLOC_DOUBLE(a)	((gdouble*)	(a).d.pointer_data)
</MACRO>
<MACRO>
<NAME>GTK_RETLOC_STRING</NAME>
#define GTK_RETLOC_STRING(a)	((gchar**)	(a).d.pointer_data)
</MACRO>
<MACRO>
<NAME>GTK_RETLOC_ENUM</NAME>
#define GTK_RETLOC_ENUM(a)	((gint*)	(a).d.pointer_data)
</MACRO>
<MACRO>
<NAME>GTK_RETLOC_FLAGS</NAME>
#define GTK_RETLOC_FLAGS(a)	((guint*)	(a).d.pointer_data)
</MACRO>
<MACRO>
<NAME>GTK_RETLOC_BOXED</NAME>
#define GTK_RETLOC_BOXED(a)	((gpointer*)	(a).d.pointer_data)
</MACRO>
<MACRO>
<NAME>GTK_RETLOC_POINTER</NAME>
#define GTK_RETLOC_POINTER(a)	((gpointer*)	(a).d.pointer_data)
</MACRO>
<MACRO>
<NAME>GTK_RETLOC_OBJECT</NAME>
#define GTK_RETLOC_OBJECT(a)	((GtkObject**)	(a).d.pointer_data)
</MACRO>
<STRUCT>
<NAME>GtkTypeInfo</NAME>
struct GtkTypeInfo
{
  gchar			*type_name;
  guint			 object_size;
  guint			 class_size;
  GtkClassInitFunc	 class_init_func;
  GtkObjectInitFunc	 object_init_func;
  gpointer		 reserved_1;
  gpointer		 reserved_2;
  GtkClassInitFunc	 base_class_init_func;
};
</STRUCT>
<STRUCT>
<NAME>GtkTypeQuery</NAME>
struct GtkTypeQuery
{
  GtkType		 type;
  const gchar		*type_name;
  guint			 object_size;
  guint			 class_size;
};
</STRUCT>
<STRUCT>
<NAME>GtkEnumValue</NAME>
struct GtkEnumValue
{
  guint	 value;
  gchar	*value_name;
  gchar *value_nick;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_type_init</NAME>
<RETURNS>void 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_type_unique</NAME>
<RETURNS>GtkType 	</RETURNS>
GtkType	   parent_type,const GtkTypeInfo *type_info
</FUNCTION>
<FUNCTION>
<NAME>gtk_type_set_chunk_alloc</NAME>
<RETURNS>void 	</RETURNS>
GtkType	 type,guint		 n_chunks
</FUNCTION>
<FUNCTION>
<NAME>gtk_type_name</NAME>
<RETURNS>gchar *</RETURNS>
guint		 type
</FUNCTION>
<FUNCTION>
<NAME>gtk_type_from_name</NAME>
<RETURNS>GtkType 	</RETURNS>
const gchar	*name
</FUNCTION>
<FUNCTION>
<NAME>gtk_type_parent</NAME>
<RETURNS>GtkType 	</RETURNS>
GtkType	 type
</FUNCTION>
<FUNCTION>
<NAME>gtk_type_class</NAME>
<RETURNS>gpointer 	</RETURNS>
GtkType	 type
</FUNCTION>
<FUNCTION>
<NAME>gtk_type_parent_class</NAME>
<RETURNS>gpointer 	</RETURNS>
GtkType	 type
</FUNCTION>
<FUNCTION>
<NAME>gtk_type_children_types</NAME>
<RETURNS>GList *</RETURNS>
GtkType	 type
</FUNCTION>
<FUNCTION>
<NAME>gtk_type_new</NAME>
<RETURNS>gpointer 	</RETURNS>
GtkType	 type
</FUNCTION>
<FUNCTION>
<NAME>gtk_type_free</NAME>
<RETURNS>void 	</RETURNS>
GtkType	 type,gpointer	 mem
</FUNCTION>
<FUNCTION>
<NAME>gtk_type_describe_heritage</NAME>
<RETURNS>void 	</RETURNS>
GtkType	 type
</FUNCTION>
<FUNCTION>
<NAME>gtk_type_describe_tree</NAME>
<RETURNS>void 	</RETURNS>
GtkType	 type,gboolean	 show_size
</FUNCTION>
<FUNCTION>
<NAME>gtk_type_is_a</NAME>
<RETURNS>gboolean 	</RETURNS>
GtkType	 type,GtkType	 is_a_type
</FUNCTION>
<FUNCTION>
<NAME>gtk_type_check_object_cast</NAME>
<RETURNS>GtkTypeObject *</RETURNS>
GtkTypeObject	*type_object,GtkType         cast_type
</FUNCTION>
<FUNCTION>
<NAME>gtk_type_check_class_cast</NAME>
<RETURNS>GtkTypeClass *</RETURNS>
GtkTypeClass	*klass,GtkType         cast_type
</FUNCTION>
<FUNCTION>
<NAME>gtk_type_register_enum</NAME>
<RETURNS>GtkType 	</RETURNS>
const gchar	*type_name,GtkEnumValue	*values
</FUNCTION>
<FUNCTION>
<NAME>gtk_type_register_flags</NAME>
<RETURNS>GtkType 	</RETURNS>
const gchar	*type_name,GtkFlagValue	*values
</FUNCTION>
<FUNCTION>
<NAME>gtk_type_enum_get_values</NAME>
<RETURNS>GtkEnumValue *</RETURNS>
GtkType	 enum_type
</FUNCTION>
<FUNCTION>
<NAME>gtk_type_flags_get_values</NAME>
<RETURNS>GtkFlagValue *</RETURNS>
GtkType	 flags_type
</FUNCTION>
<FUNCTION>
<NAME>gtk_type_enum_find_value</NAME>
<RETURNS>GtkEnumValue *</RETURNS>
GtkType	 enum_type,const gchar	*value_name
</FUNCTION>
<FUNCTION>
<NAME>gtk_type_flags_find_value</NAME>
<RETURNS>GtkFlagValue *</RETURNS>
GtkType	 flag_type,const gchar	*value_name
</FUNCTION>
<FUNCTION>
<NAME>gtk_type_set_varargs_type</NAME>
<RETURNS>void 	</RETURNS>
GtkType	foreign_type,GtkType	varargs_type
</FUNCTION>
<FUNCTION>
<NAME>gtk_type_get_varargs_type</NAME>
<RETURNS>GtkType 	</RETURNS>
GtkType	foreign_type
</FUNCTION>
<FUNCTION>
<NAME>gtk_type_query</NAME>
<RETURNS>GtkTypeQuery *</RETURNS>
GtkType	type
</FUNCTION>
<MACRO>
<NAME>GTK_VBUTTON_BOX</NAME>
#define GTK_VBUTTON_BOX(obj)          GTK_CHECK_CAST (obj, gtk_vbutton_box_get_type (), GtkVButtonBox)
</MACRO>
<MACRO>
<NAME>GTK_VBUTTON_BOX_CLASS</NAME>
#define GTK_VBUTTON_BOX_CLASS(klass)  GTK_CHECK_CLASS_CAST (klass, gtk_vbutton_box_get_type (), GtkVButtonBoxClass)
</MACRO>
<MACRO>
<NAME>GTK_IS_VBUTTON_BOX</NAME>
#define GTK_IS_VBUTTON_BOX(obj)       GTK_CHECK_TYPE (obj, gtk_vbutton_box_get_type ())
</MACRO>
<STRUCT>
<NAME>GtkVButtonBox</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkVButtonBoxClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkVButtonBox</NAME>
struct GtkVButtonBox
{
  GtkButtonBox button_box;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_vbutton_box_get_type</NAME>
<RETURNS>guint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_vbutton_box_new</NAME>
<RETURNS>GtkWidget  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_vbutton_box_get_spacing_default</NAME>
<RETURNS>gint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_vbutton_box_set_spacing_default</NAME>
<RETURNS>void  </RETURNS>
gint spacing
</FUNCTION>
<FUNCTION>
<NAME>gtk_vbutton_box_get_layout_default</NAME>
<RETURNS>GtkButtonBoxStyle  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_vbutton_box_set_layout_default</NAME>
<RETURNS>void  </RETURNS>
GtkButtonBoxStyle layout
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_VBOX</NAME>
#define GTK_TYPE_VBOX		 (gtk_vbox_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_VBOX</NAME>
#define GTK_VBOX(obj)		 (GTK_CHECK_CAST ((obj), GTK_TYPE_VBOX, GtkVBox))
</MACRO>
<MACRO>
<NAME>GTK_VBOX_CLASS</NAME>
#define GTK_VBOX_CLASS(klass)	 (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_VBOX, GtkVBoxClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_VBOX</NAME>
#define GTK_IS_VBOX(obj)	 (GTK_CHECK_TYPE ((obj), GTK_TYPE_VBOX))
</MACRO>
<MACRO>
<NAME>GTK_IS_VBOX_CLASS</NAME>
#define GTK_IS_VBOX_CLASS(klass) (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_VBOX))
</MACRO>
<STRUCT>
<NAME>GtkVBox</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkVBoxClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkVBox</NAME>
struct GtkVBox
{
  GtkBox box;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_vbox_get_type</NAME>
<RETURNS>GtkType 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_vbox_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
gboolean homogeneous,gint spacing
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_VIEWPORT</NAME>
#define GTK_TYPE_VIEWPORT            (gtk_viewport_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_VIEWPORT</NAME>
#define GTK_VIEWPORT(obj)            (GTK_CHECK_CAST ((obj), GTK_TYPE_VIEWPORT, GtkViewport))
</MACRO>
<MACRO>
<NAME>GTK_VIEWPORT_CLASS</NAME>
#define GTK_VIEWPORT_CLASS(klass)    (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_VIEWPORT, GtkViewportClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_VIEWPORT</NAME>
#define GTK_IS_VIEWPORT(obj)         (GTK_CHECK_TYPE ((obj), GTK_TYPE_VIEWPORT))
</MACRO>
<MACRO>
<NAME>GTK_IS_VIEWPORT_CLASS</NAME>
#define GTK_IS_VIEWPORT_CLASS(klass) (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_VIEWPORT))
</MACRO>
<STRUCT>
<NAME>GtkViewport</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkViewportClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkViewport</NAME>
struct GtkViewport
{
  GtkBin bin;

  GtkShadowType shadow_type;
  GdkWindow *view_window;
  GdkWindow *bin_window;
  GtkAdjustment *hadjustment;
  GtkAdjustment *vadjustment;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_viewport_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_viewport_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GtkAdjustment *hadjustment,GtkAdjustment *vadjustment
</FUNCTION>
<FUNCTION>
<NAME>gtk_viewport_get_hadjustment</NAME>
<RETURNS>GtkAdjustment *</RETURNS>
GtkViewport   *viewport
</FUNCTION>
<FUNCTION>
<NAME>gtk_viewport_get_vadjustment</NAME>
<RETURNS>GtkAdjustment *</RETURNS>
GtkViewport   *viewport
</FUNCTION>
<FUNCTION>
<NAME>gtk_viewport_set_hadjustment</NAME>
<RETURNS>void  </RETURNS>
GtkViewport   *viewport,GtkAdjustment *adjustment
</FUNCTION>
<FUNCTION>
<NAME>gtk_viewport_set_vadjustment</NAME>
<RETURNS>void  </RETURNS>
GtkViewport   *viewport,GtkAdjustment *adjustment
</FUNCTION>
<FUNCTION>
<NAME>gtk_viewport_set_shadow_type</NAME>
<RETURNS>void  </RETURNS>
GtkViewport   *viewport,GtkShadowType  type
</FUNCTION>
<MACRO>
<NAME>GTK_VPANED</NAME>
#define GTK_VPANED(obj)          GTK_CHECK_CAST (obj, gtk_vpaned_get_type (), GtkVPaned)
</MACRO>
<MACRO>
<NAME>GTK_VPANED_CLASS</NAME>
#define GTK_VPANED_CLASS(klass)  GTK_CHECK_CLASS_CAST (klass, gtk_vpaned_get_type (), GtkVPanedClass)
</MACRO>
<MACRO>
<NAME>GTK_IS_VPANED</NAME>
#define GTK_IS_VPANED(obj)       GTK_CHECK_TYPE (obj, gtk_vpaned_get_type ())
</MACRO>
<STRUCT>
<NAME>GtkVPaned</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkVPanedClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkVPaned</NAME>
struct GtkVPaned
{
  GtkPaned paned;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_vpaned_get_type</NAME>
<RETURNS>guint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_vpaned_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GTK_VRULER</NAME>
#define GTK_VRULER(obj)          GTK_CHECK_CAST (obj, gtk_vruler_get_type (), GtkVRuler)
</MACRO>
<MACRO>
<NAME>GTK_VRULER_CLASS</NAME>
#define GTK_VRULER_CLASS(klass)  GTK_CHECK_CLASS_CAST (klass, gtk_vruler_get_type (), GtkVRulerClass)
</MACRO>
<MACRO>
<NAME>GTK_IS_VRULER</NAME>
#define GTK_IS_VRULER(obj)       GTK_CHECK_TYPE (obj, gtk_vruler_get_type ())
</MACRO>
<STRUCT>
<NAME>GtkVRuler</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkVRulerClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkVRuler</NAME>
struct GtkVRuler
{
  GtkRuler ruler;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_vruler_get_type</NAME>
<RETURNS>guint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_vruler_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_VSCALE</NAME>
#define GTK_TYPE_VSCALE            (gtk_vscale_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_VSCALE</NAME>
#define GTK_VSCALE(obj)            (GTK_CHECK_CAST ((obj), GTK_TYPE_VSCALE, GtkVScale))
</MACRO>
<MACRO>
<NAME>GTK_VSCALE_CLASS</NAME>
#define GTK_VSCALE_CLASS(klass)    (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_VSCALE, GtkVScaleClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_VSCALE</NAME>
#define GTK_IS_VSCALE(obj)         (GTK_CHECK_TYPE ((obj), GTK_TYPE_VSCALE))
</MACRO>
<MACRO>
<NAME>GTK_IS_VSCALE_CLASS</NAME>
#define GTK_IS_VSCALE_CLASS(klass) (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_VSCALE))
</MACRO>
<STRUCT>
<NAME>GtkVScale</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkVScaleClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkVScale</NAME>
struct GtkVScale
{
  GtkScale scale;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_vscale_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_vscale_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GtkAdjustment *adjustment
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_VSCROLLBAR</NAME>
#define GTK_TYPE_VSCROLLBAR            (gtk_vscrollbar_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_VSCROLLBAR</NAME>
#define GTK_VSCROLLBAR(obj)            (GTK_CHECK_CAST ((obj), GTK_TYPE_VSCROLLBAR, GtkVScrollbar))
</MACRO>
<MACRO>
<NAME>GTK_VSCROLLBAR_CLASS</NAME>
#define GTK_VSCROLLBAR_CLASS(klass)    (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_VSCROLLBAR, GtkVScrollbarClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_VSCROLLBAR</NAME>
#define GTK_IS_VSCROLLBAR(obj)         (GTK_CHECK_TYPE ((obj), GTK_TYPE_VSCROLLBAR))
</MACRO>
<MACRO>
<NAME>GTK_IS_VSCROLLBAR_CLASS</NAME>
#define GTK_IS_VSCROLLBAR_CLASS(klass) (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_VSCROLLBAR))
</MACRO>
<STRUCT>
<NAME>GtkVScrollbar</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkVScrollbarClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkVScrollbar</NAME>
struct GtkVScrollbar
{
  GtkScrollbar scrollbar;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_vscrollbar_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_vscrollbar_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GtkAdjustment *adjustment
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_VSEPARATOR</NAME>
#define GTK_TYPE_VSEPARATOR                  (gtk_vseparator_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_VSEPARATOR</NAME>
#define GTK_VSEPARATOR(obj)                  (GTK_CHECK_CAST ((obj), GTK_TYPE_VSEPARATOR, GtkVSeparator))
</MACRO>
<MACRO>
<NAME>GTK_VSEPARATOR_CLASS</NAME>
#define GTK_VSEPARATOR_CLASS(klass)          (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_VSEPARATOR, GtkVSeparatorClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_VSEPARATOR</NAME>
#define GTK_IS_VSEPARATOR(obj)               (GTK_CHECK_TYPE ((obj), GTK_TYPE_VSEPARATOR))
</MACRO>
<MACRO>
<NAME>GTK_IS_VSEPARATOR_CLASS</NAME>
#define GTK_IS_VSEPARATOR_CLASS(klass)       (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_VSEPARATOR))
</MACRO>
<STRUCT>
<NAME>GtkVSeparator</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkVSeparatorClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkVSeparator</NAME>
struct GtkVSeparator
{
  GtkSeparator separator;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_vseparator_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_vseparator_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GtkWidgetFlags</NAME>
typedef enum
{
  GTK_TOPLEVEL         = 1 << 4,
  GTK_NO_WINDOW        = 1 << 5,
  GTK_REALIZED         = 1 << 6,
  GTK_MAPPED           = 1 << 7,
  GTK_VISIBLE          = 1 << 8,
  GTK_SENSITIVE        = 1 << 9,
  GTK_PARENT_SENSITIVE = 1 << 10,
  GTK_CAN_FOCUS        = 1 << 11,
  GTK_HAS_FOCUS        = 1 << 12,
  GTK_CAN_DEFAULT      = 1 << 13,
  GTK_HAS_DEFAULT      = 1 << 14,
  GTK_HAS_GRAB	       = 1 << 15,
  GTK_RC_STYLE	       = 1 << 16,
  GTK_COMPOSITE_CHILD  = 1 << 17,
  GTK_NO_REPARENT      = 1 << 18,
  GTK_APP_PAINTABLE    = 1 << 19,
  GTK_RECEIVES_DEFAULT = 1 << 20
} GtkWidgetFlags;
</ENUM>
<MACRO>
<NAME>GTK_TYPE_WIDGET</NAME>
#define GTK_TYPE_WIDGET			  (gtk_widget_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_WIDGET</NAME>
#define GTK_WIDGET(widget)		  (GTK_CHECK_CAST ((widget), GTK_TYPE_WIDGET, GtkWidget))
</MACRO>
<MACRO>
<NAME>GTK_WIDGET_CLASS</NAME>
#define GTK_WIDGET_CLASS(klass)		  (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_WIDGET, GtkWidgetClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_WIDGET</NAME>
#define GTK_IS_WIDGET(widget)		  (GTK_CHECK_TYPE ((widget), GTK_TYPE_WIDGET))
</MACRO>
<MACRO>
<NAME>GTK_IS_WIDGET_CLASS</NAME>
#define GTK_IS_WIDGET_CLASS(klass)	  (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_WIDGET))
</MACRO>
<MACRO>
<NAME>GTK_WIDGET_TYPE</NAME>
#define GTK_WIDGET_TYPE(wid)		  (GTK_OBJECT_TYPE (wid))
</MACRO>
<MACRO>
<NAME>GTK_WIDGET_STATE</NAME>
#define GTK_WIDGET_STATE(wid)		  (GTK_WIDGET (wid)->state)
</MACRO>
<MACRO>
<NAME>GTK_WIDGET_SAVED_STATE</NAME>
#define GTK_WIDGET_SAVED_STATE(wid)	  (GTK_WIDGET (wid)->saved_state)
</MACRO>
<MACRO>
<NAME>GTK_WIDGET_FLAGS</NAME>
#define GTK_WIDGET_FLAGS(wid)		  (GTK_OBJECT_FLAGS (wid))
</MACRO>
<MACRO>
<NAME>GTK_WIDGET_TOPLEVEL</NAME>
#define GTK_WIDGET_TOPLEVEL(wid)	  ((GTK_WIDGET_FLAGS (wid) & GTK_TOPLEVEL) != 0)
</MACRO>
<MACRO>
<NAME>GTK_WIDGET_NO_WINDOW</NAME>
#define GTK_WIDGET_NO_WINDOW(wid)	  ((GTK_WIDGET_FLAGS (wid) & GTK_NO_WINDOW) != 0)
</MACRO>
<MACRO>
<NAME>GTK_WIDGET_REALIZED</NAME>
#define GTK_WIDGET_REALIZED(wid)	  ((GTK_WIDGET_FLAGS (wid) & GTK_REALIZED) != 0)
</MACRO>
<MACRO>
<NAME>GTK_WIDGET_MAPPED</NAME>
#define GTK_WIDGET_MAPPED(wid)		  ((GTK_WIDGET_FLAGS (wid) & GTK_MAPPED) != 0)
</MACRO>
<MACRO>
<NAME>GTK_WIDGET_VISIBLE</NAME>
#define GTK_WIDGET_VISIBLE(wid)		  ((GTK_WIDGET_FLAGS (wid) & GTK_VISIBLE) != 0)
</MACRO>
<MACRO>
<NAME>GTK_WIDGET_DRAWABLE</NAME>
#define GTK_WIDGET_DRAWABLE(wid)	  (GTK_WIDGET_VISIBLE (wid) && GTK_WIDGET_MAPPED (wid))
</MACRO>
<MACRO>
<NAME>GTK_WIDGET_SENSITIVE</NAME>
#define GTK_WIDGET_SENSITIVE(wid)	  ((GTK_WIDGET_FLAGS (wid) & GTK_SENSITIVE) != 0)
</MACRO>
<MACRO>
<NAME>GTK_WIDGET_PARENT_SENSITIVE</NAME>
#define GTK_WIDGET_PARENT_SENSITIVE(wid)  ((GTK_WIDGET_FLAGS (wid) & GTK_PARENT_SENSITIVE) != 0)
</MACRO>
<MACRO>
<NAME>GTK_WIDGET_IS_SENSITIVE</NAME>
#define GTK_WIDGET_IS_SENSITIVE(wid)	  (GTK_WIDGET_SENSITIVE (wid) && \
					   GTK_WIDGET_PARENT_SENSITIVE (wid))
</MACRO>
<MACRO>
<NAME>GTK_WIDGET_CAN_FOCUS</NAME>
#define GTK_WIDGET_CAN_FOCUS(wid)	  ((GTK_WIDGET_FLAGS (wid) & GTK_CAN_FOCUS) != 0)
</MACRO>
<MACRO>
<NAME>GTK_WIDGET_HAS_FOCUS</NAME>
#define GTK_WIDGET_HAS_FOCUS(wid)	  ((GTK_WIDGET_FLAGS (wid) & GTK_HAS_FOCUS) != 0)
</MACRO>
<MACRO>
<NAME>GTK_WIDGET_CAN_DEFAULT</NAME>
#define GTK_WIDGET_CAN_DEFAULT(wid)	  ((GTK_WIDGET_FLAGS (wid) & GTK_CAN_DEFAULT) != 0)
</MACRO>
<MACRO>
<NAME>GTK_WIDGET_HAS_DEFAULT</NAME>
#define GTK_WIDGET_HAS_DEFAULT(wid)	  ((GTK_WIDGET_FLAGS (wid) & GTK_HAS_DEFAULT) != 0)
</MACRO>
<MACRO>
<NAME>GTK_WIDGET_HAS_GRAB</NAME>
#define GTK_WIDGET_HAS_GRAB(wid)	  ((GTK_WIDGET_FLAGS (wid) & GTK_HAS_GRAB) != 0)
</MACRO>
<MACRO>
<NAME>GTK_WIDGET_RC_STYLE</NAME>
#define GTK_WIDGET_RC_STYLE(wid)	  ((GTK_WIDGET_FLAGS (wid) & GTK_RC_STYLE) != 0)
</MACRO>
<MACRO>
<NAME>GTK_WIDGET_COMPOSITE_CHILD</NAME>
#define GTK_WIDGET_COMPOSITE_CHILD(wid)	  ((GTK_WIDGET_FLAGS (wid) & GTK_COMPOSITE_CHILD) != 0)
</MACRO>
<MACRO>
<NAME>GTK_WIDGET_APP_PAINTABLE</NAME>
#define GTK_WIDGET_APP_PAINTABLE(wid)	  ((GTK_WIDGET_FLAGS (wid) & GTK_APP_PAINTABLE) != 0)
</MACRO>
<MACRO>
<NAME>GTK_WIDGET_RECEIVES_DEFAULT</NAME>
#define GTK_WIDGET_RECEIVES_DEFAULT(wid)  ((GTK_WIDGET_FLAGS (wid) & GTK_RECEIVES_DEFAULT) != 0)
</MACRO>
<MACRO>
<NAME>GTK_WIDGET_SET_FLAGS</NAME>
#define GTK_WIDGET_SET_FLAGS(wid,flag)	  G_STMT_START{ (GTK_WIDGET_FLAGS (wid) |= (flag)); }G_STMT_END
</MACRO>
<MACRO>
<NAME>GTK_WIDGET_UNSET_FLAGS</NAME>
#define GTK_WIDGET_UNSET_FLAGS(wid,flag)  G_STMT_START{ (GTK_WIDGET_FLAGS (wid) &= ~(flag)); }G_STMT_END
</MACRO>
<STRUCT>
<NAME>GtkRequisition</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkAllocation</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkSelectionData</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkWidgetClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkWidgetAuxInfo</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkWidgetShapeInfo</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>GtkCallback</NAME>
<RETURNS>void </RETURNS>
GtkWidget *widget,
			     gpointer	data
</USER_FUNCTION>
<STRUCT>
<NAME>GtkRequisition</NAME>
struct GtkRequisition
{
  gint16 width;
  gint16 height;
};
</STRUCT>
<STRUCT>
<NAME>GtkAllocation</NAME>
struct GtkAllocation
{
  gint16 x;
  gint16 y;
  guint16 width;
  guint16 height;
};
</STRUCT>
<STRUCT>
<NAME>GtkSelectionData</NAME>
struct GtkSelectionData
{
  GdkAtom selection;
  GdkAtom target;
  GdkAtom type;
  gint	  format;
  guchar *data;
  gint	  length;
};
</STRUCT>
<STRUCT>
<NAME>GtkWidget</NAME>
struct GtkWidget
{
  /* The object structure needs to be the first
   *  element in the widget structure in order for
   *  the object mechanism to work correctly. This
   *  allows a GtkWidget pointer to be cast to a
   *  GtkObject pointer.
   */
  GtkObject object;
  
  /* 16 bits of internally used private flags.
   * this will be packed into the same 4 byte alignment frame that
   * state and saved_state go. we therefore don't waste any new
   * space on this.
   */
  guint16 private_flags;
  
  /* The state of the widget. There are actually only
   *  5 widget states (defined in "gtkenums.h").
   */
  guint8 state;
  
  /* The saved state of the widget. When a widgets state
   *  is changed to GTK_STATE_INSENSITIVE via
   *  "gtk_widget_set_state" or "gtk_widget_set_sensitive"
   *  the old state is kept around in this field. The state
   *  will be restored once the widget gets sensitive again.
   */
  guint8 saved_state;
  
  /* The widgets name. If the widget does not have a name
   *  (the name is NULL), then its name (as returned by
   *  "gtk_widget_get_name") is its classes name.
   * Among other things, the widget name is used to determine
   *  the style to use for a widget.
   */
  gchar *name;
  
  /* The style for the widget. The style contains the
   *  colors the widget should be drawn in for each state
   *  along with graphics contexts used to draw with and
   *  the font to use for text.
   */
  GtkStyle *style;
  
  /* The widgets desired size.
   */
  GtkRequisition requisition;
  
  /* The widgets allocated size.
   */
  GtkAllocation allocation;
  
  /* The widgets window or its parent window if it does
   *  not have a window. (Which will be indicated by the
   *  GTK_NO_WINDOW flag being set).
   */
  GdkWindow *window;
  
  /* The widgets parent.
   */
  GtkWidget *parent;
};
</STRUCT>
<STRUCT>
<NAME>GtkWidgetAuxInfo</NAME>
struct GtkWidgetAuxInfo
{
  gint16  x;
  gint16  y;
  gint16 width;
  gint16 height;
};
</STRUCT>
<STRUCT>
<NAME>GtkWidgetShapeInfo</NAME>
struct GtkWidgetShapeInfo
{
  gint16     offset_x;
  gint16     offset_y;
  GdkBitmap *shape_mask;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_widget_get_type</NAME>
<RETURNS>GtkType 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GtkType		type,const gchar	       *first_arg_name,...
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_newv</NAME>
<RETURNS>GtkWidget *</RETURNS>
GtkType		type,guint		nargs,GtkArg	       *args
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_ref</NAME>
<RETURNS>void 	</RETURNS>
GtkWidget	       *widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_unref</NAME>
<RETURNS>void 	</RETURNS>
GtkWidget	       *widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_destroy</NAME>
<RETURNS>void 	</RETURNS>
GtkWidget	       *widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_destroyed</NAME>
<RETURNS>void 	</RETURNS>
GtkWidget	       *widget,GtkWidget	      **widget_pointer
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_get</NAME>
<RETURNS>void 	</RETURNS>
GtkWidget	       *widget,GtkArg	       *arg
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_getv</NAME>
<RETURNS>void 	</RETURNS>
GtkWidget	       *widget,guint		nargs,GtkArg	       *args
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_set</NAME>
<RETURNS>void 	</RETURNS>
GtkWidget	       *widget,const gchar         *first_arg_name,...
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_setv</NAME>
<RETURNS>void 	</RETURNS>
GtkWidget	       *widget,guint		nargs,GtkArg	       *args
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_unparent</NAME>
<RETURNS>void 	</RETURNS>
GtkWidget	       *widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_show</NAME>
<RETURNS>void 	</RETURNS>
GtkWidget	       *widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_show_now</NAME>
<RETURNS>void  </RETURNS>
GtkWidget           *widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_hide</NAME>
<RETURNS>void 	</RETURNS>
GtkWidget	       *widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_show_all</NAME>
<RETURNS>void 	</RETURNS>
GtkWidget	       *widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_hide_all</NAME>
<RETURNS>void 	</RETURNS>
GtkWidget	       *widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_map</NAME>
<RETURNS>void 	</RETURNS>
GtkWidget	       *widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_unmap</NAME>
<RETURNS>void 	</RETURNS>
GtkWidget	       *widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_realize</NAME>
<RETURNS>void 	</RETURNS>
GtkWidget	       *widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_unrealize</NAME>
<RETURNS>void 	</RETURNS>
GtkWidget	       *widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_queue_draw</NAME>
<RETURNS>void 	</RETURNS>
GtkWidget	       *widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_queue_draw_area</NAME>
<RETURNS>void 	</RETURNS>
GtkWidget	       *widget,gint                 x,gint                 y,gint                 width,gint                 height
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_queue_clear</NAME>
<RETURNS>void 	</RETURNS>
GtkWidget	       *widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_queue_clear_area</NAME>
<RETURNS>void 	</RETURNS>
GtkWidget	       *widget,gint                 x,gint                 y,gint                 width,gint                 height
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_queue_resize</NAME>
<RETURNS>void 	</RETURNS>
GtkWidget	       *widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_draw</NAME>
<RETURNS>void 	</RETURNS>
GtkWidget	       *widget,GdkRectangle	       *area
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_draw_focus</NAME>
<RETURNS>void 	</RETURNS>
GtkWidget	       *widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_draw_default</NAME>
<RETURNS>void 	</RETURNS>
GtkWidget	       *widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_size_request</NAME>
<RETURNS>void 	</RETURNS>
GtkWidget	       *widget,GtkRequisition      *requisition
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_size_allocate</NAME>
<RETURNS>void 	</RETURNS>
GtkWidget	       *widget,GtkAllocation       *allocation
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_get_child_requisition</NAME>
<RETURNS>void  </RETURNS>
GtkWidget	       *widget,GtkRequisition    *requisition
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_add_accelerator</NAME>
<RETURNS>void 	</RETURNS>
GtkWidget           *widget,const gchar         *accel_signal,GtkAccelGroup       *accel_group,guint                accel_key,guint                accel_mods,GtkAccelFlags        accel_flags
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_remove_accelerator</NAME>
<RETURNS>void 	</RETURNS>
GtkWidget           *widget,GtkAccelGroup       *accel_group,guint                accel_key,guint                accel_mods
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_remove_accelerators</NAME>
<RETURNS>void 	</RETURNS>
GtkWidget           *widget,const gchar	       *accel_signal,gboolean		visible_only
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_accelerator_signal</NAME>
<RETURNS>guint 	</RETURNS>
GtkWidget           *widget,GtkAccelGroup       *accel_group,guint                accel_key,guint                accel_mods
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_lock_accelerators</NAME>
<RETURNS>void 	</RETURNS>
GtkWidget	       *widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_unlock_accelerators</NAME>
<RETURNS>void 	</RETURNS>
GtkWidget	       *widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_accelerators_locked</NAME>
<RETURNS>gboolean  </RETURNS>
GtkWidget	       *widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_event</NAME>
<RETURNS>gint 	</RETURNS>
GtkWidget	       *widget,GdkEvent	       *event
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_activate</NAME>
<RETURNS>gboolean  </RETURNS>
GtkWidget	       *widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_set_scroll_adjustments</NAME>
<RETURNS>gboolean  </RETURNS>
GtkWidget        *widget,GtkAdjustment    *hadjustment,GtkAdjustment    *vadjustment
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_reparent</NAME>
<RETURNS>void 	</RETURNS>
GtkWidget	       *widget,GtkWidget	       *new_parent
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_popup</NAME>
<RETURNS>void 	</RETURNS>
GtkWidget	       *widget,gint			x,gint			y
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_intersect</NAME>
<RETURNS>gint 	</RETURNS>
GtkWidget	       *widget,GdkRectangle	       *area,GdkRectangle	       *intersection
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_grab_focus</NAME>
<RETURNS>void 	</RETURNS>
GtkWidget	       *widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_grab_default</NAME>
<RETURNS>void 	</RETURNS>
GtkWidget	       *widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_set_name</NAME>
<RETURNS>void 	</RETURNS>
GtkWidget	       *widget,const gchar	       *name
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_get_name</NAME>
<RETURNS>gchar *</RETURNS>
GtkWidget	       *widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_set_state</NAME>
<RETURNS>void 	</RETURNS>
GtkWidget	       *widget,GtkStateType		state
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_set_sensitive</NAME>
<RETURNS>void 	</RETURNS>
GtkWidget	       *widget,gboolean		sensitive
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_set_app_paintable</NAME>
<RETURNS>void 	</RETURNS>
GtkWidget	       *widget,gboolean		app_paintable
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_set_parent</NAME>
<RETURNS>void 	</RETURNS>
GtkWidget	       *widget,GtkWidget	       *parent
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_set_parent_window</NAME>
<RETURNS>void 	</RETURNS>
GtkWidget	       *widget,GdkWindow	       *parent_window
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_get_parent_window</NAME>
<RETURNS>GdkWindow  *</RETURNS>
GtkWidget	       *widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_set_uposition</NAME>
<RETURNS>void 	</RETURNS>
GtkWidget	       *widget,gint			x,gint			y
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_set_usize</NAME>
<RETURNS>void 	</RETURNS>
GtkWidget	       *widget,gint			width,gint			height
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_set_events</NAME>
<RETURNS>void 	</RETURNS>
GtkWidget	       *widget,gint			events
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_add_events</NAME>
<RETURNS>void  </RETURNS>
GtkWidget           *widget,gint	                events
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_set_extension_events</NAME>
<RETURNS>void 	</RETURNS>
GtkWidget		*widget,GdkExtensionMode	mode
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_get_extension_events</NAME>
<RETURNS>GdkExtensionMode  </RETURNS>
GtkWidget	*widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_get_toplevel</NAME>
<RETURNS>GtkWidget *</RETURNS>
GtkWidget	*widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_get_ancestor</NAME>
<RETURNS>GtkWidget *</RETURNS>
GtkWidget	*widget,GtkType	widget_type
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_get_colormap</NAME>
<RETURNS>GdkColormap *</RETURNS>
GtkWidget	*widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_get_visual</NAME>
<RETURNS>GdkVisual *</RETURNS>
GtkWidget	*widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_set_colormap</NAME>
<RETURNS>void  </RETURNS>
GtkWidget      *widget,GdkColormap    *colormap
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_set_visual</NAME>
<RETURNS>void  </RETURNS>
GtkWidget      *widget,GdkVisual      *visual
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_get_events</NAME>
<RETURNS>gint 	</RETURNS>
GtkWidget	*widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_get_pointer</NAME>
<RETURNS>void 	</RETURNS>
GtkWidget	*widget,gint		*x,gint		*y
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_is_ancestor</NAME>
<RETURNS>gint 	</RETURNS>
GtkWidget	*widget,GtkWidget	*ancestor
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_hide_on_delete</NAME>
<RETURNS>gint 	</RETURNS>
GtkWidget	*widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_set_style</NAME>
<RETURNS>void 	</RETURNS>
GtkWidget	*widget,GtkStyle	*style
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_set_rc_style</NAME>
<RETURNS>void 	</RETURNS>
GtkWidget	*widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_ensure_style</NAME>
<RETURNS>void 	</RETURNS>
GtkWidget	*widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_get_style</NAME>
<RETURNS>GtkStyle *</RETURNS>
GtkWidget	*widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_restore_default_style</NAME>
<RETURNS>void 	</RETURNS>
GtkWidget	*widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_modify_style</NAME>
<RETURNS>void  </RETURNS>
GtkWidget      *widget,GtkRcStyle     *style
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_set_composite_name</NAME>
<RETURNS>void  </RETURNS>
GtkWidget	*widget,gchar     	*name
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_get_composite_name</NAME>
<RETURNS>gchar *</RETURNS>
GtkWidget	*widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_reset_rc_styles</NAME>
<RETURNS>void  </RETURNS>
GtkWidget      *widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_push_style</NAME>
<RETURNS>void 	</RETURNS>
GtkStyle	 *style
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_push_colormap</NAME>
<RETURNS>void 	</RETURNS>
GdkColormap *cmap
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_push_visual</NAME>
<RETURNS>void 	</RETURNS>
GdkVisual	 *visual
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_push_composite_child</NAME>
<RETURNS>void 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_pop_composite_child</NAME>
<RETURNS>void 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_pop_style</NAME>
<RETURNS>void 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_pop_colormap</NAME>
<RETURNS>void 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_pop_visual</NAME>
<RETURNS>void 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_set_default_style</NAME>
<RETURNS>void 	</RETURNS>
GtkStyle	  *style
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_set_default_colormap</NAME>
<RETURNS>void 	</RETURNS>
GdkColormap *colormap
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_set_default_visual</NAME>
<RETURNS>void 	</RETURNS>
GdkVisual	  *visual
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_get_default_style</NAME>
<RETURNS>GtkStyle *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_get_default_colormap</NAME>
<RETURNS>GdkColormap *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_get_default_visual</NAME>
<RETURNS>GdkVisual *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_shape_combine_mask</NAME>
<RETURNS>void 	</RETURNS>
GtkWidget *widget,GdkBitmap *shape_mask,gint       offset_x,gint       offset_y
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_reset_shapes</NAME>
<RETURNS>void 	</RETURNS>
GtkWidget *widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_path</NAME>
<RETURNS>void 	</RETURNS>
GtkWidget *widget,guint     *path_length,gchar    **path,gchar    **path_reversed
</FUNCTION>
<FUNCTION>
<NAME>gtk_widget_class_path</NAME>
<RETURNS>void 	</RETURNS>
GtkWidget *widget,guint     *path_length,gchar    **path,gchar    **path_reversed
</FUNCTION>
<MACRO>
<NAME>gtk_widget_ref</NAME>
#  define gtk_widget_ref gtk_object_ref
</MACRO>
<MACRO>
<NAME>gtk_widget_unref</NAME>
#  define gtk_widget_unref gtk_object_unref
</MACRO>
<MACRO>
<NAME>GTK_TYPE_WINDOW</NAME>
#define GTK_TYPE_WINDOW			(gtk_window_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_WINDOW</NAME>
#define GTK_WINDOW(obj)			(GTK_CHECK_CAST (obj, GTK_TYPE_WINDOW, GtkWindow))
</MACRO>
<MACRO>
<NAME>GTK_WINDOW_CLASS</NAME>
#define GTK_WINDOW_CLASS(klass)		(GTK_CHECK_CLASS_CAST (klass, GTK_TYPE_WINDOW, GtkWindowClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_WINDOW</NAME>
#define GTK_IS_WINDOW(obj)		(GTK_CHECK_TYPE (obj, GTK_TYPE_WINDOW))
</MACRO>
<MACRO>
<NAME>GTK_IS_WINDOW_CLASS</NAME>
#define GTK_IS_WINDOW_CLASS(klass)	(GTK_CHECK_CLASS_TYPE (klass, GTK_TYPE_WINDOW))
</MACRO>
<STRUCT>
<NAME>GtkWindow</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkWindowClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkWindow</NAME>
struct GtkWindow
{
  GtkBin bin;

  gchar *title;
  gchar *wmclass_name;
  gchar *wmclass_class;
  GtkWindowType type;

  GtkWidget *focus_widget;
  GtkWidget *default_widget;
  GtkWindow *transient_parent;

  gushort resize_count;
  guint allow_shrink : 1;
  guint allow_grow : 1;
  guint auto_shrink : 1;
  guint handling_resize : 1;
  guint position : 2;

  /* The following flag is initially TRUE when a window is mapped.
   * and will be set to FALSE after it is first positioned.
   * It is also temporarily reset when the window's size changes.
   * 
   * When TRUE, we move the window to the position the app set.
   */
  guint use_uposition : 1;
  guint modal : 1;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_window_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_window_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GtkWindowType        type
</FUNCTION>
<FUNCTION>
<NAME>gtk_window_set_title</NAME>
<RETURNS>void  </RETURNS>
GtkWindow           *window,const gchar         *title
</FUNCTION>
<FUNCTION>
<NAME>gtk_window_set_wmclass</NAME>
<RETURNS>void  </RETURNS>
GtkWindow           *window,const gchar         *wmclass_name,const gchar         *wmclass_class
</FUNCTION>
<FUNCTION>
<NAME>gtk_window_set_policy</NAME>
<RETURNS>void  </RETURNS>
GtkWindow           *window,gint                 allow_shrink,gint                 allow_grow,gint                 auto_shrink
</FUNCTION>
<FUNCTION>
<NAME>gtk_window_add_accel_group</NAME>
<RETURNS>void  </RETURNS>
GtkWindow           *window,GtkAccelGroup	    *accel_group
</FUNCTION>
<FUNCTION>
<NAME>gtk_window_remove_accel_group</NAME>
<RETURNS>void  </RETURNS>
GtkWindow           *window,GtkAccelGroup	    *accel_group
</FUNCTION>
<FUNCTION>
<NAME>gtk_window_set_position</NAME>
<RETURNS>void  </RETURNS>
GtkWindow           *window,GtkWindowPosition    position
</FUNCTION>
<FUNCTION>
<NAME>gtk_window_activate_focus</NAME>
<RETURNS>gint 	</RETURNS>
GtkWindow           *window
</FUNCTION>
<FUNCTION>
<NAME>gtk_window_activate_default</NAME>
<RETURNS>gint 	</RETURNS>
GtkWindow           *window
</FUNCTION>
<FUNCTION>
<NAME>gtk_window_set_transient_for</NAME>
<RETURNS>void  </RETURNS>
GtkWindow           *window,GtkWindow           *parent
</FUNCTION>
<FUNCTION>
<NAME>gtk_window_set_geometry_hints</NAME>
<RETURNS>void  </RETURNS>
GtkWindow           *window,GtkWidget           *geometry_widget,GdkGeometry         *geometry,GdkWindowHints       geom_mask
</FUNCTION>
<FUNCTION>
<NAME>gtk_window_set_default_size</NAME>
<RETURNS>void  </RETURNS>
GtkWindow           *window,gint                 width,gint                 height
</FUNCTION>
<FUNCTION>
<NAME>gtk_window_set_modal</NAME>
<RETURNS>void  </RETURNS>
GtkWindow           *window,gboolean             modal
</FUNCTION>
<FUNCTION>
<NAME>gtk_window_set_focus</NAME>
<RETURNS>void  </RETURNS>
GtkWindow           *window,GtkWidget           *focus
</FUNCTION>
<FUNCTION>
<NAME>gtk_window_set_default</NAME>
<RETURNS>void  </RETURNS>
GtkWindow           *window,GtkWidget           *defaultw
</FUNCTION>
<FUNCTION>
<NAME>gtk_window_remove_embedded_xid</NAME>
<RETURNS>void  </RETURNS>
GtkWindow           *window,guint                xid
</FUNCTION>
<FUNCTION>
<NAME>gtk_window_add_embedded_xid</NAME>
<RETURNS>void  </RETURNS>
GtkWindow           *window,guint                xid
</FUNCTION>
